
/*
Easy
Copyright (C) 2024 Università degli Studi di Catania (www.unict.it)
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;

namespace Backend.Components {
    class UtilsFile {
        public string FileName { get; set; }
        public string TempFolder { get; set; }
        public int MaxFileSizeMB { get; set; }
        public List<String> FileParts { get; set; }

        public UtilsFile() {
            FileParts = new List<string>();
        }

        /// <summary>
        /// original name + ".part_N.X" (N = file part number, X = total files)
        /// Merges a chunk into the output file. Actually, output file is created only where all chunk ha been uploaded
        /// If every chunk has been uploaded, merge them and return true.
        /// </summary>
        /// <param name="FileName"></param>
        /// <returns></returns> empty or the guid. the name of the file save on the file system
        public string MergeFile(string FileName) {
            string rslt = "";
            // parse out the different tokens from the filename according to the convention
            string partToken = ".part_";
            string baseFileName = FileName.Substring(0, FileName.IndexOf(partToken));
            string trailingTokens = FileName.Substring(FileName.IndexOf(partToken) + partToken.Length);
            int FileIndex = 0;
            int FileCount = 0;
            int.TryParse(trailingTokens.Substring(0, trailingTokens.IndexOf(".")), out FileIndex);
            int.TryParse(trailingTokens.Substring(trailingTokens.LastIndexOf(".") + 1), out FileCount);
            // get a list of all file parts in the temp folder
            string Searchpattern = Path.GetFileName(baseFileName) + partToken + "*";
            string[] FilesList = Directory.GetFiles(Path.GetDirectoryName(FileName), Searchpattern);
            //  merge
            if (FilesList.Count() == FileCount) {
                // use a singleton to stop overlapping processes
                //NINO: TODO: non funziona, si perde i pezzi a random, manca un lock, un wait, qualsiasi cosa che 
                // rimedi al fatto che se lo trova in uso non fa niente e si salta un pezzo a vita
                if (!MergeFileManager.Instance.InUse(baseFileName)) {
                    MergeFileManager.Instance.AddFile(baseFileName);
                    if (File.Exists(baseFileName))
                        File.Delete(baseFileName);
                    // add each file located to a list so we can get them into 
                    // the correct order for rebuilding the file
                    List<SortedFile> MergeList = new List<SortedFile>();
                    foreach (string File in FilesList) {
                        SortedFile sFile = new SortedFile();
                        sFile.FileName = File;
                        baseFileName = File.Substring(0, File.IndexOf(partToken));
                        trailingTokens = File.Substring(File.IndexOf(partToken) + partToken.Length);
                        int.TryParse(trailingTokens.Substring(0, trailingTokens.IndexOf(".")), out FileIndex);
                        sFile.FileOrder = FileIndex;
                        MergeList.Add(sFile);
                    }
                    // sort by the file-part number to ensure we merge back in the correct order
                    var MergeOrder = MergeList.OrderBy(s => s.FileOrder).ToList();
                    // file path name. path uplod + the guid generated by server
                    string attachFileName = Path.GetFileName(baseFileName);
                    string attachPathFileName = Path.GetDirectoryName(FileName) + "//" + attachFileName;
                    using (FileStream FS = new FileStream(attachPathFileName, FileMode.Create)) {
                        // merge each file chunk back into one contiguous file stream
                        foreach (var chunk in MergeOrder) {
                            try {
                                using (FileStream fileChunk = new FileStream(chunk.FileName, FileMode.Open)) {
                                    fileChunk.CopyTo(FS);
                                }
                            }
                            catch (IOException ex) {
                                // handle     
                                var m = ex.Message;
                            }
                        }
                    }

                   
                    // delete partial file, after the merging
                    foreach (var chunk in MergeOrder) {
                        try {
                           File.Delete(chunk.FileName);  
                        } catch (IOException ex){
                            // handle     
                            var m = ex.Message;
                        }
                    }

                    rslt = attachPathFileName;

                    // unlock the file from singleton
                    MergeFileManager.Instance.RemoveFile(baseFileName);
                }
            }

            return rslt;
        }

    }

    public struct SortedFile {
        public int FileOrder { get; set; }
        public String FileName { get; set; }
    }

    public class MergeFileManager {
        private static MergeFileManager instance;
        private List<string> MergeFileList;

        private MergeFileManager() {
            try {
                MergeFileList = new List<string>();
            }
            catch { }
        }

        public static MergeFileManager Instance {
            get {
                if (instance == null)
                    instance = new MergeFileManager();
                return instance;
            }
        }

        public void AddFile(string BaseFileName) {
            MergeFileList.Add(BaseFileName);
        }

        public bool InUse(string BaseFileName) {
            return MergeFileList.Contains(BaseFileName);
        }

        public bool RemoveFile(string BaseFileName) {
            return MergeFileList.Remove(BaseFileName);
        }
    }

}
