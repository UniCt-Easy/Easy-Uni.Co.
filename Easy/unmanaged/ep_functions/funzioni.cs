
/*
Easy
Copyright (C) 2024 Università degli Studi di Catania (www.unict.it)
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


using System;
using System.Data;
using System.Windows.Forms;
using metadatalibrary;
using funzioni_configurazione;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net.Configuration;
using System.Runtime.Remoting.Messaging;
using System.Text;
using System.Windows.Forms.VisualStyles;
using metaeasylibrary;
using q = metadatalibrary.MetaExpression;

namespace ep_functions {


    public class ep_poster : InnerPosting {
        public PostData p;
        private IDataAccess conn;
        Hashtable msgsToIgnore = new Hashtable();

        public PostData innerPostClass {
            get { return p; }
        }

        public EasyProcedureMessageCollection EPResult;

        public virtual bool saveData(DataSet d, PostData post) {

            var msg = epm.getMessages();
            if (msg.Count > 0 && !msg.CanIgnore) return false;

            post.innerPosting = true;
            post.addMessagesToIgnore(hashMessagesToIgnore());
            post.initClass(d, conn);

            var listaMsg = post.DO_POST_SERVICE();

            if (listaMsg.Count > 0) {
                string what = listaMsg.CanIgnore ? "Avvertimenti" : "Errori";
                mergeMessages(listaMsg);
                string error = $"{what} nel salvataggio dei movimenti di budget";
                if (d.Tables.Contains("epexp") && d.Tables["epexp"].Rows.Count == 0 && d.Tables.Contains("epacc") &&
                    d.Tables["epacc"].Rows.Count == 0) {
                    error = $"{what} nel salvataggio delle scritture";
                }

                EasyProcedureMessageCollection lm = new EasyProcedureMessageCollection();
                if (listaMsg.CanIgnore) {
                    lm.AddWarning(error);
                }
                else {
                    lm.AddDBSystemError(error);
                }

                mergeMessages(lm);
                return epm.getMessages().CanIgnore;
            }

            return true;
        }

        public Hashtable hashMessagesToIgnore() {
            return msgsToIgnore;
        }

        public void afterPost(bool committed) {
            if (!committed) epm.revertPostingChanges();
            epm.mostraEtichette();
        }

        /// <summary>
        /// Adds messages to the resulting messages list
        /// </summary>
        /// <param name="messages"></param>
        public void mergeMessages(ProcedureMessageCollection messages) {
            messages.SkipMessages(msgsToIgnore);
            epm.mergeMessages(messages);
        }

        public void initClass(DataSet ds, IDataAccess conn) {
            this.conn = conn;
            msgsToIgnore.Clear();
        }

        public void reselectAllViewsAndAcceptChanges() {
            p?.reselectAllViewsAndAcceptChanges();
        }

        public InnerPosting getInnerPosting() {
            if (p == null) return null;
            return PostData.getInnerPosting(p.DS);
        }

        public void setInnerPosting(Hashtable ignoredMessages) {
            foreach (var s in ignoredMessages.Keys) {
                msgsToIgnore[s] = 1;
            }
        }


        public virtual ProcedureMessageCollection DO_POST_SERVICE() {
            //effettua tutte le operazioni che avrebbe fatto
            // Il beforePost è già stato invocato correttamente
            bool saved = epm.silent;
            epm.silent = true;
            epm.silentBlocked = true;

            epm.clearMessages();

            epm.invokedByInnerPosting = true;
            epm.afterPost(true);
            epm.invokedByInnerPosting = false;
            epm.silent = saved;
            epm.silentBlocked = false;
            return epm.getMessages();
        }

        private EP_Manager epm;

        public ep_poster(EP_Manager ep_manager) {
            epm = ep_manager;
        }
    }


    public class EP_Manager : IDisposable {
        DataAccess Conn;
        int esercizio;
        Button btnGeneraImpegni;
        Button btnVisualizzaImpegni;
        Button btnGeneraPreImpegni;
        Button btnVisualizzaPreImpegni;
        Button btnGeneraScritture;
        Button btnVisualizzaScritture;
        Label labScritture;
        Label labInformazioni;
        private MetaData meta;
        MetaDataDispatcher Disp;
        public EP_functions EP;
        DataSet DS;
        string mainTable;
        Control[] allBtn;
        Control[] allLab;
        QueryHelper QHS;
        public bool UsaImpegniDiBudget;
        public bool UsaAccertamentiDiBudget;
        public bool UsaScritture;
        CQueryHelper QHC = new CQueryHelper();
        public bool invokedByInnerPosting = false;

        public DataSet GetPostingDataSet() {
            return EP.D;
        }

        struct changeToRevert {
            public string Field;
            public DataRow R;
            public object OriginalValue;
        }


        public void doChange(DataRow r, string field, object value) {
            if (invokedByInnerPosting) {
                changesToRevert.Add(new changeToRevert() {Field = field, OriginalValue = r[field], R = r});
                r[field] = value;
            }
            else {
                r[field] = value;
                r.AcceptChanges();
            }
        }

        List<changeToRevert> changesToRevert = new List<changeToRevert>();

        public void resetChanges() {
            if (!invokedByInnerPosting) return;
            changesToRevert.Clear();
        }

        public void revertPostingChanges() {
            //if (!invokedByInnerPosting)return;
            foreach (var c in changesToRevert) {
                if (c.R.RowState == DataRowState.Deleted) {
                    continue; //non è possibile assegnare i valori di una riga che è in stato di deleted
                }

                c.R[c.Field] = c.OriginalValue;
            }

            changesToRevert.Clear();
        }


        bool ricevi_broadcast = true;

        void MetaData_messageBroadcaster(object sender, object message) {
            if (ricevi_broadcast) {
                if (message.ToString() == "EntrySaved" || message.ToString() == "EpExpSaved") {
                    mostraEtichette();
                    if (mainTable == "mandate") {
                        checkForMissingEpExp(DS.Tables["mandatedetail"]);
                    }

                    if (mainTable == "invoice") {
                        checkForMissingEpExp(DS.Tables["invoicedetail"]);
                    }
                }

            }
        }

        private object getAccountTreasurer(object idtreasurer, string kind) {
            object idaccmotive;
            if (kind == "D") {
                idaccmotive = Conn.DO_READ_VALUE("treasurer", QHS.CmpEq("idtreasurer", idtreasurer),
                    "idaccmotive_payment");
            }
            else {
                idaccmotive = Conn.DO_READ_VALUE("treasurer", QHS.CmpEq("idtreasurer", idtreasurer),
                    "idaccmotive_proceeds");
            }

            if (idaccmotive == DBNull.Value) {
                string messaggio = "Non è stata configurata la causale relativa alla distinta di trasmissione"
                                   + "\n Non verranno generate le scritture in Partita Doppia"
                                   + "\nPer configurare tale causale andare dal menu:"
                                   + "\nConfigurazione - Tesoriere - Tesoriere";
                ShowMessage(messaggio, "Attenzione");
                return DBNull.Value;
            }

            DataRow[] contiBanca = EP.GetAccMotiveDetails(idaccmotive);
            if (contiBanca.Length == 0) {
                ShowMessage("La causale del pagamento / incasso a banca non è ben configurata.", "Errore");
                return DBNull.Value;
            }

            return contiBanca[0]["idacc"];

        }

        void checkForMissingEpExp(DataTable t) {
            foreach (DataRow r in t.Select()) {
                if (r.RowState != DataRowState.Unchanged) continue;
                object idepexp = r["idepexp"];
                if (idepexp == DBNull.Value) continue;
                if (Conn.RUN_SELECT_COUNT("epexp", QHS.CmpEq("idepexp", idepexp), false) == 0) {
                    doChange(r, "idepexp", DBNull.Value);
                }
            }
        }

        public void Dispose() {
            MetaData.messageBroadcaster -= MetaData_messageBroadcaster;
            disableIntegratedPosting();
            changesToRevert?.Clear();
            changesToRevert = null;

        }

        /// <summary>
        /// Anagrafica per il versamento dell'iva intracom istituzionale
        /// </summary>
        private readonly object _idregVersamento12;

        private object _idrateo_attivo;
        private object _idrateo_passivo;

        /// <summary>
        /// Anagrafica per il rimborso dell'iva intracom istituzionale
        /// </summary>
        private readonly object _idregRimborso12;



        /// <summary>
        /// Conto per le fatture da ricevere
        /// </summary>
        private readonly object _idaccInvoicetoreceive;

        private readonly DataRow _rConfig;

        /// <summary>
        /// Conto per le fatture da emettere
        /// </summary>
        private readonly object _idaccInvoicetoemit;

        private bool modoCalcoloRigaPerRiga;
        private bool usaContiPresentazioneDocumenti;

        public void setPostingClass(ep_poster poster) {
            this.postingClass = poster;
        }

        public void update(DataSet d) {
            this.DS = d;

            object eco_entry = Conn.GetUsr("eco_entry");
            if (eco_entry == null || eco_entry.ToString() == "") eco_entry = "'S'";

            PostData.setInnerPosting(DS, null);
            if (eco_entry.ToString().ToUpper() == "'S'") {
                if (mainTable == "mandate" || mainTable == "estimate" || mainTable == "invoice") {
                    postingClass = new ep_poster(this);
                    PostData.setInnerPosting(DS, postingClass);
                }
            }


        }

        public class TaxInfo {
            public DataRow taxRow;
            public DataRow taxmotiveRow;
            int taxcode;
            public Dictionary<int, DataRow> taxServiceRow = new Dictionary<int, DataRow>();

            public TaxInfo(int taxcode) {
                this.taxcode = taxcode;
            }

            public void addServiceDetail(int idser, DataRow r) {
                if (taxServiceRow.ContainsKey(idser)) {
                    taxServiceRow[idser] = r;
                    return;
                }

                ;
                taxServiceRow.Add(idser, r);
            }

            public DataRow getInfo(int idser) {
                if (idser == 0) return taxmotiveRow;
                if (taxServiceRow.ContainsKey(idser)) return taxServiceRow[idser];
                return taxmotiveRow;
            }

            public static TaxInfo getInfo(Dictionary<int, TaxInfo> allTax, int taxcode) {
                if (!allTax.ContainsKey(taxcode)) return null;
                return allTax[taxcode];
            }

            public static void addTaxInfo(Dictionary<int, TaxInfo> allTax, int taxcode, DataRow taxRow) {
                if (!allTax.ContainsKey(taxcode)) {
                    allTax.Add(taxcode, new TaxInfo(taxcode));
                }

                allTax[taxcode].taxRow = taxRow;

            }

            public string taxRef() {
                if (taxRow == null) {
                    return "Ritenuta di chiave " + taxcode + " non presente";
                }

                return taxRow["taxref"].ToString();
            }

            public static void addMotiveInfo(Dictionary<int, TaxInfo> allTax, int taxcode, int idser,
                DataRow taxmotiveRow) {
                if (!allTax.ContainsKey(taxcode)) {
                    allTax.Add(taxcode, new TaxInfo(taxcode));
                }

                if (idser != 0) {
                    allTax[taxcode].addServiceDetail(idser, taxmotiveRow);
                }
                else {
                    allTax[taxcode].taxmotiveRow = taxmotiveRow;
                }

            }
        }

        public void disableIntegratedPosting() {
            postingClass = null;
            if (DS != null) {
                PostData.setInnerPosting(DS, null);
            }

        }

        Dictionary<int, TaxInfo> taxInfo = new Dictionary<int, TaxInfo>();
        int minimoAnnoImpegniDiBudget = 0;

        public EP_Manager(MetaData meta, Button generaImp, Button viewImp, Button generaPreImp, Button viewPreImp,
            Button generaEntry,
            Button viewEntry, Label labEntry, Label labWarn, string mainTable) {
            this.btnGeneraImpegni = generaImp;
            this.btnGeneraPreImpegni = generaPreImp;
            this.btnGeneraScritture = generaEntry;
            this.btnVisualizzaImpegni = viewImp;
            this.btnVisualizzaPreImpegni = viewPreImp;
            this.btnVisualizzaScritture = viewEntry;
            this.labInformazioni = labWarn;
            this.labScritture = labEntry;
            Form f = btnGeneraImpegni?.FindForm() ??
                     btnVisualizzaImpegni?.FindForm() ??
                     btnGeneraScritture?.FindForm() ??
                     btnVisualizzaImpegni?.FindForm();
            if (f != null) f.Disposed += (o, k) => { Dispose(); };
            this.meta = meta;
            this.Conn = meta.Conn;
            this.QHS = Conn.GetQueryHelper();
            this.esercizio = Conn.GetEsercizio();
            this.Disp = meta.Dispatcher;
            this.EP = new EP_functions(Disp);
            this.DS = meta.DS;
            this.mainTable = mainTable;
            allBtn = new Control[] {
                btnGeneraImpegni, btnVisualizzaImpegni,
                btnGeneraPreImpegni, btnVisualizzaPreImpegni,
                btnGeneraScritture, btnVisualizzaScritture
            };
            allLab = new Control[] {labScritture, labInformazioni};

            List<SelectBuilder> allSel = new List<SelectBuilder>();
            DataTable config = Conn.CreateTableByName("config", "*");
            allSel.Add(new SelectBuilder("*").IntoTable(config).Where(QHS.CmpEq("ayear", esercizio)));
            DataTable _tax = Conn.CreateTableByName("tax", "*");
            allSel.Add(new SelectBuilder("*").IntoTable(_tax));
            DataTable _taxmotive = Conn.CreateTableByName("taxmotiveyear", "*");
            allSel.Add(new SelectBuilder("*").IntoTable(_taxmotive).Where(QHS.CmpEq("ayear", esercizio)));
            Conn.MULTI_RUN_SELECT(allSel);

            //DataTable config = Conn.RUN_SELECT("config", "*", null, QHS.CmpEq("ayear", esercizio), null, null, false);
            //DataTable _tax = Conn.RUN_SELECT("tax", "*", null, null, null, false);
            //DataTable _taxmotive = Conn.RUN_SELECT("taxmotiveyear", "*", null, QHS.CmpEq("ayear", esercizio), null, false);

            foreach (DataRow r in _tax.Rows) {
                TaxInfo.addTaxInfo(taxInfo, CfgFn.GetNoNullInt32(r["taxcode"]), r);
            }

            foreach (DataRow r in _taxmotive.Rows) {
                TaxInfo.addMotiveInfo(taxInfo, CfgFn.GetNoNullInt32(r["taxcode"]), CfgFn.GetNoNullInt32(r["idser"]), r);
            }

            _teh = new TaxEntryHelper(Conn);
            DataRow currInvSetup = config.Rows[0];
            _rConfig = currInvSetup;
            string flagEpExp = currInvSetup["flagepexp"].ToString().ToUpper();

            minimoAnnoImpegniDiBudget =
                CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("config", QHS.CmpEq("flagepexp", "S"), "min(ayear)"));
            _idregVersamento12 = currInvSetup["paymentagency12"];
            _idregRimborso12 = currInvSetup["refundagency12"];
            _idaccInvoicetoreceive = currInvSetup["idacc_invoicetoreceive"];
            _idaccInvoicetoemit = currInvSetup["idacc_invoicetoemit"];
            _idrateo_attivo = currInvSetup["idacc_accruedrevenue"];
            _idrateo_passivo = currInvSetup["idacc_accruedcost"];

            modoCalcoloRigaPerRiga = _rConfig["flagivapaybyrow"].ToString().ToUpper() == "S";
            
            UsaImpegniDiBudget = (flagEpExp == "S");
            UsaScritture = EP.attivo;
            UsaAccertamentiDiBudget = UsaImpegniDiBudget;
            object idaccPayment = _rConfig["idacc_bankpaydoc"];
            usaContiPresentazioneDocumenti = (idaccPayment != DBNull.Value);
            object eco_entry = Conn.GetUsr("eco_entry");
            if (eco_entry == null || eco_entry.ToString() == "") eco_entry = "'S'";

            if (DS != null) {
                PostData.setInnerPosting(DS, null);
                if (eco_entry.ToString().ToUpper() == "'S'") {
                    if (mainTable == "mandate" || mainTable == "estimate" || mainTable == "invoice") {
                        postingClass = new ep_poster(this);
                        PostData.setInnerPosting(DS, postingClass);
                    }
                }
            }

            if (btnGeneraPreImpegni != null) {
                btnGeneraPreImpegni.Click += BtnGeneraPreImpegni_Click;
            }

            if (btnGeneraImpegni != null) {
                btnGeneraImpegni.Click += BtnGeneraImpegni_Click;
            }

            if (btnVisualizzaImpegni != null) {
                btnVisualizzaImpegni.Click += BtnVisualizzaImpegni_Click;
            }

            if (btnVisualizzaPreImpegni != null) {
                btnVisualizzaPreImpegni.Click += BtnVisualizzaPreImpegni_Click;
            }

            if (btnGeneraScritture != null) {
                btnGeneraScritture.Click += BtnGeneraScritture_Click;
            }

            if (btnVisualizzaScritture != null) {
                btnVisualizzaScritture.Click += BtnVisualizzaScritture_Click;
            }

            object oggi = Conn.DO_SYS_CMD("select getdate()");
            DateSys = (DateTime) oggi;

            MetaData.messageBroadcaster += MetaData_messageBroadcaster;
        }


        private DateTime DateSys;

        private void BtnVisualizzaScritture_Click(object sender, EventArgs e) {
            editEntry();
        }

        public void clearMessages() {
            listaMessaggi.Clear();
            listaMessaggi.CanIgnore = true;
        }

        public void mergeMessages(ProcedureMessageCollection messages) {
            listaMessaggi.Add(messages);
        }

        public ProcedureMessageCollection getMessages() {
            return listaMessaggi;
        }

        ProcedureMessageCollection listaMessaggi = new EasyProcedureMessageCollection();

        private void BtnGeneraScritture_Click(object sender, EventArgs e) {
            if (!meta.IsEmpty) {
                if (!meta.GetFormData(true)) return;
            }

            listaMessaggi = new EasyProcedureMessageCollection();
            PostData.RemoveFalseUpdates(DS);
            DataRow r = getCurrentRow();
            if (r == null) return;
            if (DS.HasChanges()) {
                ShowMessage("E' necessario salvare prima di generare le scritture.");
                return;
            }

            if (mainTable == "csa_import") {
                if (!VerificaProblemiCsa(r)) {
                    ShowMessage("Rilevati problemi nei dati importati, effettuare le verifiche opportune", "Errore");
                    return;
                }
            }

            if (generaScritture()) {
                mostraEtichette();
                editEntry();
            }


        }

        void ShowMessage(string error, string title = null, bool unrecoverable = true) {
            var msg = new EasyProcedureMessage();
            msg.ErrorType = unrecoverable ? "Errore" : "Avvertimento";
            msg.AuditID = "client";
            msg.Enabled = true;
            msg.EnforcementNumber = "1";
            msg.ShortMess = title ?? "Controlli su EP";
            msg.LongMess = error;
            listaMessaggi.Add(msg);
            if (title == null) title = unrecoverable ? "Errore" : "Avviso";
            if (!invokedByInnerPosting && !silent)
                MetaFactory.factory.getSingleton<IMessageShower>().Show(error, title);
        }

        private void BtnVisualizzaPreImpegni_Click(object sender, EventArgs e) {
            editEpExp(1);
        }

        private void BtnVisualizzaImpegni_Click(object sender, EventArgs e) {
            editEpExp(2);
        }

        private void BtnGeneraImpegni_Click(object sender, EventArgs e) {
            if (!meta.IsEmpty) {
                if ((!meta.GetFormData(true)) && (mainTable != "csa_import")) return;
            }

            PostData.RemoveFalseUpdates(DS);
            DataRow r = getCurrentRow();
            if (r == null) return;
            if (DS.HasChanges()) {
                ShowMessage("E' necessario salvare prima di generare i movimenti di budget");
                return;
            }

            if (mainTable == "csa_import") {
                if (!VerificaProblemiCsa(r)) {
                    ShowMessage("Rilevati problemi nei dati importati, effettuare le verifiche opportune", "Errore");
                    return;
                }
            }


            bool scritturegenerate;
            bool impegniGenerati;
            int nphase = CfgFn.GetNoNullInt32(((Button) sender).Tag);
            if (generaImpegniAccertamenti(nphase, out scritturegenerate, out impegniGenerati)) {
                if (impegniGenerati) editEpExp(nphase);
            }
        }

        private void BtnGeneraPreImpegni_Click(object sender, EventArgs e) {
            if (!meta.IsEmpty) {
                if (!meta.GetFormData(true)) return;
            }

            PostData.RemoveFalseUpdates(DS);
            DataRow r = getCurrentRow();
            if (r == null) return;
            if (DS.HasChanges()) {
                ShowMessage("E' necessario salvare prima di generare i movimenti di budget");
                return;
            }

            if (mainTable == "csa_import") {
                if (!VerificaProblemiCsa(r)) {
                    ShowMessage("Rilevati problemi nei dati importati, effettuare le verifiche opportune", "Errore");
                    return;
                }
            }

            int nphase = CfgFn.GetNoNullInt32(((Button) sender).Tag);
            bool scritturegenerate;
            bool impegniGenerati;
            if (generaImpegniAccertamenti(nphase, out scritturegenerate, out impegniGenerati)) {
                if (impegniGenerati) editEpExp(nphase);
            }
        }

        object getIdAccFromMotive(object idAccMotive, object idupb = null) {
            if (idAccMotive == DBNull.Value || idAccMotive == null) return null;
            var rEntries = EP.GetAccMotiveDetails(idAccMotive);
            if (rEntries == null || rEntries.Length == 0) return null;
            return getRightIdAcc(rEntries[0]["idacc"].ToString(), idupb);

        }

        Dictionary<string, bool> upbSpecial = new Dictionary<string, bool>();

        bool isUpbSpecial(object idupb) {
            if (idupb == null || idupb == DBNull.Value)
                return false;
            if (upbSpecial.ContainsKey(idupb.ToString()))
                return upbSpecial[idupb.ToString()];
            bool isspecial =
                CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("upb", QHS.CmpEq("idupb", idupb), "(flagkind&4)")) != 0;
            upbSpecial.Add(idupb.ToString(), isspecial);
            return isspecial;
        }

        Dictionary<string, string> idaccspecial = new Dictionary<string, string>();

        string getSpecialAcc(string idacc) {
            if (idaccspecial.ContainsKey(idacc))
                return idaccspecial[idacc];
            object spec = Conn.DO_READ_VALUE("account", QHS.CmpEq("idacc", idacc), "idacc_special");
            if (spec == null || spec == DBNull.Value || spec.ToString() == "")
                spec = idacc;
            idaccspecial[idacc] = spec.ToString();
            return spec.ToString();
        }

        string getRightIdAcc(string idacc, object idupb) {
            if (isUpbSpecial(idupb))
                return getSpecialAcc(idacc);
            return idacc;
        }

        public object getIdAccForDocument(DataRow r, object idupb) {
            switch (r.Table.TableName) {
                case "mandatedetail":
                    return getIdAccFromMotive(r["idaccmotive"], idupb);
                case "invoicedetail":
                    return getIdAccFromMotive(r["idaccmotive"], idupb);
                case "estimatedetail":
                    return getIdAccFromMotive(r["idaccmotive"], idupb);
            }

            return null;
        }

        public void setForcedCurrentRow(DataRow forcedCurr) {
            _forcedCurrent = forcedCurr;
        }

        DataRow _forcedCurrent;

        DataRow getCurrentRow() {
            if (_forcedCurrent != null) return _forcedCurrent;
            if (DS.Tables[mainTable].Select().Length == 0) return null;
            return DS.Tables[mainTable].Select()[0];
        }

        void showHide(bool show, params Control[] btns) {
            for (int i = 0; i < btns.Length; i++) {
                Control b = btns[i];
                if (b == null) continue;
                b.Visible = show;
            }
        }

        void specialMessagesEntry() {
            showHide(true, labInformazioni);
        }

        bool specialMessagesEntry(DataRow r) {
            if (r == null) {
                return false;
            }

            showHide(false, labInformazioni);
            if (mainTable == "mandate") {
                //Per gli ordini verifica che ci siano dettagli di pertinenza dell'anno corrente
                if (CfgFn.GetNoNullInt32(r["yman"]) == esercizio) return false;
                bool detailsFound = false;
                foreach (DataRow md in DS.Tables["mandatedetail"].Rows) {
                    if (md.RowState != DataRowState.Deleted) {
                        if (md["start"] != DBNull.Value) {
                            if (((DateTime) md["start"]).Year == esercizio) detailsFound = true;
                        }

                        if (md["stop"] != DBNull.Value) {
                            if (((DateTime) md["stop"]).Year == esercizio) detailsFound = true;
                        }
                    }

                    if (md.RowState != DataRowState.Added) {
                        if (md["start", DataRowVersion.Original] != DBNull.Value) {
                            if (((DateTime) md["start", DataRowVersion.Original]).Year == esercizio)
                                detailsFound = true;
                        }

                        if (md["stop", DataRowVersion.Original] != DBNull.Value) {
                            if (((DateTime) md["stop", DataRowVersion.Original]).Year == esercizio) detailsFound = true;
                        }
                    }

                    if (detailsFound) break;
                }

                if (!detailsFound) {
                    showHide(false, btnGeneraScritture, btnVisualizzaScritture, labScritture);
                    specialMessagesEntry();
                    return true;
                }

                return false;
            }

            if (mainTable == "estimate") {
                //Per gli ordini verifica che ci siano dettagli di pertinenza dell'anno corrente
                if (CfgFn.GetNoNullInt32(r["yestim"]) == esercizio) return false;
                bool detailsFound = false;
                foreach (DataRow md in DS.Tables["estimatedetail"].Rows) {
                    if (md.RowState != DataRowState.Deleted) {
                        if (md["start"] != DBNull.Value) {
                            if (((DateTime) md["start"]).Year == esercizio) detailsFound = true;
                        }

                        if (md["stop"] != DBNull.Value) {
                            if (((DateTime) md["stop"]).Year == esercizio) detailsFound = true;
                        }
                    }

                    if (md.RowState != DataRowState.Added) {
                        if (md["start", DataRowVersion.Original] != DBNull.Value) {
                            if (((DateTime) md["start", DataRowVersion.Original]).Year == esercizio)
                                detailsFound = true;
                        }

                        if (md["stop", DataRowVersion.Original] != DBNull.Value) {
                            if (((DateTime) md["stop", DataRowVersion.Original]).Year == esercizio) detailsFound = true;
                        }
                    }

                    if (detailsFound) break;
                }

                if (!detailsFound) {
                    showHide(false, btnGeneraScritture, btnVisualizzaScritture, labScritture);
                    specialMessagesEntry();
                    return true;
                }

                return false;
            }

            if (mainTable == "paymenttransmission") {
                if (r["noep"].ToString().ToUpper() == "S") {
                    specialMessagesEntry();
                    return true;
                }
            }

            if (mainTable == "proceedstransmission") {
                if (r["noep"].ToString().ToUpper() == "S") {
                    specialMessagesEntry();
                    return true;
                }
            }

            if (mainTable == "provision") {
                //Per gli accantonamenti verifica che ci siano dettagli di pertinenza dell'anno corrente
                bool detailsFound = false;
                foreach (DataRow md in DS.Tables["provisiondetail"].Rows) {
                    if (md.RowState != DataRowState.Deleted) {
                        if (md["adate"] != DBNull.Value) {
                            if (((DateTime) md["adate"]).Year == esercizio) detailsFound = true;
                        }
                    }

                    if (md.RowState != DataRowState.Added) {
                        if (md["adate", DataRowVersion.Original] != DBNull.Value) {
                            if (((DateTime) md["adate", DataRowVersion.Original]).Year == esercizio)
                                detailsFound = true;
                        }
                    }

                    if (detailsFound) break;
                }

                if (!detailsFound) {
                    showHide(false, btnGeneraScritture, btnVisualizzaScritture, labScritture);
                    specialMessagesEntry();
                    return true;
                }

                return false;
            }

            return false;
        }

        private DataTable _mainToFollow;
        private DataTable _ghostTable;

        /// <summary>
        /// Nel caso di scritture csa_import a debito crea una copia della tabella principale di nome csa_import.debit
        ///  e usa quella. E' necessario che se DS del meta collegato non contiene la tabella csa_import, che 
        ///  in questo caso la riga principale appartenga ad una tabella con tale nome in quel caso.
        /// </summary>
        private void followMain() {
            if (!DS.Tables.Contains("csa_import")) {
                if (tipoScrittura == "debito" && getCurrentRow().Table.TableName != "csa_import.debit") {
                    MetaData.mainLogError(meta, null, "La tabella principale dovrebbe chiamarsi csa_import.debit",
                        null);
                }

                return; //Sta generando le scritture fuori dal ciclo principale
            }

            if (tipoScrittura == "debito" && mainTable == "csa_import") {
                if (_mainToFollow == null) {
                    _mainToFollow = DS.Tables["csa_import"];
                }

                _ghostTable = _mainToFollow.Copy();
                _ghostTable.TableName = "csa_import.debit";
                if (_ghostTable.Rows.Count > 0) {
                    setForcedCurrentRow(_ghostTable.Rows[0]);
                }
                else {
                    setForcedCurrentRow(null);
                }
            }
        }


        bool cicloAttivo() {
            if (mainTable == "upbcommessa") {
                return false;

            }

            if (mainTable == "estimate") {
                return true;
            }

            if (mainTable == "grantload") {
                return true;
            }

            if (mainTable == "assetunload") {
                return false;
            }

            if (mainTable == "provision") {
                return false;
            }

            return false;
        }

        string tabellaImpegniAccertamenti() {
            return cicloAttivo() ? "epaccview" : "epexpview";
        }

        public bool etichetteAbilitate = true;

        public void mostraEtichette() {
            if (!etichetteAbilitate) return;

            followMain();
            DataRow curr = getCurrentRow();
            //Se non ci sono righe o la riga non è salvata, nascondi tutto
            if (curr == null || curr.RowState == DataRowState.Added) {
                showHide(false, allBtn);
                showHide(false, allLab);
                return;
            }

            string idrelatedEpExp = BudgetFunction.GetIdForDocument(curr);
            string idrelatedEntry = EP_functions.GetIdForDocument(curr);
            string filterEpExp = BudgetFunction.getDocChildCondition(QHS, idrelatedEpExp);
            string filterEntry = BudgetFunction.getDocChildCondition(QHS, idrelatedEntry);
            string tabellaEp = tabellaImpegniAccertamenti(); //epexpview o epaccview
            bool cicloAttivoEsistente = cicloAttivo();

            int nEntry = idrelatedEntry != null
                ? Conn.RUN_SELECT_COUNT("entry", QHS.AppAnd(filterEntry, QHS.CmpEq("yentry", esercizio)), true)
                : 0;
            int nEpExp1 = idrelatedEpExp != null
                ? Conn.RUN_SELECT_COUNT(tabellaEp, //epexpview
                    QHS.AppAnd(filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1)), true)
                : 0; //340ms
            int nEpExp2 = idrelatedEpExp != null
                ? Conn.RUN_SELECT_COUNT(tabellaEp,
                    QHS.AppAnd(filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2)), true)
                : 0; //300ms

            if (doppioMovimento(curr.Table.TableName) && nEpExp1 == 0 && nEpExp2 == 0) {
                nEpExp1 = idrelatedEpExp != null
                    ? Conn.RUN_SELECT_COUNT("epaccview",
                        QHS.AppAnd(filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1)), true)
                    : 0;
                nEpExp2 = idrelatedEpExp != null
                    ? Conn.RUN_SELECT_COUNT("epaccview",
                        QHS.AppAnd(filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2)), true)
                    : 0;
                if (nEpExp1 > 0 || nEpExp2 > 0) cicloAttivoEsistente = true;

            }

            bool abilitaScritture = this.abilitaScritture(curr); // || nEntry > 0;
            bool abilitaPreimpegni = preImpegniAbilitati(curr); // || nEpExp1 > 0;
            bool abilitaImpegni = impegniAbilitati(curr); // || nEpExp2 > 0;

            //TODO: per assetload e csa_import cambiare l'etichetta per includere ambi i movimenti

            string viewPreMov = cicloAttivoEsistente ? "Mostra preaccertamenti di B." : "Mostra preimpegni di budget";
            string generaAllMov = cicloAttivoEsistente
                ? "Genera preaccertamenti ed accertamenti di B."
                : "Genera preimpegni ed impegni di budget";
            string rigeneraAllMov = cicloAttivoEsistente
                ? "Rigenera preaccertamenti ed accertamenti di B."
                : "Rigenera preimpegni ed impegni di budget";
            string generaPreMov = cicloAttivoEsistente ? "Genera preaccertamenti di B." : "Genera preimpegni di B.";
            string viewMov = cicloAttivoEsistente ? "Mostra accertamenti di B." : "Mostra impegni di budget";
            string generaMov = cicloAttivoEsistente ? "Genera accertamenti di B." : "Genera impegni di B.";

            if (doppioMovimento(curr.Table.TableName)) {
                viewPreMov = "Mostra pre-movimenti di B.";
                generaAllMov = "Genera movimenti di B.";
                rigeneraAllMov = "Rigenera movimenti di B.";
                generaPreMov = "genera pre-movimenti di B.";
                viewMov = "Mostra movimenti di B.";
                generaMov = "Genera movimenti di B.";
            }


            if (btnVisualizzaPreImpegni != null) btnVisualizzaPreImpegni.Text = viewPreMov;
            if (UsaImpegniDiBudget && abilitaPreimpegni) {
                //Gestione preimpegni di budget
                if (nEpExp1 == 0) {
                    //Preimpegni abilitati e non presenti
                    if (btnGeneraPreImpegni != null) {
                        if (nEpExp2 == 0 && abilitaImpegni) {
                            btnGeneraPreImpegni.Text = generaAllMov;
                            btnGeneraPreImpegni.Tag = 0;
                        }
                        else {
                            btnGeneraPreImpegni.Text = generaPreMov;
                            btnGeneraPreImpegni.Tag = 1;
                        }
                    }

                    showHide(true, btnGeneraPreImpegni);
                    showHide(false, btnVisualizzaPreImpegni);
                }
                else {
                    showHide(true, btnVisualizzaPreImpegni);
                    //Preimpegni abilitati e presenti
                    if (nEpExp2 > 0) {
                        if (btnGeneraImpegni != null) {
                            btnGeneraPreImpegni.Text = rigeneraAllMov;
                            btnGeneraPreImpegni.Tag = 0;
                        }

                        showHide(true, btnGeneraPreImpegni);
                    }
                    else {
                        //btnGeneraPreImpegni.Text = "Rigenera i preimpegni di budget";
                        showHide(false, btnGeneraPreImpegni);
                    }
                }
            }
            else {
                showHide(false, btnGeneraPreImpegni);
                showHide((nEpExp1 > 0), btnVisualizzaPreImpegni);
            }


            if (btnVisualizzaImpegni != null) btnVisualizzaImpegni.Text = viewMov;
            if (UsaImpegniDiBudget && abilitaImpegni) {
                //Gli impegni di budget possono essere generati anche senza preimpegni, perché uno potrebbe collegarli a preimpegni esistenti
                if (nEpExp2 == 0) {
                    //impegni abilitati  e non presenti
                    if (btnGeneraImpegni != null) {
                        btnGeneraImpegni.Text = generaMov;
                        btnGeneraImpegni.Tag = 2;
                    }

                    showHide(true, btnGeneraImpegni);
                    showHide(false, btnVisualizzaImpegni);
                }
                else {
                    //impegni abilitati  e presenti     
                    showHide(true, btnVisualizzaImpegni);
                    showHide(false, btnGeneraImpegni); //se ci sono i preimpegni vanno rigenerati quelli
                }
            }
            else {
                showHide(false, btnGeneraImpegni);
                showHide((nEpExp2 > 0), btnVisualizzaImpegni);
            }


            //if (esercizio > 2015 && abilitaImpegni && nEpExp2 == 0 && UsaImpegniDiBudget) {
            //    abilitaScritture = false;
            //}

            //Gestisce la visualizzazione dei bottoni e delle label delle SCRITTURE
            if (UsaScritture && abilitaScritture) {
                if (!specialMessagesEntry(curr)) {
                    if (nEntry == 0) {
                        if (labScritture != null) {
                            labScritture.Text = "Le scritture NON sono state generate";
                        }

                        showHide(true, labScritture);
                        if (btnGeneraScritture != null) {
                            btnGeneraScritture.Text = "Genera le scritture in partita doppia";
                        }

                        showHide(true, btnGeneraScritture);
                        showHide(false, btnVisualizzaScritture);
                    }
                    else {
                        if (labScritture != null) {
                            labScritture.Text = "Le scritture sono state generate";
                        }

                        showHide(true, labScritture);
                        if (btnGeneraScritture != null) {
                            btnGeneraScritture.Text = "Rigenera le scritture in partita doppia";
                        }

                        showHide(true, btnGeneraScritture);
                        showHide(true, btnVisualizzaScritture);
                    }
                }
            }
            else {
                showHide(false, btnGeneraScritture, btnVisualizzaScritture, labScritture, labInformazioni);
                if (nEntry > 0) {
                    if (labScritture != null) {
                        labScritture.Text = "Le scritture sono state generate";
                    }

                    showHide(true, btnVisualizzaScritture);
                }
            }
        }

        public bool esistonoScrittureCollegate() {
            DataRow curr = getCurrentRow();
            //Se non ci sono righe o la riga non è salvata, nascondi tutto
            if (curr == null || curr.RowState == DataRowState.Added) {
                return false;
            }

            string idrelatedEntry = EP_functions.GetIdForDocument(curr);
            string filterEntry = BudgetFunction.getDocChildCondition(QHS, idrelatedEntry);
            int nEntry = idrelatedEntry != null
                ? Conn.RUN_SELECT_COUNT("entry", filterEntry, true)
                : 0;
            return nEntry > 0;
        }


        public void editEntry() {
            DataRow curr = getCurrentRow();
            if (curr == null || curr.RowState == DataRowState.Added) return;
            EP.EditRelatedEntry(meta, curr);
        }

        Dictionary<string, bool> mankindEntry = new Dictionary<string, bool>();
        Dictionary<string, bool> estimkindEntry = new Dictionary<string, bool>();

        bool isManKindEpEnabled(object idmankind) {
            if (idmankind == null || idmankind == DBNull.Value || idmankind.ToString() == "") return false;
            if (mankindEntry.ContainsKey(idmankind.ToString())) return mankindEntry[idmankind.ToString()];

            if (isRequest(idmankind)) {
                return false;
            }

            object flagcreatedoubleentry = Conn.DO_READ_VALUE("mandatekind", QHS.CmpEq("idmankind", idmankind),
                "flagcreatedoubleentry");
            if (flagcreatedoubleentry == null || flagcreatedoubleentry == DBNull.Value) {
                flagcreatedoubleentry = "S";
            }

            mankindEntry[idmankind.ToString()] = (flagcreatedoubleentry.ToString().ToUpper() == "S");
            return mankindEntry[idmankind.ToString()];
        }

        bool isEstimKindEpEnabled(object idestimkind) {
            if (idestimkind == null || idestimkind == DBNull.Value || idestimkind.ToString() == "") return false;
            if (estimkindEntry.ContainsKey(idestimkind.ToString())) return estimkindEntry[idestimkind.ToString()];

            object flaglinktoinvoice = Conn.DO_READ_VALUE("estimatekind", QHS.CmpEq("idestimkind", idestimkind),
                "linktoinvoice");
            if (flaglinktoinvoice == null || flaglinktoinvoice == DBNull.Value) {
                flaglinktoinvoice = "S";
            }

            estimkindEntry[idestimkind.ToString()] = (flaglinktoinvoice.ToString().ToUpper() == "N");
            return estimkindEntry[idestimkind.ToString()];
        }

        private Dictionary<string, bool> _isRequestManKind = new Dictionary<string, bool>();

        bool isRequest(object idmankind) {
            if (idmankind == null || idmankind == DBNull.Value || idmankind.ToString() == "") return false;
            if (_isRequestManKind.ContainsKey(idmankind.ToString())) return _isRequestManKind[idmankind.ToString()];

            object flagisRequest = Conn.DO_READ_VALUE("mandatekind", QHS.CmpEq("idmankind", idmankind), "isrequest");
            if (flagisRequest == null || flagisRequest == DBNull.Value) {
                flagisRequest = "S";
            }

            _isRequestManKind[idmankind.ToString()] = (flagisRequest.ToString().ToUpper() == "S");
            return _isRequestManKind[idmankind.ToString()];
        }

        public bool esistonoDettCP_FattureDaRicevere_Rateo(DataRow CurrMandate) {
            DataTable manDet;
            if (DS.Tables.Contains("mandatedetail")) {
                manDet = DS.Tables["mandatedetail"];
            }
            else {
                manDet = Conn.RUN_SELECT("mandatedetail", "*", null, QHS.CmpKey(CurrMandate), null, false);
            }
            // dettagli aventi il pallino su Fatture da ricevere o Rateo 
            foreach (DataRow Rdett in manDet.Rows) {
                if (fatturaARicevereOEmettere(Rdett) || rateo(Rdett))
                    return true;
            }
            return false;
        }
        public bool esistonoDettCA_FattureDaEmettere_Rateo(DataRow CurrEstimate) {
            DataTable estimDet;
            if (DS.Tables.Contains("estimatedetail")) {
                estimDet = DS.Tables["estimatedetail"];
            }
            else {
                estimDet = Conn.RUN_SELECT("estimatedetail", "*", null, QHS.CmpKey(CurrEstimate), null, false);
            }
            // dettagli aventi il pallino su Fatture da emettere o Rateo 
            foreach (DataRow Rdett in estimDet.Rows) {
                if (fatturaARicevereOEmettere(Rdett) || rateo(Rdett))
                    return true;
            }
            return false;
        }
        bool CPcollegabileAFattura(object idmankind) {
            if (idmankind == null || idmankind == DBNull.Value || idmankind.ToString() == "") return false;

            object flaglinktoinvoice = Conn.DO_READ_VALUE("mandatekind", QHS.CmpEq("idmankind", idmankind),
                "linktoinvoice");
            if (flaglinktoinvoice == null || flaglinktoinvoice == DBNull.Value) {
                flaglinktoinvoice = "S";
            }

            return (flaglinktoinvoice.ToString().ToUpper() == "S");
        }
        bool CAcollegabileAFattura(object idestimkind) {
            if (idestimkind == null || idestimkind == DBNull.Value || idestimkind.ToString() == "") return false;

            object flaglinktoinvoice = Conn.DO_READ_VALUE("estimatekind", QHS.CmpEq("idestimkind", idestimkind),
                "linktoinvoice");
            if (flaglinktoinvoice == null || flaglinktoinvoice == DBNull.Value) {
                flaglinktoinvoice = "S";
            }

            return (flaglinktoinvoice.ToString().ToUpper() == "S");
        }
        public bool abilitaScritture(DataRow r) {
            if (!UsaScritture) return false;
            if (r == null) return false;
            if (r.Table.TableName == "upbcommessa") {
                if (CfgFn.GetNoNullInt32(r["ayear"]) != esercizio) {
                    return false;
                }

                return true;

            }

            if (r.Table.TableName == "assetload") {
                if (CfgFn.GetNoNullInt32(r["yassetload"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "assetunload") {
                if (CfgFn.GetNoNullInt32(r["yassetunload"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "grantload") {
                if (CfgFn.GetNoNullInt32(r["yload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "mandate") {
                if (r["active"].ToString().ToUpper() != "S") {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "estimate") {
                if (r["active"].ToString().ToUpper() != "S") {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "invoice") {
                if (CfgFn.GetNoNullInt32(r["yinv"]) != esercizio) return false;
            }

            if (r.Table.TableName == "bankimport") {
                if (r["adate"] == DBNull.Value) return false;
                if (CfgFn.GetNoNullInt32(r["ayear"]) != esercizio) return false;
                if (((DateTime) r["adate"]).Year != esercizio) return false;
            }

            if (r.Table.TableName == "paymenttransmission") {
                if (r["noep"].ToString().ToUpper() == "S") {
                    return false;
                }

                if (r["transmissiondate"] == DBNull.Value) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "proceedstransmission") {
                if (r["noep"].ToString().ToUpper() == "S") {
                    return false;
                }

                if (r["transmissiondate"] == DBNull.Value) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "itineration") {
                //Le scritture non possono essere generate le la missione non è stata completata e approvata
                if (r["completed"].ToString().ToUpper() != "S") return false;
                if (r["datecompleted"] == DBNull.Value) return false;
                if (((DateTime) r["datecompleted"]).Year != esercizio) return false;
                if (CfgFn.GetNoNullInt32(r["iditinerationstatus"]) != 6) return false;
                //if (CfgFn.GetNoNullInt32(r["yitineration"]) != esercizio) return false; task 8329 non parla di anno missione
                if (r["stop"] == DBNull.Value) return false;
                //int annoStop = ((DateTime) r["stop"]).Year; //task 7860
                return true;
            }

            if (r.Table.TableName == "casualcontract") {
                if (r["completed"].ToString().ToUpper() != "S") return false;
                if (r["datecompleted"] == DBNull.Value) return false;
                if (((DateTime) r["datecompleted"]).Year != esercizio) return false;
                if (r["stop"] == DBNull.Value) return false;
                //if (r["ycon"].ToString() != esercizio.ToString()) return false; //task 7860
                return true;
            }

            if (r.Table.TableName == "wageaddition") {
                if (r["completed"].ToString().ToUpper() != "S") return false;
                if (r["ycon"].ToString() != esercizio.ToString()) return false; //task 7860
                return true;
            }

            if (r.Table.TableName == "payroll") {
                if (r["flagbalance"].ToString().ToUpper() == "S") return false;
                int annostop = esercizio;
                if (r["stop"] != DBNull.Value) {
                    annostop = ((DateTime) r["stop"]).Year;
                }

                int annoContratto =
                    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract", QHS.CmpEq("idcon", r["idcon"]), "ycon"));
                if (annostop < annoContratto) annostop = annoContratto;
                object flag = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annostop), "flag");
                bool annoStopAperto = flag != null && flag != DBNull.Value && ((CfgFn.GetNoNullInt32(flag) & 32) == 0);
                bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                     (annoStopAperto == false && annostop < esercizio);
                return daConsiderare;
            }

            if (r.Table.TableName == "profservice") {
                if (r["ycon"].ToString() != esercizio.ToString()) return false; //task 7860
                return true;
            }

            if (r.Table.TableName == "taxpay") {
                if (!usaContiPresentazioneDocumenti)
                    return false; // Le Scritture verranno effettuate in fase di trasmissioneesistenti non abilitati
                return true;
            }

            if (r.Table.TableName == "csa_importriep") {
                return false;
            }

            if (r.Table.TableName == "csa_importver") {
                return false;
            }

            if (r.Table.TableName == "csa_import") {
                if (!calcolaRighe(r)) return false;
                return true;
            }

            if (r.Table.TableName == "csa_import.debit") {
                if (!usaContiPresentazioneDocumenti) return false;
                if (!calcolaRighe(r)) return false;
                return true;
            }

            return true;
        }

        bool accertamentiAbilitati(DataRow r) {
            return preAccertamentiAbilitati(r);
        }

        bool preAccertamentiAbilitati(DataRow r) {
            if (r.Table.TableName == "upbcommessa") {
                if (CfgFn.GetNoNullInt32(r["ayear"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "estimate") {
                if (!UsaAccertamentiDiBudget) return false;
                if (r["active"].ToString().ToUpper() != "S") {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "grantload") {
                if (CfgFn.GetNoNullInt32(r["yload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "assetload") {
                if (CfgFn.GetNoNullInt32(r["yassetload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "assetunload") {
                if (CfgFn.GetNoNullInt32(r["yassetunload"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "provision") {
                return true;
            }

            if ((r.Table.TableName == "csa_importver_partitionview") ||
                (r.Table.TableName == "csa_importver_partition")) {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["amount"]);

                // Contributi negativi   credito vs erario A  RICAVO 
                if (recupero == false && (r["idacc_cost"] != DBNull.Value)
                                      && amount < 0 && EP.isRicavo(r["idacc_revenue"])
                                      && r["idacc_agency_credit"] != DBNull.Value) return true;

                //Versamento recuperi   credito vs percipiente A  RICAVO 
                if (recupero == true && EP.isRicavo(r["idacc_revenue"]) && amount > 0) return true;

                return false;
            }

            if (r.Table.TableName == "csa_importver") {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["importo"]);

                // Contributi negativi   credito vs erario A  RICAVO 
                if (recupero == false && (r["idcsa_contracttax"] != DBNull.Value ||
                                          r["idcsa_contractkinddata"] != DBNull.Value
                                      ) /* (r["idfin_cost"] != DBNull.Value || r["idexp_cost"] != DBNull.Value)*/
                                      && amount < 0 && EP.isRicavo(r["idacc_revenue"])
                                      && r["idacc_agency_credit"] != DBNull.Value) return true;

                //Versamento recuperi   credito vs percipiente A  RICAVO 
                if (recupero == true && EP.isRicavo(r["idacc_revenue"]) && amount > 0) return true;

                return false;
            }

            if (r.Table.TableName == "csa_importriep") {
                if (CfgFn.GetNoNullDecimal(r["importo"]) < 0) return true;
                //il conto di ricavo sarà _rConfig["idacc_revenue_gross_csa"];
                //if (r["idepexp"] != DBNull.Value) return false;
                //if (Conn.RUN_SELECT_COUNT("csa_contractepexp",
                //    QHS.AppAnd(QHS.CmpEq("idcsa_contract", r["idcsa_contract"]),
                //        QHS.CmpEq("ayear", esercizio)), false) > 0)
                //    return false;
                return false;
            }

            if ((r.Table.TableName == "csa_importriep_partitionview") ||
                (r.Table.TableName == "csa_importriep_partition")) {
                if (CfgFn.GetNoNullDecimal(r["amount"]) < 0) return true;
                //il conto di ricavo sarà _rConfig["idacc_revenue_gross_csa"];
                //if (r["idepexp"] != DBNull.Value) return false;
                //if (Conn.RUN_SELECT_COUNT("csa_contractepexp",
                //    QHS.AppAnd(QHS.CmpEq("idcsa_contract", r["idcsa_contract"]),
                //        QHS.CmpEq("ayear", esercizio)), false) > 0)
                //    return false;
                return false;
            }

            return false;
        }



        string getHash(DataRow r, string[] listaCampi) {
            if ((listaCampi != null) && (listaCampi.Length > 0))
                return string.Join("§", (from field in listaCampi where r.Table.Columns.Contains(field) && r[field] != DBNull.Value select r[field].ToString()).ToArray()) ;
            return "";
        }

        public bool preImpegniAbilitati(DataRow r) {
            if (!UsaImpegniDiBudget) return false;
            if (r == null) return false;

            if (r.Table.TableName == "upbcommessa") {
                if (CfgFn.GetNoNullInt32(r["ayear"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "mandate") {
                if (r["active"].ToString().ToUpper() != "S") {
                    return isRequest(r["idmankind"]);
                }

                return true; //isRequest(r["idmankind"]);
            }

            if (r.Table.TableName == "estimate") {
                if (!UsaAccertamentiDiBudget) return false;
                if (r["active"].ToString().ToUpper() != "S") {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "grantload") {
                if (!UsaAccertamentiDiBudget) return false;
                if (CfgFn.GetNoNullInt32(r["yload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "assetload") {
                if (!UsaAccertamentiDiBudget) return false;
                if (CfgFn.GetNoNullInt32(r["yassetload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "assetunload") {
                if (CfgFn.GetNoNullInt32(r["yassetunload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "invoice") {
                if (CfgFn.GetNoNullInt32(r["yinv"]) != esercizio) return false;
                int flagFattura = CfgFn.GetNoNullInt32(r["flagbit"]);
                bool bollaDoganale = ((flagFattura & 1) != 0);
                bool anticipoSpese = ((flagFattura & 2) != 0);
                if (!cicloAttivo()) { //siamo nel ciclo passivo  ossia stiamo generando impegni di budget

                    //commento questa riga perchè abbiamo una gestione più dettagliata ora , ad ogni modo non poteva mai scattare neanche prima visto che
                    //  cicloAttivo() era equivalente a      tipoRegistroAV() == "A"
                    //if (tipoRegistroAV(r["idinvkind"]) == "V") return false; //ma non dobbiamo comunque farlo sulle vendite??

                    //Se esiste un dettaglio con flag "bolla doganale" e con iva indetraibile diversa da zero deve generare l'impegno di budget
                    // per importo pari alla sola iva indetraibile (1)
                    if (DS.Tables["invoicedetail"]
                            .Select(QHC.AppAnd(QHC.BitSet("flagbit", 0), QHC.NullOrGt("unabatable", 0))).Length >
                        0) return true;

                    //Per le fatt. collegate a parcelle gli impegni stanno sulla parcella tranne per le fatt a ricevere parte iva indet.
                    if (Conn.RUN_SELECT_COUNT("profservice", QHS.AppAnd(QHS.CmpGe("ycon", minimoAnnoImpegniDiBudget),
                                QHS.DoPar(QHS.AppOr(QHS.IsNull("epkind"), QHS.NullOrEq("epkind", "N"))), QHS.CmpKey(r)),
                            false) > 0) return false;
                    //if (DS.Tables["invoicedetail"].Select(QHS.CmpGe("ycon", minimoAnnoImpegniDiBudget)).Length > 0) return false;

                    //Per fatture collegate a contratti prof., di tipo fatt. a ricevere, comunque non genera impegni (task  10223 e chat successive
                    // con Antonio)
                    ////// elimino la condizione  a seguito task 10272 (dipende se fatt.commerciale se a ricevere etc.)
                    //if (Conn.RUN_SELECT_COUNT("profservice", QHS.AppAnd(QHS.CmpEq("epkind", "F"),
                    //    QHS.CmpKey(r)), false) > 0) return false;


                    //Se non ci sono dett. fattura NON collegati a c.passivo e NON spese anticipate allora non vanno generate scritture
                    //Ossia gli impegni vanno generati sui dett. fattura che siano NON collegati a c.passivo e che non siano "spese anticipate"   
                    //Se l'ordine è creato PRIMA del primo anno impegni di budget non è considerato                 
                    if (DS.Tables["invoicedetail"].Select(
                            QHC.BitClear("flagbit", 1)
                            //   10416 yman è troppo poco, deleghiamo la scelta su cosa fare alla funzione interna
                            //QHC.AppAnd(QHC.BitClear("flagbit",1),QHS.NullOrLt("yman",minimoAnnoImpegniDiBudget))
                        ).Length == 0) return false;

                }
                //if (cicloAttivo()) {
                //    //analogamente ad altra modifica
                //    //if (veroTipoFatturaAv(r["idinvkind"]) == "A") return false;

                //    //   10416 yestim è troppo poco, deleghiamo la scelta su cosa fare alla funzione interna
                //    //if (DS.Tables["invoicedetail"].Select(QHS.NullOrLt("yestim", minimoAnnoImpegniDiBudget)).Length == 0) return false;                   
                //}
                return true;
            }

            if (r.Table.TableName == "itineration") {
                if (r["completed"].ToString().ToUpper() != "S")
                    return false; //8297task --> ripristinato a seguito di 10337

                if (CfgFn.GetNoNullInt32(r["iditinerationstatus"]) != 6) return false;
                //if (CfgFn.GetNoNullInt32(r["yitineration"]) != esercizio) return false; //task 8002

                //if (r["stop"] == DBNull.Value) return false;
                //int annoStop = ((DateTime) r["stop"]).Year;       //task 8002
                //if (annoStop != esercizio) return false;

                if (r["stop"] == DBNull.Value) return false; //8264

                //if (r["adate"] == DBNull.Value) return false; //commentato per   10337
                if (r["datecompleted"] == DBNull.Value) return false; //10337

                int annoDoc = ((DateTime) r["datecompleted"]).Year;
                if (annoDoc != esercizio) return false;

                //int annoMissione = ((DateTime)r["adate"]).Year;              commentate per 10337
                //if (annoMissione > esercizio) return false;


                //una volta che una missione è a saldo non si può più modificarla come anticipo
                if (getFaseAnticipoMissione(r) && !getRealFaseAnticipoMissione(r)) return false;

                return true;
            }

            if (r.Table.TableName == "casualcontract") {
                if (r["completed"].ToString().ToUpper() != "S") return false;
                if (r["stop"] == DBNull.Value) return false;
                //if (r["ycon"].ToString() != esercizio.ToString()) return false; //task 8002

                if (r["datecompleted"] == DBNull.Value) return false; //10337
                int annoDoc = ((DateTime) r["datecompleted"]).Year;
                if (annoDoc != esercizio) return false;

                return true;
            }

            if (r.Table.TableName == "wageaddition") {
                if (r["ycon"].ToString() != esercizio.ToString()) return false; //task 8002
                return true;
            }

            if (r.Table.TableName == "pettycashoperation") {
                int flag = CfgFn.GetNoNullInt32(r["flag"]);
                if ((flag & 8) == 0) return false;
                if (getContabilizzazioneFondo(r) != Tipocont.ContNone) return false;
                return true;
            }

            if (r.Table.TableName == "payroll") {
                if (r["flagbalance"].ToString().ToUpper() == "S") return false;
                int annostop = esercizio;
                if (r["stop"] != DBNull.Value) {
                    annostop = ((DateTime) r["stop"]).Year;
                }

                int annoContratto =
                    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract", QHS.CmpEq("idcon", r["idcon"]), "ycon"));
                if (annostop < annoContratto) annostop = annoContratto;
                object flag = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annostop), "flag");
                bool annoStopAperto = flag != null && flag != DBNull.Value && ((CfgFn.GetNoNullInt32(flag) & 32) == 0);
                bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                     (annoStopAperto == false && annostop < esercizio);
                return daConsiderare;
            }

            if (r.Table.TableName == "profservice") {
                int annoContratto = CfgFn.GetNoNullInt32(r["ycon"]);
                if (annoContratto > esercizio) return false; //task 8002
                int anno = ((DateTime) r["adate"]).Year;
                //if (anno < esercizio && esercizio == minimoAnnoImpegniDiBudget) return true;
                if (anno != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "csa_import" || r.Table.TableName == "csa_import.debit") {
                if (tipoScrittura == "debito") return false;
                return true;
            }

            if (r.Table.TableName == "csa_importver_partitionview") {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["amount"]);

                if (r["idepexp"] != DBNull.Value) {
                    return false;
                }

                //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
                if (recupero == false && EP.isCosto(r["idacc_cost"])
                                      && amount > 0)
                    return true;

                // Versamento recuperi  COSTO   A  debito vs percipiente
                if (recupero == true && amount < 0 && EP.isCosto(r["idacc_cost"])) return true;


                return preAccertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }


            if (r.Table.TableName == "csa_importver") {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["importo"]);

                if (r["idepexp"] != DBNull.Value) {
                    return false;
                }

                string k = r["idver"] + "*" + r["idcsa_import"];
                if (existContractTaxEpExp.ContainsKey(k)) {
                    if (existContractTaxEpExp[k]) return false;
                }
                else {
                    ///TODO: leggere questi dati tutti insieme, non è possibile perdere tanto tempo
                    existContractTaxEpExp[k] = (getImportVer_EpExp(r["idcsa_import"], r["idver"]).Length > 0);
                    //Conn.RUN_SELECT_COUNT("csa_importver_epexp",
                    //QHS.AppAnd(QHS.CmpEq("idcsa_import", r["idcsa_import"]),
                    //    QHS.CmpEq("idver", r["idver"])),
                    //false) > 0;
                    if (existContractTaxEpExp[k]) return false;
                }

                //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
                if (recupero == false && EP.isCosto(r["idacc_cost"]) &&
                    (r["idacc_debit"] != DBNull.Value || r["idacc_expense"] != DBNull.Value)
                    && amount > 0)
                    return true;

                // Versamento recuperi  COSTO   A  debito vs percipiente
                if (recupero == true && amount < 0 && EP.isCosto(r["idacc_cost"])) return true;


                return preAccertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if (r.Table.TableName == "csa_importriep_partitionview") {
                decimal amount = CfgFn.GetNoNullDecimal(r["amount"]);

                //impegni di budget già associati manualmente  >>sbagliato!! 
                if (r["idepexp"] != DBNull.Value) return false;

                // Fase del pagamento prestazione (LORDI)    costo   A 	debito vs percipiente
                if (amount > 0 && EP.isCosto(r["idacc"])) return true;

                return preAccertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if (r.Table.TableName == "csa_importriep") {
                decimal amount = CfgFn.GetNoNullDecimal(r["importo"]);

                //impegni di budget già associati manualmente  >>sbagliato!! 
                if (r["idepexp"] != DBNull.Value) return false;


                int idcsa_import = CfgFn.GetNoNullInt32(r["idcsa_import"]);
                if (existContractEpExp.ContainsKey(idcsa_import)) {
                    if (existContractEpExp[idcsa_import]) return false;
                }
                else {
                    ///TODO: leggere questi dati tutti insieme, non è possibile perdere tanto tempo
                    existContractEpExp[idcsa_import] = (getImportRiep_EpExp(r["idcsa_import"], r["idriep"]).Length > 0);
                    //Conn.RUN_SELECT_COUNT("csa_importriep_epexp",
                    //QHS.AppAnd(QHS.CmpEq("idcsa_import", r["idcsa_import"]),
                    //    QHS.CmpEq("idriep", r["idriep"])),
                    //false) > 0;
                    if (existContractEpExp[idcsa_import]) return false;
                }


                // Fase del pagamento prestazione (LORDI)    costo   A 	debito vs percipiente
                if (amount > 0 && EP.isCosto(r["idacc"])) return true;

                return preAccertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if (r.Table.TableName == "provision") {
                return true;
            }

            return false;
        }

        private Dictionary<int, bool> existContractEpExp = new Dictionary<int, bool>();
        private Dictionary<string, bool> existContractTaxEpExp = new Dictionary<string, bool>();

        private enum Tipocont {
            ContNone,
            ContMissione,
            ContIva,
            ContOccasionale,
            ContProfessionale
        };

        public string tipoScrittura;

        Tipocont getContabilizzazioneFondo(DataRow curr) {
            string filter = QHS.CmpKey(curr);
            if (Conn.RUN_SELECT_COUNT("pettycashoperationinvoice", filter, false) > 0) return Tipocont.ContIva;
            if (Conn.RUN_SELECT_COUNT("pettycashoperationitineration", filter, false) > 0) return Tipocont.ContMissione;
            if (Conn.RUN_SELECT_COUNT("pettycashoperationprofservice", filter, false) > 0)
                return Tipocont.ContProfessionale;
            if (Conn.RUN_SELECT_COUNT("pettycashoperationcasualcontract", filter, false) > 0)
                return Tipocont.ContOccasionale;
            return Tipocont.ContNone;
        }

        public bool impegniAbilitati(DataRow r) {
            if (!UsaImpegniDiBudget) return false;
            if (r == null) return false;
            if (r.Table.TableName == "mandate") {
                if (r["active"].ToString().ToUpper() != "S") {
                    return false;
                }

                return !isRequest(r["idmankind"]);
            }

            if (r.Table.TableName == "assetload") {
                if (CfgFn.GetNoNullInt32(r["yassetload"]) != esercizio) {
                    return false;
                }

                return true;
            }

            if (r.Table.TableName == "assetunload") {
                if (CfgFn.GetNoNullInt32(r["yassetunload"]) != esercizio) return false;
                return true;
            }

            if (r.Table.TableName == "csa_importriep") {
                decimal amount = CfgFn.GetNoNullDecimal(r["importo"]);

                //impegni di budget già associati manualmente  >>sbagliato!! 
                //if (r["idepexp"] != DBNull.Value) return false;


                //int idcsa_import = CfgFn.GetNoNullInt32(r["idcsa_import"]);
                //if (existContractEpExp.ContainsKey(idcsa_import)) {
                //    if (existContractEpExp[idcsa_import]) return false;
                //}
                //else {
                //    existContractEpExp[idcsa_import] = Conn.RUN_SELECT_COUNT("csa_importriep_epexpview",
                //        QHS.AppAnd(QHS.CmpEq("idcsa_import", r["idcsa_import"]),
                //            QHS.CmpEq("idriep", r["idriep"]),QHS.CmpEq("nphase",2)),
                //        false) > 0;
                //    if (existContractEpExp[idcsa_import]) return false;
                //}


                // Fase del pagamento prestazione (LORDI)    costo   A 	debito vs percipiente
                if (amount > 0 && EP.isCosto(r["idacc"])) return true;

                return accertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if ((r.Table.TableName == "csa_importriep_partition") ||
                (r.Table.TableName == "csa_importriep_partitionview")) {
                decimal amount = CfgFn.GetNoNullDecimal(r["amount"]);

                // Fase del pagamento prestazione (LORDI)    costo   A 	debito vs percipiente
                if (amount > 0 && EP.isCosto(r["idacc"])) return true;

                return accertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if ((r.Table.TableName == "csa_importver_partition") ||
                (r.Table.TableName == "csa_importver_partitionview")) {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["amount"]);

                //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
                if (recupero == false && EP.isCosto(r["idacc_cost"])
                                      && amount > 0) return true;

                // Versamento recuperi  COSTO   A  debito vs percipiente
                if (recupero == true && amount < 0 && EP.isCosto(r["idacc_cost"])) return true;

                return accertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            if (r.Table.TableName == "csa_importver") {
                bool recupero = r["flagclawback"].ToString().ToUpper() == "S";
                decimal amount = CfgFn.GetNoNullDecimal(r["importo"]);

                //if (r["idepexp"] != DBNull.Value) return false;

                //string k = r["idver"] + "*" + r["idcsa_import"];
                //if (existContractTaxEpExp.ContainsKey(k)) {
                //    if (existContractTaxEpExp[k]) return false;
                //}
                //else {
                //    existContractTaxEpExp[k] = Conn.RUN_SELECT_COUNT("csa_importver_epexpview",
                //        QHS.AppAnd(QHS.CmpEq("idcsa_import", r["idcsa_import"]),
                //            QHS.CmpEq("idver", r["idver"]), QHS.CmpEq("nphase", 2)),
                //        false) > 0;
                //    if (existContractTaxEpExp[k]) return false;
                //}

                //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
                if (recupero == false && EP.isCosto(r["idacc_cost"]) &&
                    (r["idacc_debit"] != DBNull.Value || r["idacc_expense"] != DBNull.Value)
                    && amount > 0)
                    return true;

                // Versamento recuperi  COSTO   A  debito vs percipiente
                if (recupero == true && amount < 0 && EP.isCosto(r["idacc_cost"])) return true;


                return accertamentiAbilitati(r); //potrebbero essere abilitati gli accertamenti 
            }

            return preImpegniAbilitati(r);
        }

        public void afterPost() {

            afterPost(false);
        }

        bool doppioMovimento(string table) {
            if (table == "csa_import") return true;
            if (table == "upbcommessa") return true;
            if (table == "assetload") return true;
            if (table == "assetunload") return true;
            if (table == "provision") return true;
            if (table == "invoice") return true;
            if (table == "estimate") return true;
            if (table == "mandate") return true;
            return false;
        }

        public bool mostraDatiSalvati = true; //mostra scritture e movimenti dopo averli salvati, sempre se non silent
        public bool ultimaGenerazioneRiuscita = false;

        public void afterPost(bool silent) {
            ultimaGenerazioneRiuscita = false;
            if (postingClass != null && !invokedByInnerPosting) return;

            this.silent = silent;
            if (_fromDelete) {

                if (_idRelatedForEntry.Count > 0) {

                    cancellaScritture(_idRelatedForEntry, invokedByInnerPosting ? postingClass : null);

                    _idRelatedForEntry.Clear();
                }


                if (_idrelatedToDelete.Count > 0) {

                    cancellaImpegniBudget(2, _idrelatedToDelete);

                    cancellaImpegniBudget(1, _idrelatedToDelete);

                    _idrelatedToDelete.Clear();
                }

                _fromDelete = false;
                ultimaGenerazioneRiuscita = true;
                return;
            }

            bool impegniGenerati = false;
            bool preimpegniGenerati = false;
            bool scrittureGenerate = false;

            DataRow curr = getCurrentRow();
            if (curr == null) return;

            if (mainTable == "csa_import") {
                if (!VerificaProblemiCsa(curr)) {
                    ShowMessage("Rilevati problemi nei dati importati, effettuare le verifiche opportune", "Errore");
                    return;
                }
            }

            if (curr.Table.TableName == "csa_import.debit") return; //task 8623
            string message = "";

            string idrelatedEpExp = BudgetFunction.GetIdForDocument(curr);
            string idrelatedEntry = EP_functions.GetIdForDocument(curr);
            string filterEpExp = BudgetFunction.getDocChildCondition(QHS, idrelatedEpExp);
            string filterEntry = BudgetFunction.getDocChildCondition(QHS, idrelatedEntry);
            int nEntry = idrelatedEntry != null
                ? Conn.RUN_SELECT_COUNT("entry", QHS.AppAnd(filterEntry, QHS.CmpEq("yentry", esercizio)), true)
                : 0;
            string vista = cicloAttivo() ? "epaccview" : "epexpview";
            string secondaVista = cicloAttivo() ? "epexpview" : "epaccview";
            int nEpExp1 = idrelatedEpExp != null
                ? Conn.RUN_SELECT_COUNT(vista, QHS.AppAnd(
                        filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                    , true)
                : 0;
            int nEpExp2 = idrelatedEpExp != null
                ? Conn.RUN_SELECT_COUNT(vista, QHS.AppAnd(
                        filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2))
                    , true)
                : 0;
            if (doppioMovimento(curr.Table.TableName)) {
                nEpExp1 += idrelatedEpExp != null
                    ? Conn.RUN_SELECT_COUNT(secondaVista, QHS.AppAnd(
                            filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                        , true)
                    : 0;
                nEpExp2 += idrelatedEpExp != null
                    ? Conn.RUN_SELECT_COUNT(secondaVista, QHS.AppAnd(
                            filterEpExp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2))
                        , true)
                    : 0;
            }

            bool impegniAbilitatiRigaCorrente = impegniAbilitati(curr);
            bool preimpegniAbilitatiRigaCorrente = preImpegniAbilitati(curr);
            bool scrittureAbilitateRigaCorrente = abilitaScritture(curr);
            bool errori = false;
            string preMov = cicloAttivo() ? "preaccertamenti" : "preimpegni";
            string preMovSpec = cicloAttivo() ? "i preaccertamenti" : "i preimpegni";
            string Mov = cicloAttivo() ? "accertamenti" : "impegni";
            string MovSpec = cicloAttivo() ? "gli accertamenti" : "gli impegni";

            //if (nEpExp1 > 0 && !preimpegniAbilitatiRigaCorrente) {
            //    ShowMessage("Ci sono "+preMov+"  di budget  esistenti ma non sono abilitati per questa riga.",
            //        "Avviso");
            //}
            //else {
            //    if (nEpExp2 > 0 && !impegniAbilitatiRigaCorrente) {
            //        ShowMessage("Ci sono "+Mov+" di budget esistenti ma non sono abilitati per questa riga.",
            //            "Avviso");
            //    }
            //}

            bool impegniGeneratiDavvero = false;
            if (UsaImpegniDiBudget) {

                if (nEpExp1 > 0 && nEpExp2 > 0 && preimpegniAbilitatiRigaCorrente && impegniAbilitatiRigaCorrente) {
                    if (generaImpegniAccertamenti(0, out scrittureGenerate, out impegniGeneratiDavvero)) {
                        ultimaGenerazioneRiuscita = true;
                        preimpegniGenerati = true;
                        impegniGenerati = true;
                        message += "Sono stati generati " + preMov + " e " + Mov + " di budget\r\n";
                    }
                    else {
                        errori = true;
                    }
                }
                else {
                    if (nEpExp1 > 0 && preimpegniAbilitatiRigaCorrente) {
                        if (generaImpegniAccertamenti(1, out scrittureGenerate, out impegniGeneratiDavvero)) {
                            ultimaGenerazioneRiuscita = true;
                            preimpegniGenerati = true;
                            message += "Sono stati generati " + MovSpec + " di budget\r\n";
                        }
                        else {
                            errori = true;
                        }
                    }

                    if (impegniAbilitatiRigaCorrente) {
                        if (preimpegniGenerati) {
                            if (generaImpegniAccertamenti(2, out scrittureGenerate, out impegniGeneratiDavvero)) {
                                ultimaGenerazioneRiuscita = true;
                                impegniGenerati = true;
                                message += "Sono stati generati " + MovSpec + " di budget\r\n";
                            }
                            else {
                                errori = true;
                            }
                        }
                        else {
                            if (generaImpegniAccertamenti(0, out scrittureGenerate, out impegniGeneratiDavvero)) {
                                ultimaGenerazioneRiuscita = true;
                                preimpegniGenerati = impegniGeneratiDavvero;
                                impegniGenerati = impegniGeneratiDavvero;
                                if (impegniGeneratiDavvero) {
                                    message += "Sono stati generati " + preMov + " e " + Mov + " di budget\r\n";
                                }
                            }
                            else {
                                errori = true;
                            }
                        }

                        nEpExp2 = Conn.RUN_SELECT_COUNT(vista, QHS.AppAnd(
                            QHS.CmpEq("idrelated", idrelatedEpExp), QHS.CmpEq("ayear", esercizio),
                            QHS.CmpEq("nphase", 2)), true);
                    }

                }

                if (!((preimpegniGenerati) || (impegniGenerati)))
                     clearAllDictionary();
            }

            if (scrittureGenerate) {

                message += "Sono state generate le scritture in partita doppia\r\n";
            }

            //Se ci sono gli impegni di budget le scritture saranno rigenerate insieme agli impegni di budget
            if (scrittureAbilitateRigaCorrente && !scrittureGenerate && !errori) {
                if (nEntry > 0) {
                    if (generaScritture(curr)) {
                        scrittureGenerate = true;
                        mostraEtichette();
                        message += "Sono state generate le scritture in partita doppia\r\n";
                    }
                }
                else {
                    //Se si usano gli impegni di budget è necessario creare prima quelli
                    if (impegniAbilitatiRigaCorrente) {
                        if (nEpExp2 > 0 || impegniGenerati) {
                            if (generaScritture(curr)) {
                                scrittureGenerate = true;
                                mostraEtichette();
                                message += "Sono state generate le scritture in partita doppia\r\n";
                            }
                        }
                    }
                    else {
                        if (generaScritture(curr)) {
                            scrittureGenerate = true;
                            mostraEtichette();
                            message += "Sono state generate le scritture in partita doppia\r\n";
                        }
                    }

                }
            }

            clearHashImpegniByIdRelated();
            if (scrittureAbilitateRigaCorrente && !scrittureGenerate) errori = true;
            if (!errori) {
                if (mainTable == "mandate") {
                    if (!scrittureAbilitateRigaCorrente) updateCausaleCostoFatturaAcquistoCollegata(curr);
                }

                if (mainTable == "estimate") {
                    if (!scrittureAbilitateRigaCorrente) updateCausaleRicavoFatturaVenditaCollegata(curr);
                }

                //if (mainTable == "profservice") {
                //    updateCausaleCostoFatturaAcquistoCollegataAProfessionale(curr);
                //}

                correggiDebitoDocumenti();
                correggiCreditoDocumenti();
                ultimaGenerazioneRiuscita = true;
            }

            if (_idRelatedForEntryDetail.Count > 0) {
                //TODO: qua è da verificare se ci sono problemi mettendo tutto in un'unica transazione

                cancellaScrittureDetail(_idRelatedForEntryDetail);
                _idRelatedForEntryDetail.Clear();
            }

            if (_idrelatedToDelete.Count > 0) {
                //TODO: qua è da verificare se ci sono problemi mettendo tutto in un'unica transazione
                bool deleted = cancellaImpegniBudget(2, _idrelatedToDelete);
                deleted |= cancellaImpegniBudget(1, _idrelatedToDelete);
                if (deleted) message += "Alcuni impegni di budget cancellati";
                _idrelatedToDelete.Clear();
            }

            if (silent || !mostraDatiSalvati) return;
            if (preimpegniGenerati && !impegniGenerati) {
                editEpExp(1);
                return;
            }

            if (impegniGenerati && !scrittureGenerate) {
                editEpExp(2);
                return;
            }

            if (!impegniGenerati && scrittureGenerate) {
                editEntry();
                return;
            }

            //if (message != "" && interactive) {
            //    MetaFactory.factory.getSingleton<IMessageShower>().Show(message, "Operazioni effettuate");
            //}


        }
        /*
        bool PropagazioneConsentita(DataRow mainMandate) {
            ////sempre TRUE qualora esercizio del dettaglio del CP/ CA ed esercizio della fattura siano uguali, e Eserc. Fattura = Eserc. contabile corrente
            //bool CambioPossibile = true;
            //foreach (DataRow md in DS.Tables["mandatedetail"]._Filter(q.keyCmp(mainMandate))) {
            //    if (DS.Tables["invoicedetail"] == null) return false;

            //    foreach (DataRow rInvDet in DS.Tables["invoicedetail"]._Filter(q.eq("idmankind", md["idmankind"])
            //        & q.eq("yman", md["yman"]) & q.eq("nman", md["nman"]) & q.eq("manrownum", md["rownum"]))) {
            //        if (CfgFn.GetNoNullInt32(rInvDet["yinv"]) != Conn.GetEsercizio())
            //            CambioPossibile = false;
            //        object oDataInizio = md["start"];
            //        if (oDataInizio != null && oDataInizio != DBNull.Value) {
            //            int annoDettaglioMan = ((DateTime)oDataInizio).Year;
            //            if (annoDettaglioMan != CfgFn.GetNoNullInt32(rInvDet["yinv"])) {
            //                CambioPossibile = false;
            //                continue;
            //            }
            //        }
            //        if (CfgFn.GetNoNullInt32(md["yman"]) != CfgFn.GetNoNullInt32(rInvDet["yinv"])) {
            //            CambioPossibile = false;
            //            continue;
            //        }
            //    }// fine ciclo su invoicedetail
            //}
            //if (CambioPossibile) return true;//Vuol dire che gli esercizi sono uguali e il cambio è possibile. Se è false, va avanti e fa gli altri controlli.

            //CON BUDGET, la modifica è possibile se Eserc. CP (o year di start) <= Eserc. Fattura , e  Eserc. CP = Eserc.contabile corrente, ove Eserc. CP e Eserc.Fattura Aperto(Eserc.Fattura Aperto è superfluo controllarlo)
            object flagCP = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", CfgFn.GetNoNullInt32(mainMandate["yman"])), "flag");
            bool annoCPAperto = flagCP != null && flagCP != DBNull.Value && ((CfgFn.GetNoNullInt32(flagCP) & 32) == 0);

            //if (UsaImpegniDiBudget) {
            bool PossoPropagare = true;
                foreach (DataRow md in DS.Tables["mandatedetail"]._Filter(q.keyCmp(mainMandate))) {
                    foreach (DataRow rInvDet in DS.Tables["invoicedetail"]._Filter(q.eq("idmankind", md["idmankind"])
                        & q.eq("yman", md["yman"]) & q.eq("nman", md["nman"]) & q.eq("manrownum", md["rownum"]))) {

                        object oDataInizio = md["start"];
                        if (oDataInizio != null && oDataInizio != DBNull.Value) {
                            int annoDettaglioMan = ((DateTime)oDataInizio).Year;
                            if (annoDettaglioMan != Conn.GetEsercizio())
                                return false; //Eserc. del dettaglio deve essere dell'Eserc. Corrente altrimenti l'operazione non si può fare

                            object flagdettCP = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annoDettaglioMan), "flag");
                            bool annodettCPAperto = flagdettCP != null && flagdettCP != DBNull.Value && ((CfgFn.GetNoNullInt32(flagdettCP) & 32) == 0);
                            if ((annoDettaglioMan <= CfgFn.GetNoNullInt32(rInvDet["yinv"])) && annodettCPAperto) {
                                continue;
                            }
                            else {
                                PossoPropagare = false;
                                return PossoPropagare;// E' una situazione in cui non è consentita la propagazione. Esce.
                            }
                        }
                        else {
                            if (CfgFn.GetNoNullInt32(md["yman"]) <= CfgFn.GetNoNullInt32(rInvDet["yinv"]) && annoCPAperto && (CfgFn.GetNoNullInt32(md["yman"]) == Conn.GetEsercizio())) {
                                continue;
                            }
                            else {
                                PossoPropagare = false;
                                return PossoPropagare;// E' una situazione in cui non è consentita la propagazione. Esce.
                            }
                        }
                    }// fine ciclo su invoicedetail collegati ai dettagli di questo CP
                }
                if (PossoPropagare) return true;
            //}

            //SENZA BUDGET, la modifica è possibile anche se Eserc. CP (o year di start) <Eserc. Fattura  , e  Eserc. Fattura = Eserc.contabile corrente, ove Eserc.Fattura Aperto(è superfluo controllarlo)
            //if (!UsaImpegniDiBudget) {
            //    bool CambioPossibileconEsercMinNoBgt = true;
            //    foreach (DataRow md in DS.Tables["mandatedetail"]._Filter(q.keyCmp(mainMandate))) {
            //        foreach (DataRow rInvDet in DS.Tables["invoicedetail"]._Filter(q.eq("idmankind", md["idmankind"])
            //            & q.eq("yman", md["yman"]) & q.eq("nman", md["nman"]) & q.eq("manrownum", md["rownum"]))) {

            //            object oDataInizio = md["start"];
            //            if (oDataInizio != null && oDataInizio != DBNull.Value) {
            //                int annoDettaglioMan = ((DateTime)oDataInizio).Year;
            //                if (annoDettaglioMan != Conn.GetEsercizio())
            //                    return false; //Eserc. del dettaglio deve essere dell'Eserc. Coorente altrimenti l'operazione non si può fare

            //                object flagdettCP = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annoDettaglioMan), "flag");
            //                bool annodettCPAperto = flagdettCP != null && flagdettCP != DBNull.Value && ((CfgFn.GetNoNullInt32(flagdettCP) & 32) == 0);

            //                if (annoDettaglioMan < CfgFn.GetNoNullInt32(rInvDet["yinv"]) && annodettCPAperto) {
            //                    continue;
            //                }
            //                else {
            //                    CambioPossibileconEsercMinNoBgt = false;
            //                    return CambioPossibileconEsercMinNoBgt;// E' una situazione in cui non è consentita la propagazione. Esce.
            //                }
            //            }
            //            else {
            //                if (CfgFn.GetNoNullInt32(md["yman"]) != Conn.GetEsercizio())
            //                    return false; //Eserc. del dettaglio deve essere dell'Eserc. Coorente altrimenti l'operazione non si può fare

            //                object flagCP = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", CfgFn.GetNoNullInt32(md["yman"])), "flag");
            //                bool annoCPAperto = flagCP != null && flagCP != DBNull.Value && ((CfgFn.GetNoNullInt32(flagCP) & 32) == 0);

            //                if (CfgFn.GetNoNullInt32(md["yman"]) < CfgFn.GetNoNullInt32(rInvDet["yinv"]) && annoCPAperto) {
            //                    continue;
            //                }
            //                else {
            //                    CambioPossibileconEsercMinNoBgt = false;
            //                    return CambioPossibileconEsercMinNoBgt;// E' una situazione in cui non è consentita la propagazione. Esce.
            //                }
            //            }
            //        }// fine ciclo su invoicedetail
            //    }
            //    if (CambioPossibileconEsercMinNoBgt) return true;
            //}

            return false;
		}
        */

        object getIdAccMotiveCreditVersion(DataRow r, DataRowVersion ver) {
            DataRowVersion toConsider = ver;
            if (r.RowState == DataRowState.Added) {
                toConsider = DataRowVersion.Current;
            }

            if (r.RowState == DataRowState.Deleted) {
                toConsider = DataRowVersion.Original;
            }

            string prefix = "idaccmotivecredit";
            if (!r.Table.Columns.Contains(prefix)) {
                prefix = "idaccmotivedebit";
            }

            object idaccmotive = r[prefix, toConsider];
            object idaccmotiveCrg = r[prefix + "_crg", toConsider];
            object dateCrg = r[prefix + "_datacrg", toConsider];

            if (idaccmotiveCrg == DBNull.Value) return idaccmotive;
            if (dateCrg == DBNull.Value) return idaccmotiveCrg;
            var d = (DateTime) dateCrg;
            return d.Year <= esercizio ? idaccmotiveCrg : idaccmotive;
        }

        object getIdAccMotiveDebitVersion(DataRow r, DataRowVersion ver) {
            DataRowVersion toConsider = ver;
            if (r.RowState == DataRowState.Added) {
                toConsider = DataRowVersion.Current;
            }

            if (r.RowState == DataRowState.Deleted) {
                toConsider = DataRowVersion.Original;
            }

            string prefix = "idaccmotivedebit";
            if (!r.Table.Columns.Contains(prefix)) {
                prefix = "idaccmotivecredit";
            }

            object idaccmotive = r[prefix, toConsider];
            object idaccmotiveCrg = r[prefix + "_crg", toConsider];
            object dateCrg = r[prefix + "_datacrg", toConsider];

            if (idaccmotiveCrg == DBNull.Value) return idaccmotive;
            if (dateCrg == DBNull.Value) return idaccmotiveCrg;
            var d = (DateTime) dateCrg;
            return d.Year <= esercizio ? idaccmotiveCrg : idaccmotive;
        }

        private List<DataRow> docToUpdateCredito = new List<DataRow>();
        private List<DataRow> docToUpdateDebito = new List<DataRow>();

        void initDocumentoCorrigeDebitoCredito() {
            docToUpdateDebito.Clear();
            docToUpdateCredito.Clear();
        }

        /// <summary>
        /// Aggiunge una riga a quelle di cui aggiornare il conto di debito alla fine
        /// </summary>
        /// <param name="r"></param>
        void checkDocumentoCorrigeDebito(DataRow r) {
            var idAccOriginal = getIdAccMotiveDebitVersion(r, DataRowVersion.Original);
            var idAccCurrent = getIdAccMotiveDebitVersion(r, DataRowVersion.Current);
            if (idAccOriginal.ToString() != idAccCurrent.ToString()) {
                docToUpdateDebito.Add(r);
            }
        }

        void checkDocumentoCorrigeCredito(DataRow r) {
            var idAccOriginal = getIdAccMotiveCreditVersion(r, DataRowVersion.Original);
            var idAccCurrent = getIdAccMotiveCreditVersion(r, DataRowVersion.Current);
            if (idAccOriginal.ToString() != idAccCurrent.ToString()) {
                docToUpdateCredito.Add(r);
            }
        }

        bool checkLastError(string where) {
            string err = Conn.LastError;
            if (string.IsNullOrEmpty(err)) return true;
            ShowMessage("Errore " + where + ":" + err, "Errore aggiornando il db");
            return false;
        }

        void aggiornaDebitiFattureCollegate(DataRow rMandate) {
            if (CfgFn.GetNoNullInt32(rMandate["yman"]) < minimoAnnoImpegniDiBudget) return;
            DataTable allInvoice = Conn.RUN_SELECT("invoicemandateview", "*", null, QHS.CmpKey(rMandate), null, false);
            foreach (DataRow rInvMan in allInvoice.Rows) {
                DataTable inv = Conn.RUN_SELECT("invoice", "*", null, QHS.AppAnd(
                    QHS.CmpEq("idinvkind", rInvMan["idinvkind"]),
                    QHS.CmpEq("yinv", rInvMan["yinv"]),
                    QHS.CmpEq("ninv", rInvMan["ninv"])
                ), null, false);
                if (inv.Rows.Count == 0) continue;
                DataRow rInv = inv.Rows[0];
                var idaccmotiveInvoice = getIdAccMotiveDebitVersion(rInv, DataRowVersion.Current);
                var idaccmotiveMandate = getIdAccMotiveDebitVersion(rMandate, DataRowVersion.Current);
                if (idaccmotiveInvoice.ToString() == idaccmotiveMandate.ToString()) continue;


                //var pagam = getPagamentiDocumento(rInv);
                //foreach (object idexp in pagam) {
                //	correggiContoDebitoPagamento(idexp, rMandate);
                //}

                Conn.DO_UPDATE("invoice", QHS.CmpKey(rInv),
                    new[] {"idaccmotivedebit", "idaccmotivedebit_crg", "idaccmotivedebit_datacrg"},
                    new[] {
                        QHS.quote(rMandate["idaccmotivedebit"]),
                        QHS.quote(rMandate["idaccmotivedebit_crg"]),
                        QHS.quote(rMandate["idaccmotivedebit_datacrg"])
                    }, 3
                );
                checkLastError("aggiornando le scritture");


                object oldidaccDebit = EP.GetSupplierAccountForRegistry(idaccmotiveInvoice, rInv["idreg"]);
                object newidaccDebit = EP.GetSupplierAccountForRegistry(idaccmotiveMandate, rInv["idreg"]);
                if (oldidaccDebit.ToString() != newidaccDebit.ToString()) {
                    DataTable tEntry = Conn.RUN_SELECT("entry", "*", null,
                        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInv)), null, false);
                    if (tEntry.Rows.Count == 1) {
                        string filterAccounts = QHS.AppAnd(QHS.CmpKey(tEntry.Rows[0]),
                            QHS.CmpEq("idacc", oldidaccDebit));
                        Conn.DO_UPDATE("entrydetail", filterAccounts,
                            new[] {"idacc", "idaccmotive"},
                            new[] {QHS.quote(newidaccDebit), QHS.quote(idaccmotiveMandate)}, 2);
                        checkLastError("aggiornando le scritture");

                    }
                }

            }
        }

        void aggiornaCreditiFattureCollegate(DataRow rEstim) {
            if (CfgFn.GetNoNullInt32(rEstim["yestim"]) < minimoAnnoImpegniDiBudget) return;
            DataTable allInvoice = Conn.RUN_SELECT("invoiceestimateview", "*", null, QHS.CmpKey(rEstim), null, false);
            foreach (DataRow rInvEst in allInvoice.Rows) {
                DataTable inv = Conn.RUN_SELECT("invoice", "*", null, QHS.AppAnd(
                    QHS.CmpEq("idinvkind", rInvEst["idinvkind"]),
                    QHS.CmpEq("yinv", rInvEst["yinv"]),
                    QHS.CmpEq("ninv", rInvEst["ninv"])
                ), null, false);
                if (inv.Rows.Count == 0) continue;
                DataRow rInv = inv.Rows[0];
                var idaccmotiveInvoice = getIdAccMotiveCreditVersion(rInv, DataRowVersion.Current);
                var idaccmotiveEstim = getIdAccMotiveCreditVersion(rEstim, DataRowVersion.Current);
                if (idaccmotiveInvoice.ToString() == idaccmotiveEstim.ToString()) continue;


                //var incas = getIncassiDocumento(rInv);
                //foreach (object idinc in incas) {
                //	correggiContoCreditoIncasso(idinc, rEstim);
                //}

                Conn.DO_UPDATE("invoice", QHS.CmpKey(rInv),
                    new[] {"idaccmotivedebit", "idaccmotivedebit_crg", "idaccmotivedebit_datacrg"},
                    new[] {
                        QHS.quote(rEstim["idaccmotivecredit"]),
                        QHS.quote(rEstim["idaccmotivecredit_crg"]),
                        QHS.quote(rEstim["idaccmotivecredit_datacrg"])
                    }, 3
                );
                checkLastError("aggiornando le scritture");


                object oldidaccCredit = EP.GetSupplierAccountForRegistry(idaccmotiveInvoice, rInv["idreg"]);
                object newidaccCredit = EP.GetSupplierAccountForRegistry(idaccmotiveEstim, rInv["idreg"]);
                if (oldidaccCredit.ToString() != newidaccCredit.ToString()) {
                    DataTable tEntry = Conn.RUN_SELECT("entry", "*", null,
                        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInv)), null, false);
                    if (tEntry.Rows.Count == 1) {
                        string filterAccounts = QHS.AppAnd(QHS.CmpKey(tEntry.Rows[0]),
                            QHS.CmpEq("idacc", oldidaccCredit));
                        Conn.DO_UPDATE("entrydetail", filterAccounts,
                            new[] {"idacc", "idaccmotive"},
                            new[] {QHS.quote(newidaccCredit), QHS.quote(idaccmotiveEstim)}, 2);
                        checkLastError("aggiornando le scritture");
                    }
                }

            }
        }

        void aggiornaDebitiFattureCollegateAParcella(DataRow rProfService) {
            if (rProfService["idinvkind"] == DBNull.Value) return;
            if (CfgFn.GetNoNullInt32(rProfService["ycon"]) < minimoAnnoImpegniDiBudget) return;
            DataTable inv = Conn.RUN_SELECT("invoice", "*", null, QHS.AppAnd(
                QHS.CmpEq("idinvkind", rProfService["idinvkind"]),
                QHS.CmpEq("yinv", rProfService["yinv"]),
                QHS.CmpEq("ninv", rProfService["ninv"])
            ), null, false);
            if (inv.Rows.Count == 0) return;
            DataRow rInv = inv.Rows[0];
            var idaccmotiveInvoice = getIdAccMotiveDebitVersion(rInv, DataRowVersion.Current);
            var idaccmotiveProfService = getIdAccMotiveDebitVersion(rProfService, DataRowVersion.Current);
            if (idaccmotiveInvoice.ToString() == idaccmotiveProfService.ToString()) return;

            //var pagam = getPagamentiDocumento(rInv);
            //foreach (object idexp in pagam) {
            //	correggiContoDebitoPagamento(idexp, rProfService);
            //}

            Conn.DO_UPDATE("invoice", QHS.CmpKey(rInv),
                new[] {"idaccmotivedebit", "idaccmotivedebit_crg", "idaccmotivedebit_datacrg"},
                new[] {
                    QHS.quote(rProfService["idaccmotivedebit"]),
                    QHS.quote(rProfService["idaccmotivedebit_crg"]),
                    QHS.quote(rProfService["idaccmotivedebit_datacrg"])
                }, 3
            );
            checkLastError("aggiornando la fattura");

            object oldidaccDebit = EP.GetSupplierAccountForRegistry(idaccmotiveInvoice, rInv["idreg"]);
            object newidaccDebit = EP.GetSupplierAccountForRegistry(idaccmotiveProfService, rInv["idreg"]);
            if (oldidaccDebit.ToString() != newidaccDebit.ToString()) {
                DataTable tEntry = Conn.RUN_SELECT("entry", "*", null,
                    QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInv)), null, false);
                if (tEntry.Rows.Count == 1) {
                    string filterAccounts = QHS.AppAnd(QHS.CmpKey(tEntry.Rows[0]),
                        QHS.CmpEq("idacc", oldidaccDebit));
                    Conn.DO_UPDATE("entrydetail", filterAccounts,
                        new[] {"idacc", "idaccmotive"},
                        new[] {QHS.quote(newidaccDebit), QHS.quote(idaccmotiveProfService)},
                        2);
                    checkLastError("aggiornando le scritture");
                }
            }


        }

        ///// <summary>
        ///// Correggi il conto di debito dei movimenti collegati e la scrittura in pd collegata all'elenco di trasm.
        ///// </summary>
        ///// <param name="idexp"></param>
        ///// <param name="rDoc"></param>
        //void correggiContoDebitoPagamento(object idexp, DataRow rDoc) {

        //	var idaccmotive = getIdAccMotiveDebitVersion(rDoc, DataRowVersion.Current);
        //	//Sfrutto l'esistenza dell'idreg per capire anche se il movimento è dell'anno corrente altrimenti non faccio nulla
        //	var idreg = Conn.DO_READ_VALUE("expense", QHS.AppAnd(QHS.CmpEq("ymov", Conn.GetEsercizio()),
        //		QHS.CmpEq("idexp", idexp)), "idreg");
        //	if (idreg == null || idreg == DBNull.Value) return;
        //	var idaccRegistry = EP.GetSupplierAccountForRegistry(idaccmotive, idreg);

        //	Conn.DO_UPDATE("expenselast", QHS.CmpEq("idexp", idexp),
        //		new[] {"idaccdebit"}, new[] {QHS.quote(idaccRegistry)}, 1);
        //	checkLastError("aggiornando il mov. di spesa");

        //	Conn.DO_UPDATE("entrydetail", QHS.CmpEq("idrelated", "expense§" + idexp ), //+ "§debit" 15040 rimuovo
        //		new[] {"idacc"}, new[] {QHS.quote(idaccRegistry)}, 1);
        //	checkLastError("aggiornando le scritture");

        //}

        ///// <summary>
        ///// Correggi il conto di credito dei movimenti collegati e la scrittura in pd collegata all'elenco di trasm.
        ///// </summary>
        ///// <param name="idinc"></param>
        ///// <param name="rDoc"></param>
        //void correggiContoCreditoIncasso(object idinc, DataRow rDoc) {
        //	var idaccmotive = getIdAccMotiveCreditVersion(rDoc, DataRowVersion.Current);
        //	//Sfrutto l'esistenza dell'idreg per capire anche se il movimento è dell'anno corrente altrimenti non faccio nulla
        //	var idreg = Conn.DO_READ_VALUE("income", QHS.AppAnd(QHS.CmpEq("ymov", Conn.GetEsercizio()),
        //		QHS.CmpEq("idinc", idinc)), "idreg");
        //	if (idreg == null || idreg == DBNull.Value) return;

        //	var idaccRegistry = EP.GetSupplierAccountForRegistry(idaccmotive, idreg);


        //	Conn.DO_UPDATE("incomelast", QHS.CmpEq("idinc", idinc),
        //		new[] {"idacccredit"}, new[] {QHS.quote(idaccRegistry)}, 1);
        //	checkLastError("aggiornando il mov. di entrata");

        //	Conn.DO_UPDATE("entrydetail", QHS.CmpEq("idrelated", "income§" + idinc ), //+ "§credit" 15040 tolgo tutto
        //		new[] {"idacc"}, new[] {QHS.quote(idaccRegistry)}, 1);
        //	checkLastError("aggiornando le scritture");

        //}

        void correggiDebitoDocumenti() {
            foreach (DataRow r in docToUpdateDebito) {
                //Non aggiorna la causale di debito di pagamenti di documenti cancellati, ma non dovrebbe nemmeno essere possibile
                // cancellarli
                if (r.RowState == DataRowState.Detached) continue;

                //var listIdExp = getPagamentiDocumento(r);
                //foreach (var idexp in listIdExp) {
                //	correggiContoDebitoPagamento(idexp, r);
                //}

                if (r.Table.TableName == "mandate") {
                    aggiornaDebitiFattureCollegate(r);
                }

                if (r.Table.TableName == "profservice") {
                    aggiornaDebitiFattureCollegateAParcella(r);
                }
            }

        }

        void correggiCreditoDocumenti() {
            foreach (DataRow r in docToUpdateCredito) {
                if (r.RowState == DataRowState.Detached) continue;
                //var listIdInc = getIncassiDocumento(r);
                //foreach (var idinc in listIdInc) {
                //	correggiContoCreditoIncasso(idinc, r);
                //}

                if (r.Table.TableName == "estimate") {
                    aggiornaCreditiFattureCollegate(r);
                }
            }

        }

        private List<string> _idrelatedToDelete = new List<string>();
        private List<string> _idRelatedForEntry = new List<string>();
        private List<string> _idRelatedForEntryDetail = new List<string>();
        bool _fromDelete;

        public void beforePost() {
            beforePost(false);
        }

        private ep_poster postingClass;

        //Chiamato solo dalla procedura stipendi con true
        public void beforePost(bool forceDelete) {
            //Queste liste sono compilate in beforePost perchè se poi sono cancellate le righe non sarebbero più disponibili in afterPost
            _idrelatedToDelete.Clear();
            _idRelatedForEntry.Clear();
            _idRelatedForEntryDetail.Clear();
            initDocumentoCorrigeDebitoCredito();
            if (DS != null) {
                if (DS.Tables[mainTable] == null) return;
            }

            DataTable t = DS.Tables[mainTable];
            if (t.Rows.Count == 0) return;
            DataRow rMain = t.Rows[0];
            if (!forceDelete) {
                //Questo è quello che fa "sempre" tranne nel CSA, che è l'unico punto in cui è chiamato BeforePost(true)
                if (mainTable == "mandate") {
                    checkDocumentoCorrigeDebito(rMain);
                    foreach (DataRow r in DS.Tables["mandatedetail"].Rows) {
                        if (r.RowState == DataRowState.Deleted) {
                            //Prende le righe di dettaglio cancellate anche se la riga principale non è cancellata
                            if (r["start", DataRowVersion.Original] != DBNull.Value ||
                                r["stop", DataRowVersion.Original] != DBNull.Value) {
                                _idRelatedForEntryDetail.Add(BudgetFunction.GetIdForDocument(r));
                            }

                            _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                        }
                    }
                }

                if (mainTable == "assetload") {
                    //buoni carico: cancella tutte le scritture su cespiti non in buono carico
                    foreach (DataRow r in DS.Tables["assetacquireview"].Select(QHS.IsNull("idassetload"))) {
                        _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                    }
                }

              
                if (mainTable == "assetunload") {
                    foreach (DataRow r in DS.Tables["assetamortizationunloadview"]
                        .Select(QHS.IsNull("idassetunload"))) {
                        _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                    }
                }

                if (mainTable == "grantload") {
                    foreach (DataRow r in DS.Tables["assetgrant"].Select(QHS.IsNull("idgrantload"))) {
                        _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));

                    }

                    foreach (DataRow r in DS.Tables["assetgrantdetail"].Select(QHS.IsNull("idgrantload"))) {
                        _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                    }
                }

                if (mainTable == "estimate") {
                    checkDocumentoCorrigeCredito(rMain);
                    foreach (DataRow r in DS.Tables["estimatedetail"].Rows) {
                        if (r.RowState == DataRowState.Deleted) {
                            //Prende le righe di dettaglio cancellate anche se la riga principale non è cancellata
                            if (r["start", DataRowVersion.Original] != DBNull.Value ||
                                r["stop", DataRowVersion.Original] != DBNull.Value) {
                                _idRelatedForEntryDetail.Add(BudgetFunction.GetIdForDocument(r));
                            }

                            _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                        }
                    }
                }

                if (mainTable == "invoice") {
                    checkDocumentoCorrigeCredito(rMain);
                    checkDocumentoCorrigeDebito(rMain);
                    foreach (DataRow r in DS.Tables["invoicedetail"].Rows) {
                        //Prende le righe di dettaglio cancellate anche se la riga principale non è cancellata
                        if (r.RowState == DataRowState.Deleted) {
                            _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                        }
                    }
                }

                if (mainTable == "itineration") {
                    checkDocumentoCorrigeDebito(rMain);
                }

                if (mainTable == "parasubcontract") {
                    checkDocumentoCorrigeDebito(rMain);
                }

                if (mainTable == "wageaddition") {
                    checkDocumentoCorrigeDebito(rMain);
                }

                if (mainTable == "profservice") {
                    checkDocumentoCorrigeDebito(rMain);
                }

                if (mainTable == "casualcontract") {
                    checkDocumentoCorrigeDebito(rMain);
                }

                //Se la riga principale non è cancellata, esce qui, tranne per i c.parasubordinati
                if (rMain.RowState != DataRowState.Deleted && mainTable != "parasubcontract") return;
            }

            //Passa di qui solo in caso di cancellazioni "vere" oppure se "forced" oppure se mainTable="parasubcontract"

            //in caso di cancellazioni o modifiche del documento, saranno effettuate nell'afterPost delle variazioni agli impegni,
            // sempre che non lo faccia direttamente il form del documento, come nel caso del c.passivo. Al momento solo in quel caso 
            // sono previste delle modifiche specifiche "pre", negli altri casi si agirà a posteriori (post-save) sul totale
            _fromDelete = true;
            if (mainTable == "mandate") {
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);
                foreach (DataRow rDettaglio in DS.Tables["mandatedetail"].Rows) {
                    //Prende le righe di dettaglio cancellate anche se la riga principale non è cancellata
                    if (rDettaglio["start", DataRowVersion.Original] != DBNull.Value ||
                        rDettaglio["stop", DataRowVersion.Original] != DBNull.Value) {
                        _idRelatedForEntryDetail.Add(BudgetFunction.GetIdForDocument(rDettaglio));
                    }


                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rDettaglio));
                }

                if (forceDelete) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));

                }
            }

            if (mainTable == "estimate") {
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                if (forceDelete) checkDocumentoCorrigeCredito(rMain);
                foreach (DataRow r in DS.Tables["estimatedetail"].Rows) {
                    //Prende le righe di dettaglio cancellate anche se la riga principale non è cancellata
                    if (r["start", DataRowVersion.Original] != DBNull.Value ||
                        r["stop", DataRowVersion.Original] != DBNull.Value) {
                        _idRelatedForEntryDetail.Add(BudgetFunction.GetIdForDocument(r));
                    }

                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                }

                if (forceDelete) _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }


            if (mainTable == "assetload" && forceDelete) {
                //buoni carico: cancella tutte le scritture su cespiti non in buono carico
                foreach (DataRow r in DS.Tables["assetacquireview"].Select()) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                }
            }

            if (mainTable == "assetunload" && forceDelete) {
                foreach (DataRow r in DS.Tables["assetamortizationunloadview"].Select()) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                }
            }

          

            if (mainTable == "grantload" && forceDelete) {
                foreach (DataRow r in DS.Tables["assetgrant"].Select()) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                }

                foreach (DataRow r in DS.Tables["assetgrantdetail"].Select()) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(r));
                }
            }



            if (mainTable == "invoice") {
                if (forceDelete) {
                    checkDocumentoCorrigeCredito(rMain);
                    checkDocumentoCorrigeDebito(rMain);
                }

                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (DataRow rDettaglio in DS.Tables["invoicedetail"].Rows) {
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rDettaglio));
                }

                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "itineration") {
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }

                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "casualcontract") {
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }

                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "wageaddition") {
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }
            }

            if (mainTable == "pettycashoperation") {
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "payroll") {
                //elencoRelatedCedolini = ottieniIdRelatedCedoliniNonErogati();
                //elencoRelatedBudgetCedolini = ottieniIdRelatedBudgetCedoliniNonErogati();
                DataRowVersion toConsider = DataRowVersion.Current;
                if (rMain.RowState == DataRowState.Deleted) toConsider = DataRowVersion.Original;
                int annoContratto = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract", QHS.CmpEq("idcon",
                    rMain["idcon", DataRowVersion.Original]), "ycon"));
                int annostop = esercizio;
                if (rMain["stop", toConsider] != DBNull.Value) {
                    annostop = ((DateTime) rMain["stop", toConsider]).Year;
                }

                if (annostop < annoContratto) annostop = annoContratto;
                object flag = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annostop), "flag");
                bool annoStopAperto = flag != null && flag != DBNull.Value && ((CfgFn.GetNoNullInt32(flag) & 32) == 0);
                bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                     (annoStopAperto == false && (annostop < esercizio));
                if (daConsiderare) {
                    _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                    _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
                }
            }

            if (mainTable == "parasubcontract") {
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);

                //elencoRelatedCedolini = ottieniIdRelatedCedoliniNonErogati();
                //elencoRelatedBudgetCedolini = ottieniIdRelatedBudgetCedoliniNonErogati();
                string filtroCedNonErogati = QHS.AppAnd(QHC.IsNull("disbursementdate"),
                    QHS.CmpEq("flagbalance", "N"), QHS.CmpEq("fiscalyear", esercizio), QHS.CmpKey(rMain));
                DataTable cedoliniNonErogati = Conn.RUN_SELECT("payroll", "*", null, filtroCedNonErogati, null, false);
                DataRowVersion toConsider = DataRowVersion.Current;
                if (rMain.RowState == DataRowState.Deleted) toConsider = DataRowVersion.Original;
                int annoContratto = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract",
                    QHS.CmpEq("idcon", rMain["idcon", toConsider]), "ycon"));
                int ultimoAnnoAperto = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("accountingyear",
                    QHS.AppAnd(QHS.BitClear("flag", 5), QHS.IsNotNull("flag")), "min(ayear)"));
                foreach (DataRow rCedolino in cedoliniNonErogati.Rows) {
                    int annostop = esercizio;
                    if (rCedolino["stop"] != DBNull.Value) {
                        annostop = ((DateTime) rCedolino["stop"]).Year;
                    }

                    if (annostop < annoContratto) annostop = annoContratto;
                    bool annoStopAperto = annostop >= ultimoAnnoAperto;
                    bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                         (annoStopAperto == false && (annostop < esercizio));
                    if (daConsiderare) {
                        _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rCedolino));
                        _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rCedolino));
                    }
                }
            }

            if (mainTable == "csa_import") { //anche per i debiti
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }

                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));

            }

            if (mainTable == "profservice") {
                if (forceDelete) checkDocumentoCorrigeDebito(rMain);
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }
            }

            if (mainTable == "taxpay") {
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            //TASK 10605 AGGIUNTO IVAPAY
            if (mainTable == "ivapay") {
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
            }

            if (mainTable == "csa_importver") {
                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "csa_importriep") {
                _idrelatedToDelete.Add(BudgetFunction.GetIdForDocument(rMain));
            }

            if (mainTable == "csa_import") { // anche per i debiti
                _idRelatedForEntry.Add(EP_functions.GetIdForDocument(rMain));
                foreach (string s in getAllIdRelatedLike(BudgetFunction.GetIdForDocument(rMain))) {
                    _idrelatedToDelete.Add(s);
                }
            }
        }



        List<string> getAllIdRelatedLike(string idrelated) {
            DataTable allChild = Conn.RUN_SELECT("epexp", "idepexp,idrelated", null,
                BudgetFunction.getDocChildCondition(QHS, idrelated), null, false);
            List<string> idrel = new List<string>();
            foreach (DataRow r in allChild.Rows) {
                string thisId = r["idrelated"].ToString();
                if (string.IsNullOrEmpty(thisId)) continue;
                if (idrel.Contains(thisId)) continue;
                idrel.Add(thisId);
            }

            return idrel;
        }

        bool cancellaImpegniBudget(int nphase, List<string> idrelated) {
            bool something = false;
            foreach (string idrel in idrelated) {
                if (string.IsNullOrEmpty(idrel)) continue;
                BudgetFunction bf = new BudgetFunction(Disp)
                    {metaNameForPosting = metaTableForPosting, autoIgnore = autoIgnore, silent = silentPosting};
                if (!bf.attivo) return false;
                //TODO: aggiungere caso particolare  per assetload
                bool res = bf.getEpMovForDocument(cicloAttivo() ? "epacc" : "epexp", idrel, nphase);
                if (doppioMovimento(mainTable)) {
                    res |= bf.getEpMovForDocument("epacc", idrel, nphase);
                }

                if (res) {
                    something = true;
                    res = bf.DeleteAll(invokedByInnerPosting ? postingClass : null);
                }
            }

            return something;
        }

        public bool silentPosting = false;
        public bool autoIgnore = false;
        public string metaTableForPosting = "epexp";

        void cancellaScrittureDetail(List<string> idRelated) {
            if (!EP.attivo) return;
            foreach (string idrel in idRelated) {
                if (string.IsNullOrEmpty(idrel)) continue;
                var parts = idrel.Split('§');
                var mainId = BudgetFunction.ComposeObjects(parts.ToList().Take(parts.Length - 1).ToArray());
                EP.GetEntryForDocument(mainId, true);
                EP.DeleteDetailByIdRelated(idrel, invokedByInnerPosting ? postingClass : null);
            }
        }

        void cancellaScritture(List<string> idRelated, ep_poster poster) {
            if (!EP.attivo) return;
            foreach (string idrel in idRelated) {
                if (string.IsNullOrEmpty(idrel)) continue;
                EP.GetEntryForDocument(idrel, true);
                if (EP.MainEntryExists())
                    EP.DeleteAll(poster);
            }
        }

        public bool generaScritture() {
            DataRow curr = getCurrentRow();
            if (curr == null) return false;
            bool res = generaScritture(curr);
            mostraEtichette();
            return res;
        }

        public bool silent = false;
        public bool chiediMovimentiParent = true;
        public bool silentBlocked = false; //se true silent  è sempre true

        /// <summary>
        /// Genera le scritture o gli impegni ove previsto per la riga corrente, altrimenti non fa nulla. Non aggiorna le etichette
        /// Se bf è null, salva anche su db altrimenti opera solo sul dataset
        /// Valorizza EPRules se salva le scritture se bf null
        /// </summary>
        /// <param name="curr">Current row</param>
        /// <param name="bf">BudgetFunction containing a dataaset to use for entry generation</param>
        public bool generaScritture(DataRow curr, BudgetFunction bf = null) {
            if (!abilitaScritture(curr)) return false;

            bool res = false;
            switch (mainTable) {
                case "upbcommessa":
                    res = generaScrittureCommessaCompletata(curr, bf);
                    break;
                case "mandate":
                    res = generaScrittureContrattoPassivo(curr, bf);
                    break;
                case "grantload":
                    res = generaScrittureRisconti(curr, bf);
                    break;
                case "assetload":
                    res = generaScrittureBuonoCarico(curr, bf);
                    break;
                case "assetunload":
                    res = generaScrittureBuonoScarico(curr, bf);
                    break;
                case "estimate":
                    res = generaScrittureContrattoAttivo(curr, bf);
                    break;
                case "invoice":
                    res = generaScrittureFattura(curr, bf);
                    break;
                case "paymenttransmission":
                    res = generaScrittureElencoTrasmPagamento(curr, bf);
                    foreach (DataTable t in EP.D.Tables)
                        RowChange.SetOptimized(t, true);
                    break;
                case "proceedstransmission":
                    res = generaScrittureElencoTrasmIncasso(curr, bf);
                    foreach (DataTable t in EP.D.Tables)
                        RowChange.SetOptimized(t, true);
                    break;
                case "itineration":
                    res = generaScrittureMissione(curr, bf);
                    break;
                case "casualcontract":
                    res = generaScrittureOccasionale(curr, bf);
                    break;
                case "wageaddition":
                    res = generaScrittureDipendente(curr, bf);
                    break;
                case "pettycashoperation":
                    res = generaScrittureFondoEconomale(curr, bf);
                    break;
                case "payroll":
                    res = generaScrittureCedolino(curr, bf);
                    break;
                case "profservice":
                    res = generaScrittureProfessionali(curr, bf);
                    break;
                case "taxpay":
                    res = generaScrittureLiquidazioneRitenute(curr, bf);
                    break;
                case "csa_import":
                  

                    if (tipoScrittura == "debito") {
                        res = generaScrittureDebitoAContiBancaCsa(curr, bf);
                    }
                    else {
                        res = generaScrittureImportazioneCsa(curr, bf);
                    }
                    foreach (DataTable t in EP.D.Tables) {
                        RowChange.SetOptimized(t, true);
                    }
                    break;
                case "ivapay":
                    res = generaScrittureLiquidazioneIva(curr, bf);
                    break;
                case "bankimport":
                    res = generaScrittureBankImport(curr, bf);
                    break;
                case "provision":
                    res = generaScrittureProvision(curr, bf);
                    break;
            }

            EPRules = null;

            if (res) {
                if (bf != null) {
                    return true;
                }

                res = salvaScritture();
                return res;
            }

            EP.undoDetailChanges();
            return false;
        }

        Dictionary<string, string> tipoFattura = new Dictionary<string, string>();
        Dictionary<string, string> tipoRegistro = new Dictionary<string, string>();

        //private string documentoAV(DataRow R) {
        //    int flagBit = CfgFn.GetNoNullInt32(R["flagbit"]);
        //    if ((flagBit & 16) != 0) return "V"; //Forza accertamenti di budget
        //    if ((flagBit & 32) != 0) return "A"; //Forza impegni di budget
        //    return tipoFatturaAV(R["idinvkind"]); //altrimenti vale la contabilizzazione in entrata o spesa
        //}

        private string tipoFatturaAV(object idInvKind) {
            if (tipoFattura.ContainsKey(idInvKind.ToString())) return tipoFattura[idInvKind.ToString()];
            string filterreg = QHS.CmpEq("idinvkind", idInvKind);
            int flag = CfgFn.GetNoNullInt32(
                Conn.DO_READ_VALUE("invoicekind", QHS.CmpEq("idinvkind", idInvKind), "flag"));
            bool acquisto = (flag & 1) == 0;
            /*
            DataTable invRegKind = Conn.RUN_SELECT("invoicekindregisterkind", "*", null, filterreg, null, false);
            DataRow[] registerToLink = invRegKind.Select();
            bool acquisto = false;
            foreach (DataRow iReg in registerToLink) {
                object regClass = Conn.DO_READ_VALUE("ivaregisterkind",
                    QHS.CmpEq("idivaregisterkind", iReg["idivaregisterkind"]),
                    "registerclass");
                if (regClass.ToString().ToUpper() == "A")
                    acquisto = true;
            }
            */
            tipoFattura[idInvKind.ToString()] = (acquisto ? "A" : "V");
            return tipoFattura[idInvKind.ToString()];

        }

        private string tipoRegistroAV(object idInvKind) {
            if (tipoRegistro.ContainsKey(idInvKind.ToString())) return tipoRegistro[idInvKind.ToString()];
            string filterreg = QHS.CmpEq("idinvkind", idInvKind);
            DataTable invRegKind = Conn.RUN_SELECT("invoicekindregisterkind", "*", null, filterreg, null, false);
            DataRow[] registerToLink = invRegKind.Select();
            bool acquisto = false;
            foreach (DataRow iReg in registerToLink) {
                object regClass = Conn.DO_READ_VALUE("ivaregisterkind",
                    QHS.CmpEq("idivaregisterkind", iReg["idivaregisterkind"]),
                    "registerclass");
                if (regClass.ToString().ToUpper() == "A")
                    acquisto = true;
            }

            tipoRegistro[idInvKind.ToString()] = (acquisto ? "A" : "V");
            return tipoRegistro[idInvKind.ToString()];

        }

        Dictionary<string, int> tipoAtt = new Dictionary<string, int>();

        private int tipoAttivita(object idInvKind) {
            if (tipoAtt.ContainsKey(idInvKind.ToString())) return tipoAtt[idInvKind.ToString()];
            string filterreg = QHS.CmpEq("idinvkind", idInvKind);
            DataTable invRegKind = Conn.RUN_SELECT("invoicekindregisterkind", "*", null, filterreg, null, false);
            DataRow[] registerToLink = invRegKind.Select();
            foreach (DataRow iReg in registerToLink) {
                object regClass = Conn.DO_READ_VALUE("ivaregisterkind",
                    QHS.CmpEq("idivaregisterkind", iReg["idivaregisterkind"]), "registerclass");
                if (regClass.ToString().ToUpper() == "P")
                    continue;
                int res = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("ivaregisterkind",
                    QHS.CmpEq("idivaregisterkind", iReg["idivaregisterkind"]), "flagactivity"));
                tipoAtt[idInvKind.ToString()] = res;
                return res;
            }

            tipoAtt[idInvKind.ToString()] = 1;
            return 1;
        }

        bool usaProRataAnnoOrigine = true; //true per attivare la nuova gestione



        private bool generaScrittureFattura(DataRow curr, BudgetFunction bf) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            if (DS.Tables["invoicedetail"].Rows.Count == 0)
                return false; //No details- no use for EP

            if (curr["idinvkind_real"] != DBNull.Value) {
                return false;
            }

            object idreg = curr["idreg"];
            object idregIva = idreg;

            if (curr["yinv"].ToString() != esercizio.ToString()) {
                return false;
            }

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            //DataRow EntrySetup= DS.entrysetup.Rows[0];
            string filtroInvKind = QHC.CmpEq("idinvkind", curr["idinvkind"]);
            DataRow rTipoDoc = DS.Tables["invoicekind"].Select(filtroInvKind)[0];
            DataTable invdet = DS.Tables["invoicedetail"];

            object doc;
            if (curr["doc"] != DBNull.Value) {
                doc = curr["doc"].ToString();
            }
            else {
                doc = "Doc. IVA " + rTipoDoc["codeinvkind"] + ' ' + curr["yinv"].ToString().Substring(2, 2) + "/" +
                      curr["ninv"];
            }

            int ndetails = invdet.Rows.Count;
            bool epexists = EP.MainEntryExists();
            if ((epexists == false) && (ndetails == 0)) return false; //No details- no use for EP


            DataRow mainEntry = EP.SetEntry(curr["description"], curr["adate"],
                doc, curr["docdate"], EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);

            string filterMainCurrent = QHC.CmpKey(curr);

            EP.ClearDetails(mainEntry);

            object idaccRefund12 = EP.GetAccountForIvaRefund12();
            object ivaPayment12 = EP.GetAccountForIvaPayment12();



            int myTipoAttivita = tipoAttivita(curr["idinvkind"]);
            //string myAVDocumento = documentoAV(curr);
            string mytipoRegistro = tipoRegistroAV(curr["idinvkind"]);

            bool istituzionale = (myTipoAttivita == 1);
            bool deferred = (curr["flagdeferred"].ToString().ToUpper() == "S");
            // Flagintracom può valere: S-intracom, N o X-extracom.
            bool isIntraCom = (curr["flagintracom"].ToString().ToUpper() != "N");

            bool isFlagReverseCharge = (curr["flag_reverse_charge"].ToString().ToUpper() != "N");

            string nomeDebitoCredito = nomeFattura(curr);

            bool applicaSplitPaymentCommerciale =
                (curr["flag_enable_split_payment"].ToString().ToUpper() == "S") && //split payment
                (myTipoAttivita != 1) && //commerciale o promiscuo
                (mytipoRegistro == "A"); //acquisto

            bool splitPaymentVendita = (curr["flag_enable_split_payment"].ToString().ToUpper() == "S") &&
                                       //split payment
                                       (mytipoRegistro == "V"); //vendita

            DataTable invKindYear = Conn.RUN_SELECT("invoicekindyear", "*", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idinvkind", curr["idinvkind"])), null, false);
            if (invKindYear.Select().Length == 0) {
                ShowMessage(
                    "Il tipo fattura selezionato non ha la configurazione per le scritture in partita doppia");
                return false;
            }

            DataRow tipoDocYear = invKindYear.Rows[0];

            object contoIvaCreditoODebito; ///conto per l'iva a CREDITO o a DEBITO a seconda del tipo documento
            object contoIvaCreditoDebitoIntra = DBNull.Value;
            object contoIvaCreditoDebitoSplit = DBNull.Value;

            object contoIvaIndetraibile = DBNull.Value;
            //costo iva indetraibile (per chi calcola riga per riga e gestisce tale conto)

            if (isIntraCom || isFlagReverseCharge) {
                contoIvaIndetraibile = tipoDocYear["idacc_unabatable_intra"];
            }

            if (applicaSplitPaymentCommerciale) {
                contoIvaIndetraibile = tipoDocYear["idacc_unabatable_split"];
            }

            if (!(isIntraCom || applicaSplitPaymentCommerciale || isFlagReverseCharge) ||
                contoIvaIndetraibile == DBNull.Value) {
                contoIvaIndetraibile = tipoDocYear["idacc_unabatable"];
            }


            //conto per l'iva a CREDITO o a DEBITO (DETRAIBILE) a seconda del tipo documento

            if (deferred) {
                contoIvaCreditoODebito = (tipoDocYear["idacc_deferred"] != DBNull.Value)
                    ? tipoDocYear["idacc_deferred"]
                    : tipoDocYear["idacc"];
            }
            else {
                contoIvaCreditoODebito = tipoDocYear["idacc"];
            }

            //conto per l'iva di segno opposto per fatture intracom.
            if (isIntraCom || isFlagReverseCharge) {
                if (deferred) {
                    contoIvaCreditoDebitoIntra = (tipoDocYear["idacc_deferred_intra"] != DBNull.Value)
                        ? tipoDocYear["idacc_deferred_intra"]
                        : tipoDocYear["idacc_intra"];
                }
                else {
                    contoIvaCreditoDebitoIntra = tipoDocYear["idacc_intra"];
                }
            }

            //conto per l'iva di segno opposto per fatture split payment commerciale acquisti.
            if (applicaSplitPaymentCommerciale) {
                if (deferred) {
                    contoIvaCreditoDebitoSplit = (tipoDocYear["idacc_deferred_split"] != DBNull.Value)
                        ? tipoDocYear["idacc_deferred_split"]
                        : tipoDocYear["idacc_split"];
                }
                else {
                    contoIvaCreditoDebitoSplit = tipoDocYear["idacc_split"];
                }
            }

            //Per le fatture istituzionali non intracom ignora l'iva detraibile Sara 
            string notaSuConto = "";
            if (istituzionale && !isIntraCom) {
                if (contoIvaCreditoODebito != DBNull.Value) {
                    notaSuConto =
                        "Il conto iva indetraibile del registro è stato ignorato essendo un registro istituzionale";
                    contoIvaCreditoODebito = DBNull.Value;
                }
            }


            object contoSconto = tipoDocYear["idacc_discount"];

            byte flag = CfgFn.GetNoNullByte(rTipoDoc["flag"]);
            bool registroVendita = (mytipoRegistro == "V");
            bool movEntrata = ((flag & 1) != 0);

            bool flagvariazione = (flag & 4) != 0;

            int flagInvoice = CfgFn.GetNoNullInt32(curr["flagbit"]);
            bool bollaDoganale = ((flagInvoice & 1) != 0);
            bool fatturaSpedizioniere = ((flagInvoice & 2) != 0);
            bool commercialePromiscuo = (myTipoAttivita != 1);
            bool RecuperoIVAEstera = ((flagInvoice & 64) != 0);

            if (movEntrata != registroVendita)
                flagvariazione = !flagvariazione;


            bool registroAcquisto = !registroVendita;

            string idepcontext;
            if (registroVendita) {
                idepcontext = flagvariazione ? "FATVENVAR" : "FATVEN";

            }
            else {
                idepcontext = flagvariazione ? "FATACQVAR" : "FATACQ";
            }


            if (isIntraCom && istituzionale) {
                object idaccIvapay;
                //if (vendita) { NON ESISTONO VENDITE ISTITUZIONALI, cmq ora si è dismesso l'uso del conto per il rimborso , task 9849
                // qua ci passava nel caso di autofatture intra, ora non più usate
                //    idregIva = _idregRimborso12;
                //    idaccIvapay = idaccRefund12;
                //}
                //else {
                idregIva = _idregVersamento12;
                idaccIvapay = ivaPayment12;
                //}
                if (contoIvaCreditoODebito == DBNull.Value)
                    contoIvaCreditoODebito = idaccIvapay;
            }

            object contoDebitoCreditovsFornitore; //conto di debito o credito
            object idaccmotiveDebit = getIdAccMotiveDebitCredit(curr["idaccmotivedebit"], curr["idaccmotivedebit_crg"],
                curr["idaccmotivedebit_datacrg"]);
            if (movEntrata) {
                contoDebitoCreditovsFornitore = EP.GetCustomerAccountForRegistry(idaccmotiveDebit, curr["idreg"]);
            }
            else {
                contoDebitoCreditovsFornitore = EP.GetSupplierAccountForRegistry(idaccmotiveDebit, curr["idreg"]);
            }

            if (contoDebitoCreditovsFornitore == null || contoDebitoCreditovsFornitore == DBNull.Value) {
                ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                return false;
            }

            object idaccRegistryBolla = DBNull.Value;
            if (fatturaSpedizioniere) {
                //conto usato nella seconda scrittura in segno opposto su valore doganale o spese anticipate, per il solo costo 
                object idaccmotiveRegistryBolla = Conn.DO_READ_VALUE("invoice",
                    QHS.AppAnd(
                        QHS.CmpEq("idinvkind_forwarder", curr["idinvkind"]),
                        QHS.CmpEq("yinv_forwarder", curr["yinv"]),
                        QHS.CmpEq("ninv_forwarder", curr["ninv"])), "max(idaccmotivedebit)");
                idaccRegistryBolla = getIdAccFromMotive(idaccmotiveRegistryBolla);
                if (idaccRegistryBolla == null || idaccRegistryBolla == DBNull.Value) {
                    object idregDogana = Conn.DO_READ_VALUE("invoice", QHS.AppAnd(
                        QHS.CmpEq("idinvkind_forwarder", curr["idinvkind"]),
                        QHS.CmpEq("yinv_forwarder", curr["yinv"]),
                        QHS.CmpEq("ninv_forwarder", curr["ninv"])), "max(idreg)");
                    idaccRegistryBolla = EP.GetSupplierAccountForRegistry(null, idregDogana);
                    ;
                }
            }


            double tassoProRataAttuale = CfgFn.GetNoNullDouble(
                Conn.DO_READ_VALUE("invoicekindyearview",
                    QHS.AppAnd(QHS.CmpEq("idinvkind", curr["idinvkind"]), QHS.CmpEq("ayear", esercizio)),
                    "abatablerate",
                    null));

            double tassocambio = CfgFn.GetNoNullDouble(CfgFn.GetNoNullDouble(curr["exchangerate"]));
            int annoFattura = CfgFn.GetNoNullInt32(curr["yinv"]);

            bool isFattRic = false;


            DataRow linkedProfServiceMain = null;
            if (!deferred) {
                DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.CmpKey(curr), null, false);
                if (profService != null && profService.Rows.Count == 1) {
                    linkedProfServiceMain = profService.Rows[0];
  
                }
            }

            //bool mainFattRic = isFattRic;//fattura complessivamente collegate ad un documenti di tipo fattura a ricevere
            //decimal totaleDifferenzaProrata = 0;
            //Ciclo sui dettagli
            foreach (DataRow rInvDet in DS.Tables["invoicedetail"].Select(filterMainCurrent)) {
                bool usaProRataAnnoOrigineDettaglio = usaProRataAnnoOrigine;

                DataRow rMandateDetail = null;
                if (rInvDet["idmankind"] != DBNull.Value) {
                    DataTable tManDet = Conn.RUN_SELECT("mandatedetail", "*", null,
                        QHS.AppAnd(QHS.MCmp(rInvDet, "idmankind", "yman", "nman"),
                            QHS.CmpEq("rownum", rInvDet["manrownum"])), null, false);
                    if (tManDet.Rows.Count > 0) rMandateDetail = tManDet.Rows[0];
                }

                #region Calcolo flag isFattRic

                isFattRic = false;
                string idrelatedLinkedDoc = ""; ;
                bool isFattRateo = false;
                DataRow linkedProfService = linkedProfServiceMain;
                if (rInvDet["ycon"] != DBNull.Value && rInvDet["ncon"] != DBNull.Value) {
                    DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.MCmp(rInvDet, "ycon", "ncon"),
                        null, false);
                    if (profService != null && profService.Rows.Count == 1) {
                        linkedProfService = profService.Rows[0];
                    }
                }

                //prorata per fatt. a ricevere, usato nell'impegno se fatto in anni precedenti
                double proRataFattRic = abatableRateOfYear(esercizio);

                int flagDetail = CfgFn.GetNoNullInt32(rInvDet["flagbit"]);
                bool valoreDoganale = ((flagDetail & 1) != 0);
                bool speseAnticipate = ((flagDetail & 2) != 0);

                //task 8714 Implementazione sui contratti professionali della gestione automatica ratei e fatture da ricevere
                if (linkedProfService != null) {
                    int annoCProf = CfgFn.GetNoNullInt32(linkedProfService["ycon"]);
                    if (annoCProf < annoFattura) {
                        object epkind = linkedProfService["epkind"];
                        if (epkind != null) {
                            if (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R") {
                                isFattRic = true; //valorizza fatt.  a ricevere per professionali
                                idrelatedLinkedDoc = EP_functions.GetIdForDocument(linkedProfService); 
                            }

                            isFattRateo = epkind.ToString().ToUpper() == "R";
                        }
                    }
                }

                //In base al task 5413, non considera il flag fatture a ricevere se l'anno dell'ordine è lo stesso dell'anno fattura
                //In base al task 17551, non considera il flag fatture a ricevere se l'anno inizio del dettaglio ordine è lo stesso dell'anno fattura
                if (rInvDet["idmankind"] != DBNull.Value) {
                    int annoOrdine = CfgFn.GetNoNullInt32(rInvDet["yman"]);
                    int yearStartDettaglio = annoOrdine;

                    if (rMandateDetail["start"] != DBNull.Value)  
                        {
                            DateTime originalDate = (DateTime)(rMandateDetail["start"]);
                            yearStartDettaglio = originalDate.Year;
                        }

                        if ((annoOrdine < annoFattura) && (yearStartDettaglio < annoFattura)) {
                        object epkind = rMandateDetail["epkind"];
                        if (epkind != null) {
                            if (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R") {
                                isFattRic = true; //valorizza fatt.  a ricevere per c.passivi
                                idrelatedLinkedDoc = EP_functions.GetIdForDocument(rMandateDetail);
                            }

                            isFattRateo = epkind.ToString().ToUpper() == "R";
                        }
                    }
                }


                if (rInvDet["idestimkind"] != DBNull.Value) {
                    int annoContratto = CfgFn.GetNoNullInt32(rInvDet["yestim"]);
                    int yearStartDettaglio = annoContratto;
 
                    if (annoContratto < annoFattura) {
                        string filterestimate = QHS.CmpMulti(rInvDet, "idestimkind", "yestim", "nestim");
                        filterestimate = QHS.AppAnd(filterestimate, QHS.CmpEq("rownum", rInvDet["estimrownum"]));
                        DataRow rEstimateDetail = null;
                        DataTable tEstimDet = Conn.RUN_SELECT("estimatedetail", "*", null,
                        filterestimate, null, false);
                        if (tEstimDet.Rows.Count > 0) rEstimateDetail = tEstimDet.Rows[0];
                        object epkind = rEstimateDetail["epkind"];
                        if (epkind != null) {
                            if (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R") {
                                isFattRic = true; //valorizza fatt.  a ricevere per c.attivi
                                idrelatedLinkedDoc = EP_functions.GetIdForDocument(rEstimateDetail);
                            }

                            isFattRateo = epkind.ToString().ToUpper() == "R";
                        }
                    }
                }

                #endregion

                if (rInvDet["idupb"] == DBNull.Value) {
                    ShowMessage("Attenzione, il dettaglio " + rInvDet["detaildescription"] +
                                " non ha l'indicazione dell'UPB");
                    return false;
                }


                double rImponibile = CfgFn.GetNoNullDouble(rInvDet["taxable"]);

                double iva = CfgFn.GetNoNullDouble(rInvDet["tax"]);
                double quantita = CfgFn.GetNoNullDouble(rInvDet["npackage"]);
                var scontoPerc = CfgFn.GetNoNullDouble(rInvDet["discount"]);
                double imponibileD = CfgFn.RoundValuta(rImponibile * quantita * tassocambio);
                decimal imponibile = Convert.ToDecimal(imponibileD);
                decimal imponibileScontato =
                    Convert.ToDecimal(CfgFn.RoundValuta(rImponibile * quantita * tassocambio * (1 - scontoPerc)));

                decimal sconto = imponibile - imponibileScontato;

                object idepacc = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"]))) {
                    idepacc = _listaAccertamenti[CfgFn.GetNoNullInt32(rInvDet["rownum"])]["idepacc"];
                }

                if (idepacc == DBNull.Value) idepacc = rInvDet["idepacc"];

                object idepexp = DBNull.Value;
                object idepexp_main = DBNull.Value;
                object idepacc_main = DBNull.Value;

 
                if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"]))) {
                    idepexp = _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])]["idepexp"];
                    
                    if (_listaImpegniDiffProrata.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"])))  
                    idepexp = DBNull.Value; 
                }

   
                if (idepexp == DBNull.Value) idepexp = rInvDet["idepexp"];

                var idrelated = EP_functions.GetIdForDocument(rInvDet).ToString();
                // Se è una NC valorizziamo l'idrelated di entrydetail pari all'idrelated del dettaglio fattura-madre,
                // considerando quindi la NC un'estensione della fattura( alla stregua della scrittura della distinta che chiude il debito).
                if (rInvDet["idinvkind_main"] != DBNull.Value) {
                    //rintracciamo la riga della fattura madre e costruiamo l'idrelated del dettaglio scrittura con i suoi riferimenti
                    if (rInvDet["rownum_main"] != null && rInvDet["rownum_main"] != DBNull.Value) {
                        //associazione alla fattura madre con n.riga (versione nuova)
                        string filter = QHS.AppAnd(QHS.CmpEq("idinvkind", rInvDet["idinvkind_main"]), QHS.CmpEq("yinv", rInvDet["yinv_main"]),
                                QHS.CmpEq("ninv", rInvDet["ninv_main"]), QHS.CmpEq("rownum", rInvDet["rownum_main"]));
                        DataTable tMainInvoicedetail = Conn.RUN_SELECT("invoicedetail", "*", null, filter, null, false);
                        if (tMainInvoicedetail != null && tMainInvoicedetail.Rows.Count == 1) {
                            DataRow rMainInvoicedetail = tMainInvoicedetail.Rows[0];
                            idrelated = EP_functions.GetIdForDocument(rMainInvoicedetail).ToString();
                        }
                    }
					else {
                        //associazione alla fattura madre fatta all'intero documento senza specificare il n.riga(versione attuale)
                        string filter = QHS.AppAnd(QHS.CmpEq("idinvkind", rInvDet["idinvkind_main"]), QHS.CmpEq("yinv", rInvDet["yinv_main"]),
                                QHS.CmpEq("ninv", rInvDet["ninv_main"]));
                        DataTable tMainInvoice = Conn.RUN_SELECT("invoice", "*", null, filter, null, false);
                        if (tMainInvoice != null && tMainInvoice.Rows.Count == 1) {
                            DataRow rMainInvoice = tMainInvoice.Rows[0];
                            idrelated = EP_functions.GetIdForDocument(rMainInvoice).ToString();
                        }

                    }
                }
                if (registroAcquisto) {
                    //task 10014 non consideriamo i c.passivi di anni precedenti all'EP
                    // successivamente 10416 , considera data inizio dett.
                    //Calcola l'anno in cui  dovrebbe essere stato generato l'impegno di budget associato al dettaglio contratto
                    int annoDettaglio = CfgFn.GetNoNullInt32(rInvDet["yman"]);
                    if (annoDettaglio > 0) {
                        object oDataInizio = Conn.DO_READ_VALUE("mandatedetail",
                            QHS.AppAnd(QHS.CmpEq("idmankind", rInvDet["idmankind"]),
                                QHS.CmpEq("yman", rInvDet["yman"]),
                                QHS.CmpEq("nman", rInvDet["nman"]),
                                QHS.CmpEq("rownum", rInvDet["manrownum"])),
                            "start");
                        if (oDataInizio == null) {
                            ShowMessage(
                                $"Non è stato trovato il dettaglio contratto passivo collegato alla riga fattura n.{rInvDet["rownum"]} ",
                                "Errore");
                            return false;
                        }

                        if (oDataInizio != DBNull.Value) {
                            annoDettaglio = ((DateTime) oDataInizio).Year;
                        }
                    }
                    //valorizza il prorata della Fatt. a ricevere come da contratto

                    if (annoDettaglio > 0) {
                        string idrelatedMandateDetail = BudgetFunction.GetIdForDocument(rMandateDetail);
                        int primoAnnoScrittura = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("entrydetail",
                            QHS.CmpEq("idrelated", idrelatedMandateDetail), "min(yentry)"));
                        if (primoAnnoScrittura != 0) {
                            annoDettaglio = primoAnnoScrittura;
                        }
                        else {
                            annoDettaglio = esercizio;
                        }

                        proRataFattRic = abatableRateOfYear(annoDettaglio);
                    }

                    if ((isFattRic == false) && idepexp == DBNull.Value && rMandateDetail != null &&
                        annoDettaglio >= minimoAnnoImpegniDiBudget
                    ) {
                        idepexp = rMandateDetail["idepexp"];
                        if (idepexp == null) {
                            ShowMessage(
                                $"Non è stato trovato il dettaglio contratto passivo collegato alla riga fattura n.{rInvDet["rownum"]} ",
                                "Errore");
                            return false;
                        }
                    }

                }

                if (registroVendita) {
                    int annoDettaglio = CfgFn.GetNoNullInt32(rInvDet["yestim"]);
                    if (annoDettaglio > 0) {
                        object oDataInizio = Conn.DO_READ_VALUE("estimatedetail",
                            QHS.AppAnd(QHS.CmpEq("idestimkind", rInvDet["idestimkind"]),
                                QHS.CmpEq("yestim", rInvDet["yestim"]),
                                QHS.CmpEq("nestim", rInvDet["nestim"]),
                                QHS.CmpEq("rownum", rInvDet["estimrownum"])),
                            "start");
                        if (oDataInizio == null) {
                            ShowMessage(
                                $"Non è stato trovato il dettaglio contratto attivo collegato alla riga fattura n.{rInvDet["rownum"]} ",
                                "Errore");
                            return false;
                        }

                        if (oDataInizio != DBNull.Value) {
                            annoDettaglio = ((DateTime) oDataInizio).Year;
                        }
                    }

                    if (idepacc == DBNull.Value && rInvDet["idestimkind"] != DBNull.Value
                                                && annoDettaglio >= minimoAnnoImpegniDiBudget) {
                        idepacc = Conn.DO_READ_VALUE("estimatedetail", QHS.AppAnd(
                            QHS.CmpEq("idestimkind", rInvDet["idestimkind"]),
                            QHS.CmpEq("yestim", rInvDet["yestim"]),
                            QHS.CmpEq("nestim", rInvDet["nestim"]),
                            QHS.CmpEq("rownum", rInvDet["estimrownum"])
                        ), "idepacc");
                        if (idepacc == null) {
                            ShowMessage(
                                $"Non è stato trovato il dettaglio contratto attivo collegato alla riga fattura n.{rInvDet["rownum"]} ",
                                "Errore");
                            return false;
                        }
                    }

                }

                //TODO: Condizionare a conto di costo    le seguenti due ??
                if (!isFattRic) {
                    if (idepexp == DBNull.Value) {
                        if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"]))) {
                            idepexp = _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])]["idepexp"];
                        }
                    }

                    if (idepexp == DBNull.Value) {
                        idepexp = getIdEpExpByIdRelated(BudgetFunction.GetIdForDocument(rInvDet), 2);
                    }
                    
                    // Se è una NC rintracciamo l'idrelated del dettaglio della fattura-madre,
                    if (rInvDet["idinvkind_main"] != DBNull.Value) {
                        if (rInvDet["rownum_main"] != null && rInvDet["rownum_main"] != DBNull.Value) {
                            //associazione alla fattura madre con n.riga (versione nuova)
                            string filter = QHS.AppAnd(QHS.CmpEq("idinvkind", rInvDet["idinvkind_main"]), QHS.CmpEq("yinv", rInvDet["yinv_main"]),
                                    QHS.CmpEq("ninv", rInvDet["ninv_main"]), QHS.CmpEq("rownum", rInvDet["rownum_main"]));
                            DataTable tMainInvoicedetail = Conn.RUN_SELECT("invoicedetail", "*", null, filter, null, false);
                            if (tMainInvoicedetail != null && tMainInvoicedetail.Rows.Count == 1) {
                                DataRow rMainInvoicedetail = tMainInvoicedetail.Rows[0];
                                idepexp_main = getIdEpExpByIdRelated(BudgetFunction.GetIdForDocument(rMainInvoicedetail), 2);
                                idepacc_main = getIdEpAccByIdRelated(BudgetFunction.GetIdForDocument(rMainInvoicedetail), 2);
                            }
                        }
                        else {
                            //associazione alla fattura madre fatta all'intero documento senza specificare il n.riga(versione attuale)
                            string filter = QHS.AppAnd(QHS.CmpEq("idinvkind", rInvDet["idinvkind_main"]), QHS.CmpEq("yinv", rInvDet["yinv_main"]),
                                    QHS.CmpEq("ninv", rInvDet["ninv_main"]));
                            DataTable tMainInvoice = Conn.RUN_SELECT("invoice", "*", null, filter, null, false);
                            if (tMainInvoice != null && tMainInvoice.Rows.Count == 1) {
                                DataRow rMainInvoice = tMainInvoice.Rows[0];
                                idepexp_main = getIdEpExpByIdRelated(BudgetFunction.GetIdForDocument(rMainInvoice), 2);
                                idepacc_main = getIdEpAccByIdRelated(BudgetFunction.GetIdForDocument(rMainInvoice), 2);
                            }

                        }
                    }


                    //FORSE in questo ramo dovrebbe andarsi a valorizzare l'accertamento di budget ove esista. Questo solo se il conto è di ricavo
                    //TODO: condizionare a conto di ricavo le seguenti due ??
                    if (idepacc == DBNull.Value) {
                        if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"]))) {
                            idepacc = _listaAccertamenti[CfgFn.GetNoNullInt32(rInvDet["rownum"])]["idepacc"];
                        }
                    }

                    if (idepacc == DBNull.Value) {
                        idepacc = getIdEpAccByIdRelated(BudgetFunction.GetIdForDocument(rInvDet), 2);
                    }

                    if (_listaAccertamentiDiffProrata.ContainsKey(CfgFn.GetNoNullInt32(rInvDet["rownum"]))) {
                        idepacc = DBNull.Value;
                    }

                }

                #region             calcolo ivaIndetraibileDovutaAProrataPerDettaglio valoreIvaDetraibilePerDettaglio ivaIndetraibilePerDettaglio


                double ivaindetraibile = 0; //CfgFn.GetNoNullDouble(Rinvdet["unabatable"]);
                double ivadetraibileProRataCorrente; //CfgFn.RoundValuta(ivadetraibilelorda*abatablerate);		
                double ivadetraibileFattRic;

                if (registroVendita) {
                    ivadetraibileProRataCorrente = CfgFn.RoundValuta(iva);
                    ivadetraibileFattRic = CfgFn.RoundValuta(iva);
                }
                else {
                    if (istituzionale) {
                        //non c'è iva detraibile
                        ivaindetraibile = CfgFn.RoundValuta(iva);
                        ivadetraibileProRataCorrente = 0;
                        ivadetraibileFattRic = 0;
                    }
                    else {
                        ivaindetraibile = CfgFn.GetNoNullDouble(rInvDet["unabatable"]);
                        var ivadetraibilelorda =
                            CfgFn.RoundValuta(
                                (iva - ivaindetraibile)); //CfgFn.RoundValuta((iva-ivaindetraibile)*tassocambio);
                        ivadetraibileProRataCorrente = CfgFn.RoundValuta(ivadetraibilelorda * tassoProRataAttuale);
                        ivadetraibileFattRic = CfgFn.RoundValuta(ivadetraibilelorda * proRataFattRic);
                    }
                }

                decimal ivaIndetraibileNoProrata = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivaindetraibile));
                decimal valoreIvaTotale = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(rInvDet["tax"]));

                //iva = iva detraibile, da movimentarsi con il conto normale dell'iva (acq/vendite)
                decimal valoreIvaDetraibileAttuale =
                    CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileProRataCorrente));
                decimal valoreIvaDetraibileFattRic = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileFattRic));

                decimal ivaIndetraibileAttuale = valoreIvaTotale - valoreIvaDetraibileAttuale;
                decimal ivaIndetraibileFattRic = valoreIvaTotale - valoreIvaDetraibileFattRic;

                //Per chiudere l'impegno di budget devo usare  ivaIndetraibileFattRic e NON    ivaIndetraibile
                //mentre la differenza devo totalizzarla per creare alla fine un impegno od un accerta

                decimal ivaIndetraibileDovutaAProrataAttuale = ivaIndetraibileAttuale - ivaIndetraibileNoProrata;
                decimal ivaIndetraibileDovutaAProrataFattRic = ivaIndetraibileFattRic - ivaIndetraibileNoProrata;


                //Questi sono i valori che saranno considerati nella scrittura, unitamente a diffProrata
                decimal ivaIndetraibileDovutaAProrataPerDettaglio = ivaIndetraibileDovutaAProrataAttuale;
                decimal ivaDetraibilePerDettaglio = valoreIvaDetraibileAttuale;
                decimal ivaIndetraibilePerDettaglio = ivaIndetraibileAttuale;

                //se positiva c'è più costo rispetto a quanto impegnato e bisognerà creare un impegno aggiuntivo (o variazione di quello esist.),
                //  se negativa ce n'è di meno e ci sarà un ricavo
                decimal diffProrata = 0;

                //ivadetraibile corrente = iva totale - iva indetraibile corrente
                // diffProrata = iva indetr. corrente - iva indetr. fattric
                // ivadetraibile corrente = iva totale - iva indetr. fattric - diffProrata
                // ivadetraibile corrente = iva detraibile fatt.ric  - diffProrata
                // se applichiamo il codice in if(usaProRataAnnoOrigine) ->
                //     ivadetraibile "corrente" = ivaDetraibilePerDettaglio - diffProrata
                //     iva indetraibile "corrente" = ivaIndetraibileDovutaAProrataFattRic + diffProrata
                //     è coerente perchè la somma deve sempre fare l'iva totale

                if (!commercialePromiscuo) {
                    usaProRataAnnoOrigineDettaglio = false;
                }

                if (!isFattRic) {
                    usaProRataAnnoOrigineDettaglio = false;
                }


                if (usaProRataAnnoOrigineDettaglio) {
                    diffProrata = ivaIndetraibileDovutaAProrataAttuale - ivaIndetraibileDovutaAProrataFattRic;
                    ivaIndetraibileDovutaAProrataPerDettaglio = ivaIndetraibileDovutaAProrataFattRic;
                    //ivaDetraibilePerDettaglio = valoreIvaDetraibileFattRic;
                    ivaIndetraibilePerDettaglio = ivaIndetraibileFattRic;
                }

                #endregion

                //ivaindetraibile = iva indetraibile NON dovuta a prorata
                //L'iva indetraibile dovuta a prorata NON deve  andare a fatture da ricevere ma sempre a costo

                object idaccmotive = rInvDet["idaccmotive"];
                if (idaccmotive == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {rInvDet["detaildescription"]} non ha la causale!");
                    return false;
                }

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotive);
                if (rEntries.Length == 0) {
                    ShowMessage(
                        $"Non è stata ben configurata la causale del dettaglio {rInvDet["detaildescription"]}. Impossibile generare le scritture.",
                        "Errore");
                    return false;
                }

                var idaccCostoORicavo = rEntries[0]["idacc"];

                bool collegaImpegno = EP.isCosto(idaccCostoORicavo);
                bool collegaAccertamento = EP.isRicavo(idaccCostoORicavo);

                object idaccIvaNonDovutaAProrata = contoIvaIndetraibile;
                object idaccIvaDovutaAProrata = contoIvaIndetraibile;

                //Calcola il conto di costo per l'iva indetraibile, prendendo quello principale ova non sia condigurato
                //Se è valore doganale, considera comunque il conto di costo principale per l'iva indetraibile
                if (idaccIvaDovutaAProrata == DBNull.Value || (UsaImpegniDiBudget && !valoreDoganale)) {
                    idaccIvaDovutaAProrata = idaccCostoORicavo;
                    idaccIvaNonDovutaAProrata = idaccCostoORicavo;
                }

                var idrelatedDiffProrata = BudgetFunction.GetIdForDocument(rInvDet) + "§diffprorata";
                var idrelatedProrata = BudgetFunction.GetIdForDocument(rInvDet) + "§prorata";
                var idrelatedNoProrata = BudgetFunction.GetIdForDocument(rInvDet) + "§noprorata";
                //Questo conto deve essere usato per l'eventuale scrittura su differenza prorata
                object idaccmotiveDiffProrata =
                    diffProrata > 0 ? getIdAccMotiveCostoProrata() : getIdAccMotiveRicavoProrata();
                object idaccCostoRicavoDiffProrata = getIdAccFromMotive(idaccmotiveDiffProrata, rInvDet["idupb"]);

                if (isFattRic && (registroVendita == false)) {
                    if (!isFattRateo) {
                        //E' fattura a ricevere di acquisto
                        if (!silent) {
                            ShowMessage(
                                "Per il dettaglio " + rInvDet["detaildescription"] +
                                " sarà considerato il conto 'fatture da ricevere'", "Avviso", false);
                        }

                        //Per le fatt. da ricevere imposta il conto apposito al posto di quello di costo. Attenzione che la differenza iva per prorata andrà su un altro conto (costo o ricavo),
                        //   che deve essere quello principale
                        idaccCostoORicavo = _idaccInvoicetoreceive;
                    }

                    //per le fatture istituzionali imposto il conto di iva indetraibile a quello iva a ricevere. 
                    // per le altre NO (vedi task 4587)
                    if (istituzionale) {
                        idaccIvaNonDovutaAProrata = _idaccInvoicetoreceive;
                    }
                    else {
                        idrelatedProrata = BudgetFunction.GetIdForDocument(rInvDet);
                        idrelatedNoProrata =
                            BudgetFunction
                                .GetIdForDocument(rInvDet); //altrimenti poi si confonde e non trova l'impegno giusto
                    }

                    if (valoreDoganale)
                        idaccIvaDovutaAProrata =
                            _idaccInvoicetoreceive; //parlando con Emilia andiamo a cambiare anche questo per coerenza
                    //idaccIvaDovutaAProrata = _idaccInvoicetoreceive;  //NON DEVE cambiare idaccUnabatableToUseProrata

                }

                if (isFattRic && registroVendita && !isFattRateo) {
                    if (!silent) {
                        ShowMessage(
                            "Per il dettaglio " + rInvDet["detaildescription"] +
                            " sarà considerato il conto 'fatture da emettere'", "Avviso", false);
                    }

                    //Per le fatt. da emettere imposta il conto apposito al posto di quello di ricavo
                    idaccCostoORicavo = _idaccInvoicetoemit;
                }


                //Mette insieme le cose associate agli stessi conti

                // valore_costo = da usare unitamente al conto di costo (o fattura a ricevere nel caso)
                //   è pari all'imponibile + iva indetraibile ove il conto dell'iva indetraibile non sia configurato
                //   attenzione che è possibile che parte del costo sia movimentata sotto un altro conto (quello principale) qualora 
                //  si tratti di una fattura a ricevere  che presenti una differenza di prorata rispetto alla generazione dell'impegno
                decimal valoreCosto = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(imponibile));

                // Nella bolletta doganale,
                // se il dettaglio è di tipo valoreDoganale, tiene i conti dell'iva indetraibile e imponibile separati
                // altrimenti vede se può accorparli
                if (!valoreDoganale) {
                    //Se non c'è un conto specifico per l'iva indetraibile, ne accorpa il valore al costo
                    //  questo escludendo però una eventuale parte di iva indetraibile dovuta a differenza del prorata

                    //accorpa ove possibile l'iva dovuta a prorata con l'impegno principale
                    if (idaccIvaDovutaAProrata == DBNull.Value || idaccIvaDovutaAProrata.Equals(idaccCostoORicavo)) {
                        //punto critico perchè stiamo facendo sparire l'iva indetraibile unendola al costo-->
                        //    il concetto è che la parte NOprorata va lasciata identica, mentre la parte PRORATA va suddivisa come:
                        //     la parte "da IMPEGNO" su dove andava prima più una parte "DIFFERENZA" su una nuova scrittura
                        valoreCosto += ivaIndetraibileDovutaAProrataPerDettaglio;
                        ivaIndetraibileDovutaAProrataPerDettaglio = 0;
                        idaccIvaDovutaAProrata = DBNull.Value;
                    }

                    //Accorpa ove possibile anche l'iva indetraibile non dovuta a prorata
                    if (idaccIvaNonDovutaAProrata == DBNull.Value ||
                        idaccIvaNonDovutaAProrata.Equals(idaccCostoORicavo)) {
                        valoreCosto += ivaIndetraibileNoProrata;
                        ivaIndetraibileNoProrata = 0;
                        idaccIvaNonDovutaAProrata = DBNull.Value;
                    }

                    if (ivaIndetraibileNoProrata > 0 &&
                        idaccIvaNonDovutaAProrata.Equals(idaccIvaDovutaAProrata)) {
                        ivaIndetraibileDovutaAProrataPerDettaglio += ivaIndetraibileNoProrata;
                        ivaIndetraibileNoProrata = 0;
                        idaccIvaNonDovutaAProrata = DBNull.Value;
                    }
                }

                if (contoSconto == DBNull.Value) {
                    //Non essendo definito un conto per lo sconto, deve detrarre lo sconto dal costo!
                    valoreCosto -= sconto;
                    imponibile -= sconto;
                    sconto = 0;
                }

                object invoicekind = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("invoicekind",
                    QHS.CmpEq("idinvkind", curr["idinvkind"]), "description"));

                //Se non è configurato il conto dell'iva, usciamo
                if (contoIvaCreditoODebito == DBNull.Value && ivaDetraibilePerDettaglio > 0 &&
                    !splitPaymentVendita) {
                    string tipo = deferred ? "differita" : "immediata";
                    string msg = "Non è stato trovato il conto per l'iva " + tipo + " per il tipo documento " +
                                 invoicekind + ".";
                    if (notaSuConto != "")
                        msg += " Nota: " + notaSuConto;
                    ShowMessage(msg, "Errore nella configurazione");
                    //valoreCosto = valoreCosto + valoreIvaDetraibile;
                    //valoreIvaDetraibile = 0;
                    return false; //22/6/17 con Emilia stabiliamo di  uscire
                }

                if (contoIvaCreditoODebito == DBNull.Value && isIntraCom && istituzionale &&
                    ivaIndetraibilePerDettaglio > 0 &&
                    !splitPaymentVendita) {
                    ShowMessage("Non è stato trovato il conto per l'iva  per il tipo documento " + invoicekind,
                        "Avviso", false);
                    ivaIndetraibilePerDettaglio = 0;
                    ivaIndetraibileDovutaAProrataPerDettaglio = 0;
                    ivaIndetraibileNoProrata = 0;
                }

                //if (invkind_idacc_iva == DBNull.Value){
                //    //Se non c'è un conto iva configurato, considera l'iva come parte del costo.
                //    valore_costo=valore_costo+valore_iva;
                //    valore_iva=0;
                //}

                object idaccmotiveMainDebit = idaccmotiveDebit;
                if (idaccmotiveMainDebit == DBNull.Value) {
                    idaccmotiveMainDebit = idaccmotive;
                }


                //decimal importocosto= CfgFn.GetNoNullDecimal(valore_costo);

                //				if (!vendita) {
                //					importocosto= -importocosto; //vendita è il segno NORMALE
                //					sconto= -sconto;
                //					valore_iva=-valore_iva;
                //				}
                object idupbCosto = rInvDet["idupb"];
                object idupbIva = rInvDet["idupb_iva"];
                if (idupbIva == DBNull.Value)
                    idupbIva = idupbCosto;



                if (rMandateDetail != null &&
                    (CfgFn.GetNoNullInt32(rInvDet["yman"]) >= minimoAnnoImpegniDiBudget || isFattRic)) {
                    //Se collegato a c.passivo si collega al costo
                    //idaccUnabatableToUseProrata = DBNull.Value;  
                    //valoreCosto += ivaIndetraibileDovutaAProrata;     //quella per prorata va su conto di costo "originale"
                    //ivaIndetraibileDovutaAProrata = 0;        
                    idaccIvaNonDovutaAProrata =
                        DBNull.Value; //l'iva indetraibile per mot. oggettivi va su fatt. a ricevere
                    valoreCosto += ivaIndetraibileNoProrata;
                    ivaIndetraibileNoProrata = 0;
                    idaccIvaDovutaAProrata = DBNull.Value;
                    valoreCosto += ivaIndetraibileDovutaAProrataPerDettaglio;
                    //zona critica: deve farlo solo per la quota relativa al c.passivo mentre la parte a differenza va trattata a parte
                    //QUesta gesione ora deve prevedere che anche l'iva indetraibile dovuta a prorata debba essere addossata
                    // all'impegno di budget dell'ordine, nella misura della iva indetraibile calcolata col prorata dell'anno del dettaglio
                    //  il resto invece rimane fuori
                    //if (diffProrata > 0) {
                    //    valoreCosto += ivaIndetraibileDovutaAProrataFattRic;
                    //    ivaIndetraibileDovutaAProrataPerDettaglio = 0;
                    //}
                }

                //scrittura sul costo iva indetraibile (solo per gli acquisti ove conto configurato)
                //Per le spese anticipate non c'è iva, è tutto imponibile
                if (idaccIvaDovutaAProrata != DBNull.Value && ivaIndetraibileDovutaAProrataPerDettaglio > 0) {


                    object idepexpProrata = idepexp;
                    if ((isFattRic == false) || istituzionale) {
                        //Se c'è un contratto passivo l'impegno è sempre e solo tutto sul costo principale, non c'è nessuna possibilità di avere un conto
                        //  di iva indetraibile distinto                        
                        idepexpProrata =
                            (rInvDet["idmankind"] != DBNull.Value &&
                             CfgFn.GetNoNullInt32(rInvDet["yman"]) >= minimoAnnoImpegniDiBudget)
                                ? rInvDet["idepexp"]
                                : getIdEpExpByIdRelated(idrelatedProrata, 2);
                    }
                    else {
                        //se è fattura a ricevere dobbiamo distinguere qualcosa? oppure rientra nel precedente?
                    }
                    //if (idepexpProrata == DBNull.Value && esercizio > 2015 && UsaImpegniDiBudget) {
                    //    MetaFactory.factory.getSingleton<IMessageShower>().Show("Non è stato generato l'impegno di budget per l'iva dovuta a prorata nel dettaglio "
                    //                    + rInvDet["detaildescription"]);
                    //    return false;
                    //}

                    //Non considera l'impegno di budget per le spese anticipate

                    // Se si tratta di una NC, e non è contabilizzata con una var. di spesa, dobbiamo associare il dettaglio scrittura all' imp.di Budget della fattura madre                
                    if ((rInvDet["idinvkind_main"] != DBNull.Value) && (rInvDet["idexp_taxable"]==DBNull.Value) && (rInvDet["idexp_iva"] == DBNull.Value)) {
                        idepexpProrata = idepexp_main; // Cambio valorizzazione idepexp
                    }

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        ivaIndetraibileDovutaAProrataPerDettaglio,
                        idaccIvaDovutaAProrata,
                        idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                        rInvDet, idaccmotive, rInvDet["idcostpartition"],
                        speseAnticipate ? DBNull.Value : idepexpProrata, idepacc, idrelated,
                        rInvDet["detaildescription"]);


                }


                //Per le spese anticipate non c'è iva, è tutto imponibile
                if (idaccIvaNonDovutaAProrata != DBNull.Value && ivaIndetraibileNoProrata > 0) {
                    object idepexpNoProrata = idepexp;
                    object idepAccNoProrata = idepacc;
                    if ((isFattRic == false) || istituzionale) {
                        // era cicloAttivo()?..
                        if (collegaImpegno) idepexpNoProrata = getIdEpExpByIdRelated(idrelatedNoProrata, 2);
                        if (collegaAccertamento) idepAccNoProrata = getIdEpAccByIdRelated(idrelatedNoProrata, 2);
                    }

                    //if (idepexpNoProrata == DBNull.Value && esercizio > 2015 && UsaImpegniDiBudget) {
                    //    MetaFactory.factory.getSingleton<IMessageShower>().Show("Non è stato generato l'impegno di budget per l'iva non dovuta a prorata nel dettaglio "
                    //                    + rInvDet["detaildescription"]);
                    //    return false;
                    //}
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        ivaIndetraibileNoProrata,
                        idaccIvaNonDovutaAProrata,
                        idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                        rInvDet, idaccmotive, rInvDet["idcostpartition"],
                        idepexpNoProrata, //    10594  era valoreDoganale ? DBNull.Value:idepexpNoProrata
                        idepacc, idrelated,
                        rInvDet["detaildescription"]);
                }

                object idepexpForDebit = idepexp;
                // Se si tratta di una NC, e NON è contabilizzata con una var. di spesa, dobbiamo associare il dettaglio scrittura all' imp.di Budget della fattura madre                
                if ((rInvDet["idinvkind_main"] != DBNull.Value) && (rInvDet["idexp_taxable"] == DBNull.Value) && (rInvDet["idexp_iva"] == DBNull.Value)) {
                    idepexpForDebit = idepexp_main; // Cambio valorizzazione idepexp
                }
				//scrittura su costo/ricavo (eventualmente include iva indetraibile)

                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                    valoreCosto,
                    idaccCostoORicavo,
                    idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                    rInvDet, idaccmotive, rInvDet["idcostpartition"],
                    speseAnticipate || valoreDoganale ? DBNull.Value : idepexp,
                    idepacc, isFattRic ? idrelatedLinkedDoc : idrelated, 
                    rInvDet["detaildescription"]);

                if (speseAnticipate || valoreDoganale) {
                    //sdoppia scrittura per spese anticipate o valore doganale, sempre senza imp. di budget
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        -valoreCosto,
                        idaccCostoORicavo,
                        idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                        rInvDet, idaccmotive, rInvDet["idcostpartition"], DBNull.Value, DBNull.Value, idrelated,
                        rInvDet["detaildescription"]);
                }



                //scrittura su sconto
                if (valoreCosto != 0 && sconto != 0) {
                    //Effettua la scrittura sullo sconto
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        sconto,
                        contoSconto,
                        idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                        rInvDet, idaccmotive, rInvDet["idcostpartition"], idepexp, idepacc, idrelated,
                        rInvDet["detaildescription"]);
                }

                //scrittura su iva detraibile, non c'è impegno di budget qui (per le vendite è tutta l'iva)
                //da questa iva è stata già scorporata la differenza prorata
                if (ivaDetraibilePerDettaglio != 0 && !splitPaymentVendita) {
                    //Effettua la scrittura sull'iva detraibile, senza impegno di budget
                    EP.EffettuaScritturaImpegnoBudget(idepcontext,
                        ivaDetraibilePerDettaglio,
                        contoIvaCreditoODebito,
                        idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                        rInvDet, idaccmotive, null, null, idrelated,
                        nomeDebitoCredito //"iva detraibile"
                    );
                }

                //Importo da usare per il conto fornitore/cliente
                decimal importoDebito;

                //Importo da movimentare sul conto iva detraibile
                // questo non dovrebbe essere inficiata dalla nuova gestione prorata, è usata solo nell'istituzionale
                decimal ImportoIvaComplessivaDaConsiderare = 0;

                if (splitPaymentVendita) {
                    importoDebito = CfgFn.GetNoNullDecimal(imponibile) - sconto;
                }
                else {
                    if ((isIntraCom & registroAcquisto) || applicaSplitPaymentCommerciale || isFlagReverseCharge) {
                        importoDebito = CfgFn.GetNoNullDecimal(imponibile) - sconto;
                        ImportoIvaComplessivaDaConsiderare = valoreIvaTotale;
                    }
                    else {
                        importoDebito = CfgFn.GetNoNullDecimal(imponibile) - sconto + valoreIvaTotale;
                        ImportoIvaComplessivaDaConsiderare = 0;
                    }
                }

                if (contoIvaCreditoDebitoIntra == DBNull.Value && ImportoIvaComplessivaDaConsiderare != 0 &&
                    (!istituzionale) && (!registroVendita) &&
                    (isIntraCom || isFlagReverseCharge)) {
                    string tipo = deferred ? "differita" : "immediata";
                    ShowMessage("Non è stato trovato il conto per l'iva intracomunitaria " + tipo +
                                " per il tipo documento " +
                                invoicekind, "Avviso", false);
                    //importo_debito += importo_ivaopposta;
                    ImportoIvaComplessivaDaConsiderare = 0;
                }

                if (contoIvaCreditoDebitoSplit == DBNull.Value && ImportoIvaComplessivaDaConsiderare != 0 &&
                    applicaSplitPaymentCommerciale) {
                    string tipo = deferred ? "differita" : "immediata";
                    ShowMessage("Non è stato trovato il conto per l'iva split payment " + tipo +
                                " per il tipo documento " +
                                curr["idinvkind"], "Avviso", false);
                    //importo_debito += importo_ivaopposta;
                    ImportoIvaComplessivaDaConsiderare = 0;
                }

                object idepaccForCredit = idepacc;

                if (rInvDet["idinvkind_main"] != DBNull.Value) {
                    idepaccForCredit = idepacc_main; // Cambio valorizzazione idepacc_main
                }

                object idepexpProrataDiff =
                    diffProrata > 0 ? getIdEpExpByIdRelated(idrelatedDiffProrata, 2) : DBNull.Value;
                object idepaccProrataDiff =
                    diffProrata < 0 ? getIdEpAccByIdRelated(idrelatedDiffProrata, 2) : DBNull.Value;

                //if (registroVendita) {
                //    if (collegaAccertamento) idepexpForDebit = DBNull.Value;
                //}
                //else {
                //    if (collegaImpegno) idepaccForCredit = DBNull.Value;
                //}

                //parte nuova sulla differenza dovuta a cambio prorata
                if (diffProrata > 0) {
                    EP.EffettuaScritturaImpegnoBudget(idepcontext,
                        diffProrata,
                        idaccCostoRicavoDiffProrata,
                        idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                        //rInvDet, idaccmotiveMainDebit,  idepexpForDebit, idepaccForCredit, idrelated,
                        rInvDet, idaccmotiveDiffProrata, idepexpProrataDiff, DBNull.Value, idrelated,
                        "iva indetraibile (differenza dovuta ad aumento prorata)"
                    );
                }

                if (diffProrata < 0) {
                    EP.EffettuaScritturaImpegnoBudget(idepcontext,
                        diffProrata,
                        idaccCostoRicavoDiffProrata,
                        idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                        //rInvDet, idaccmotiveMainDebit,  idepexpForDebit, idepaccForCredit, idrelated,
                        rInvDet, idaccmotiveDiffProrata, null, idepaccProrataDiff, idrelated,
                        " iva detraibile dovuta a diminuzione prorata");
                }
                
                //scrittura sul conto di debito/credito vs fornitore        
                // splittare se c'è idupb_iva
                if (importoDebito != 0) {
                    //E' stato specificato un conto per l'iva e non è intracom o split comm. o rev.charge
                    if ((idupbIva != DBNull.Value) &&
                        !(/*isIntraCom */(isIntraCom & registroAcquisto) || applicaSplitPaymentCommerciale || isFlagReverseCharge)) { // Rimossa valutazione di isIntraCom per le vendite (task 16062) 
                        EP.EffettuaScritturaImpegnoBudget(idepcontext,
                            imponibile - sconto,
                            contoDebitoCreditovsFornitore,
                            idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                            //rInvDet, idaccmotiveMainDebit, speseAnticipate|| valoreDoganale ?null:idepexpForDebit, idepaccForCredit,
                            rInvDet, idaccmotive, speseAnticipate || valoreDoganale ? null : idepexpForDebit,
                            idepaccForCredit,
                            idrelated,
                            nomeDebitoCredito //"imponibile netto"
                        );
                        if (valoreDoganale || speseAnticipate) {
                            //seconda scrittura in segno opposto su valore doganale o spese anticipate, per il solo costo (a prescindere da iva )
                            EP.EffettuaScritturaImpegnoBudget(
                                idepcontext,
                                -(imponibile - sconto), //uso lo stesso segno, presumo che il contesto farà il resto
                                speseAnticipate ? idaccRegistryBolla : contoDebitoCreditovsFornitore,
                                idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                                // rInvDet, idaccmotiveMainDebit, speseAnticipate? idepexpForDebit:null, null, idrelated, "Debito verso dogana per costo");
                                rInvDet, idaccmotive, speseAnticipate ? idepexpForDebit : null, null, idrelated,
                                nomeDebitoCredito //"Debito verso dogana per costo"
                            );
                        }
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        //Per spese anticipate non c'è iva quindi qui non farà nulla
                        //sull'iva detraibile NON c'è impegno di budget
                        //Scrittura su iva DETRAIBILE ED INDETRAIBILE
                        if (!splitPaymentVendita) {
                            //iva detraibile senza impegno/acc di budget
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                ivaDetraibilePerDettaglio + (diffProrata > 0 ? diffProrata : 0), 
                                contoDebitoCreditovsFornitore,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                //rInvDet, idaccmotiveMainDebit, null, null, idrelated,"iva detraibile");
                                rInvDet, idaccmotive, null, null, idrelated,
                                nomeDebitoCredito //"iva detraibile"
                            );

                            //iva indetraibile CON impegno di budget
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                ivaIndetraibilePerDettaglio + (diffProrata < 0 ? diffProrata : 0),      
                                contoDebitoCreditovsFornitore,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                //rInvDet, idaccmotiveMainDebit,  idepexpForDebit, idepaccForCredit, idrelated,
                                rInvDet, idaccmotive, idepexpForDebit, idepaccForCredit, idrelated,
                                nomeDebitoCredito //"iva indetraibile"
                            );
                            //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        }
                    }
                    else {
                        //NON E' stato specificato un conto per l'iva o è intracom o split comm. o rev.charge, tutto va sul conto di costo[*]
                        //Non è sicuro che sia corretto, forse aveva senso prima quando si distingueva la scrittura solo per upb
                        //Questa sezione dovrà prevedere la scrittura di due debiti uno per impegno di budget del dettaglio "conforme" al c.passivo + il nuovo
                          EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                importoDebito,
                                contoDebitoCreditovsFornitore,
                                idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                                //rInvDet, idaccmotiveMainDebit, speseAnticipate || valoreDoganale ? null: idepexpForDebit , idepaccForCredit, idrelated);
                                rInvDet, idaccmotive, speseAnticipate || valoreDoganale ? null : idepexpForDebit,
                                idepaccForCredit, idrelated
                                , nomeDebitoCredito
                            );
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        if (valoreDoganale || speseAnticipate) {
                            //seconda scrittura in segno opposto su valore doganale o spese anticipate, per il solo costo (a prescindere da iva )
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                -importoDebito, //uso lo stesso segno, presumo che il contesto farà il resto
                                speseAnticipate ? idaccRegistryBolla : contoDebitoCreditovsFornitore,
                                idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                                //rInvDet, idaccmotiveMainDebit, valoreDoganale? null : idepexpForDebit, null, idrelated, "Debito verso dogana per costo");
                                rInvDet, idaccmotive, valoreDoganale ? null : idepexpForDebit, null, idrelated,
                                nomeDebitoCredito //"Debito verso dogana per costo"
                            );
                        }
                        //chiusura debito per iva indetraibile valore doganale
                        if (valoreDoganale) {
                            //per le spese anticipate fa anche la scrittura di segno opposto, sempre senza imp. di budget - è la parte costo
                            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                                -ivaIndetraibileDovutaAProrataPerDettaglio,                             
                                contoDebitoCreditovsFornitore,
                                idreg, idupbCosto, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, rInvDet["idcostpartition"], DBNull.Value, DBNull.Value, idrelated,
                                nomeDebitoCredito //"Debito verso dogana per iva indetraibile"
                            );
                        }
                     
                    } // chiude il primo if

                }// chiude if (importoDebito != 0) 



                //scrittura su conto iva opposto per l'intracomunitario
                //scrittura sul conto di debito/credito vs fornitore              
                if (ImportoIvaComplessivaDaConsiderare != 0) {
                    if (istituzionale) {
                        if (RecuperoIVAEstera) {
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                ImportoIvaComplessivaDaConsiderare,
                                contoDebitoCreditovsFornitore,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                valoreDoganale ? "iva istituzionale" : nomeDebitoCredito
                            );

                        }
                        else {
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                ImportoIvaComplessivaDaConsiderare,
                                //E' voluto il fatto che non sia invkindIdaccIvaIntracom: questa non è veramente iva opposta
                                valoreDoganale ? idaccCostoORicavo : contoIvaCreditoODebito,
                                idregIva, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                valoreDoganale ? "iva istituzionale" : nomeDebitoCredito
                            );
                            //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        }
                    }
                    else {
                        if (applicaSplitPaymentCommerciale) {
                            //(1)
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                -ivaIndetraibilePerDettaglio,
                                contoIvaCreditoDebitoSplit,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, idepexpForDebit, idepacc, idrelated,
                                nomeDebitoCredito //"Iva indetraibile split"
                            );

                            if (diffProrata > 0) {
                                EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                    -diffProrata,
                                    contoIvaCreditoDebitoSplit,
                                    idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                    rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                    nomeDebitoCredito //"Iva indetraibile split (differenza dovuta a prorata)"
                                );
                            }

                            if (diffProrata < 0) {
                                //??? forse in questo caso dovrebbe fare già la scrittura netta sull'iva split + diffProrata nella (1)
                                //
                                EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                    -diffProrata,
                                    contoIvaCreditoDebitoSplit,
                                    idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                    rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                    nomeDebitoCredito //"Iva indetraibile split (differenza dovuta a prorata)"
                                );
                            }

                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                -ivaDetraibilePerDettaglio,
                                contoIvaCreditoDebitoSplit,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, null, null, idrelated,
                                nomeDebitoCredito //"Iva detraibile split"
                            );
                        }
                        else {
                            //passa da qui per intracom e reverse_charge
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                -ivaIndetraibilePerDettaglio,
                                contoIvaCreditoDebitoIntra,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                nomeDebitoCredito //"Iva indetraibile intracom"
                            );

                            if (diffProrata > 0) {
                                EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                    -diffProrata,
                                    contoIvaCreditoDebitoIntra,
                                    idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                    rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                    nomeDebitoCredito //"Iva indetraibile split (differenza dovuta a prorata)"
                                );
                            }

                            if (diffProrata < 0) {
                                //??? forse in questo caso dovrebbe fare già la scrittura netta sull'iva split + diffProrata nella (1)
                                //
                                EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                    -diffProrata,
                                    contoIvaCreditoDebitoIntra,
                                    idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                    rInvDet, idaccmotive, idepexp, idepacc, idrelated,
                                    nomeDebitoCredito //"Iva indetraibile split (differenza dovuta a prorata)"
                                );
                            }

                            //e qui? stessa cosa di sopra (1)?
                            EP.EffettuaScritturaImpegnoBudget(idepcontext,
                                -ivaDetraibilePerDettaglio,
                                contoIvaCreditoDebitoIntra,
                                idreg, idupbIva, rInvDet["competencystart"], rInvDet["competencystop"],
                                rInvDet, idaccmotive, null, null, idrelated,
                                nomeDebitoCredito //"Iva detraibile intracom"
                            );
                        }
                    }
                }



                if (EP.saldo != 0) {
                    ShowMessage("Si è verificata una squadratura sul dettaglio " + rInvDet["detaildescription"]);
                }

            }



            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        private Dictionary<string,object> RintracciaLiquidazioneIVA(object idexp_pagamento) {
            //A partire dall'idexp del pagamento, risale alla fase del creditore, e prende la riga di "ivapayexpense" perchè gli serve yivapay e nivapay
            object flagivaregphase = Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", Conn.GetSys("esercizio")),"flagivaregphase");
            if (flagivaregphase.ToString() == "N") return null;
            //Ha ganerato i mov. fin. fino alla fase del creditore, quindi dobbiamo prende l'impegno associato all'idexp_pagamento, e tramite quello, recupare la Lx iva.
            object expensephase = _rConfig["expensephase"];
            object idExpFaseImpegno = Conn.DO_READ_VALUE("expenselink",
                QHS.AppAnd(QHS.CmpEq("idchild", idexp_pagamento), QHS.CmpEq("nlevel", expensephase)), "idparent");
            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", idExpFaseImpegno), "yivapay,nivapay");
            return rIvaExpense;
        }
        /// <summary>
        /// Metodo che genera le scritture in P.D.
        /// </summary>
        private bool generaScrittureElencoTrasmPagamento(DataRow curr, BudgetFunction bf) {
            // Attenzione bisogna distinguere i seguenti casi!
            // 1. Inserimento di una distinta di trasmissione (con dettagli)
            // 2. Inserimento successivo di dettagli
            // 3. Rimozione successiva di dettagli
            string descrFaseSpesa = "";
            object faseObjS = Conn.DO_READ_VALUE("expensephase", QHS.CmpEq("nphase", Conn.GetSys("maxexpensephase")),
                "description");
            if (faseObjS != null) descrFaseSpesa = faseObjS.ToString();

            if (curr["noep"].ToString() == "S") return false;
            if (curr["transmissiondate"] == DBNull.Value) return false;

            bool liqDiretta = false;
            int flag =
                CfgFn.GetNoNullInt32(_rConfig["automanagekind"]);
            if ((flag & 0x08) != 0) liqDiretta = true;


            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            //Il conto banca è quello di presentazione documenti alla banca oppure se non configurato è quello di pagamento alla banca
            object idaccPayment = _rConfig["idacc_bankpaydoc"];

            if (idaccPayment == DBNull.Value) {
                idaccPayment = getAccountTreasurer(curr["idtreasurer"], "D");
                if (idaccPayment == DBNull.Value) {
                    return false;
                }
            }



            object doc = "Dist. Trasm. Mandati " + curr["ypaymenttransmission"] + "/" + curr["npaymenttransmission"];
            DateTime dataRiferimento = (DateTime) curr["transmissiondate"];
            DataRow mainEntry = EP.SetUniqueEntry(doc, dataRiferimento, doc, curr["transmissiondate"],
                EP_functions.GetIdForDocument(curr));
            DataTable tTreasurer = Conn.RUN_SELECT("treasurer", "*", null,
                QHS.CmpEq("idtreasurer", curr["idtreasurer"]), null, true);
            if (tTreasurer == null || tTreasurer.Rows.Count == 0) {
                ShowMessage("Il tesoriere non è stato selezionato", "Errore");
                return false;
            }

            DataRow rTreasuer = tTreasurer.Rows[0];
            CopySecurity(rTreasuer, mainEntry);
            EP.ClearDetails(mainEntry);

            //DataTable TaxSetup = meta.Conn.RUN_SELECT("tax","*",null,null,null,true);
            string filterEsercizio = QHS.CmpEq("ayear", esercizio);
            DataTable pSpeseSetup = Conn.RUN_SELECT("pettycashsetup", "*", null, filterEsercizio, null, true);

            object idclawbackSplitPayment = Conn.DO_READ_VALUE("clawback",
                QHS.CmpEq("clawbackref", "16_SPLIT_PAYMENT_C"), "idclawback");

            //DA FARE : Deve leggere se trattasi di iva estera commerciale o istituzionale
            object idclawbackIvaEstera = Conn.DO_READ_VALUE("clawback",
                QHS.CmpEq("clawbackref", "IVAESTERA_COMM"), "idclawback");

            //Conto per i debiti/crediti vs fornitori
            //string idAccFornitore = EP.GetAccountForSupplier();
            object idAccIvaPayment = EP.GetAccountForIvaPayment();
            object idAccIvaPayment12 = EP.GetAccountForIvaPayment12();
            object idAccIvaPaymentSplit = EP.GetAccountForIvaPaymentSplit();

            object idAccIvaPaymentInternal = EP.GetAccountForMainIvaPaymentInternal();
            object idAccIvaPaymentExternal = EP.GetAccountForMainIvaPayment();

            string filtroMandati = QHC.IsNotNull("kpaymenttransmission");
            string filtroVariazioni = QHC.IsNotNull("kpaymenttransmission");
            DataTable tPayments;
            if (DS.Tables.Contains("payment")) {
                tPayments = DS.Tables["payment"];
            }
            else {
                if (DS.Tables.Contains("paymentview")) {
                    tPayments = DS.Tables["paymentview"];
                }
                else {
                    tPayments = Conn.RUN_SELECT("payment", "*", null, QHS.CmpKey(curr), null, false);
                }
            }

            DataTable tVar = null;
            if (DS.Tables.Contains("expensevarview")) {
                tVar = DS.Tables["expensevarview"];
            }
            else {
                tVar = Conn.RUN_SELECT("expensevarview", "*", null, QHS.CmpKey(curr), null, false);
            }


            DataTable tClawBackSetup = Conn.RUN_SELECT("clawbacksetup", "idclawback, idaccmotive",
                null, filterEsercizio, null, null, true);

            string filterRecuperoSplitPayment = QHC.CmpEq("idclawback", idclawbackSplitPayment);
            object idaccRecuperoSplitPayment = DBNull.Value;
            string filterRecuperoIvaEstera = QHC.CmpEq("idclawback", idclawbackIvaEstera);
            object idaccRecuperoIvaEstera = DBNull.Value;

            DataRow[] clawBackSetup = tClawBackSetup.Select(filterRecuperoSplitPayment);
            if (clawBackSetup.Length > 0) {
                DataRow rClawBackSetup = clawBackSetup[0];
                object idaccmotiveRecuperoSplitPayment = rClawBackSetup["idaccmotive"];

                DataRow[] rContoRecupero = EP.GetAccMotiveDetails(idaccmotiveRecuperoSplitPayment);
                if (rContoRecupero.Length > 0) {
                    idaccRecuperoSplitPayment = rContoRecupero[0]["idacc"];
                }
            }

            DataRow[] clawBackSetup_ivaestera = tClawBackSetup.Select(filterRecuperoIvaEstera);
            if (clawBackSetup_ivaestera.Length > 0) {
                DataRow rClawBackSetup_ivaestera = clawBackSetup_ivaestera[0];
                object idaccmotiveRecuperoIvaestera = rClawBackSetup_ivaestera["idaccmotive"];

                DataRow[] rContoRecupero_ivaestera = EP.GetAccMotiveDetails(idaccmotiveRecuperoIvaestera);
                if (rContoRecupero_ivaestera.Length > 0) {
                    idaccRecuperoIvaEstera = rContoRecupero_ivaestera[0]["idacc"];
                }
            }

            DataRow[] rMandati = tPayments.Select(filtroMandati);
            //string elencoMandati = QueryCreator.ColumnValues(rMandati, "npay",true);
            DataRow[] rVariazioni = tVar.Select(filtroVariazioni);

            object idregauto = _rConfig["idregauto"];
            List<int> listaMovSpesa = new List<int>();

            TaxEntryHelper tHelp = new TaxEntryHelper(Conn);
            // Se ci sono mandati allora ha senso inserire(modificare) i dettagli scrittura 
            // altrimenti i dettagli resteranno impostati a zero e, quindi, verranno cancellati
            if (rMandati.Length > 0) {
                string filtermand = QHS.AppAnd(filterEsercizio,
                    QHS.CmpEq("ypay", esercizio),
                    QHS.FieldIn("npay", rMandati));
                DataTable tSpesa = Conn.RUN_SELECT("expenseview",
                    "idexp,ymov, nmov, ypay, npay,amount,idreg,idupb,autokind,autocode,idclawback,idaccdebit,idpayment,description,doc,finflag,idfin",
                    null, filtermand, null, true);



                foreach (DataRow rLiquidazione in tSpesa.Rows) {
                    string idrelated = "expense§" + rLiquidazione["idexp"];
                    listaMovSpesa.Add(CfgFn.GetNoNullInt32(rLiquidazione["idexp"]));
                    // Scritture sul movimento di spesa
                    object idAccFornitore = rLiquidazione["idaccdebit"];
                    if (idAccFornitore == DBNull.Value) {
                        idAccFornitore = EP.GetSupplierAccountForRegistry(null, rLiquidazione["idreg"]);
                    }

                    string idrelDebit = "expense§" + rLiquidazione["idexp"]; //+ "§debit" 15040 rimuovo

                    //L'importo serve sempre, lo mettiamo già nella variabile!
                    decimal importo = CfgFn.GetNoNullDecimal(rLiquidazione["amount"]);
                    decimal variazioni = CfgFn.GetNoNullDecimal(Conn.DO_READ_VALUE("expensevar",
                        QHS.AppAnd(QHS.CmpEq("yvar", Conn.GetEsercizio()), QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                            QHS.CmpLe("adate", dataRiferimento), QHS.IsNull("kpaymenttransmission")),
                        "sum(amount)", null));
                    importo += variazioni;

                    //Dobbiamo distinguere i principali casi:
                    // Mandati normali, eventualmente con ritenute
                    // Mandati x LIQUIDAZIONE RITENUTE (autokind= LIQRT)
                    // (A BREVE): Mandati x LIQUIDAZIONE IVA imm/differita(autokind=LPIva che deve diventare LIIVA/LDIVA!)                    
                    byte autokind = CfgFn.GetNoNullByte(rLiquidazione["autokind"]);
                    int autocode = CfgFn.GetNoNullInt32(rLiquidazione["autocode"]);
                    string descrdet = descrFaseSpesa + " n° " + rLiquidazione["nmov"].ToString() + "/" +
                                      rLiquidazione["ymov"].ToString() +
                                      " Mand. " + " n° " + rLiquidazione["npay"].ToString() + "/" +
                                      rLiquidazione["ypay"].ToString();
                    switch (autokind) {
                        case 3: //Reintegro fondo economale
                        case 1: //Apertura fondo economale
                            //Reintegro Fondo Piccole Spese
                            object codicefps = rLiquidazione["autocode"];
                            DataRow fpsRow = null;
                            if (codicefps == DBNull.Value) {
                                DataRow[] fpsRows = pSpeseSetup.Select();
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }
                            else {
                                DataRow[] fpsRows = pSpeseSetup.Select(QHC.CmpEq("idpettycash", codicefps));
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }

                            object idaccmotiveFps = DBNull.Value;
                            decimal importofornitore = importo;
                            if ((fpsRow != null) && (fpsRow["idacc"] != DBNull.Value)) {
                                idAccFornitore = fpsRow["idacc"];
                                importofornitore = -importo;
                            }

                            // A questo punto genera la scrittura da debiti  a banca							
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveFps, idrelated, descrdet);

                            //14947 mettere idrelated simile a foeco§codice fondo invece di idrelDebit, analogamente nelle distinte incasso
                            EP.EffettuaScritturaIdRelated("PAGAM", importofornitore, idAccFornitore,
                                rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveFps, "foeco§" + autocode, descrdet);

                            break;
                        case 2: //Liquidazione ritenute
                            //Liquidazione ritenute: effettua una scrittura dal conto di pagamento delle ritenute
                            // al conto della BANCA
                            if (usaContiPresentazioneDocumenti) break;
                            object codiceriten = rLiquidazione["autocode"];
                            int taxcode = CfgFn.GetNoNullInt32(codiceriten);
                            TaxInfo tax = TaxInfo.getInfo(taxInfo, taxcode);
                            if (tax == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + codiceriten + " non è il codice di una ritenuta esistente",
                                    "Errore");
                                return false;
                            }

                            DataRow motiveRow = tax.getInfo(CfgFn.GetNoNullInt32(0));
                            if (motiveRow == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + tax.taxRef() +
                                    " non è il codice di una ritenuta configurata per l'EP.", "Errore");
                                return false;
                            }

                            //Prende la causale di pagamento associato alla liqudazione (pay) della ritenuta 
                            object idaccmotiveRiten = motiveRow["idaccmotive_pay"];
                            if (idaccmotiveRiten == DBNull.Value) {
                                ShowMessage("La ritenuta di codice " + tax.taxRef() +
                                            " non è stata configurata per l'E/P");
                                return false;
                            }

                            //Per ogni conto associato alla causale genera una scrittura 
                            DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveRiten);
                            if (rEntries.Length == 0) {
                                ShowMessage("La ritenuta di codice " + tax.taxRef() +
                                            " non ben configurata per l'E/P");
                                return false;
                            }

                            object idAccRiten = rEntries[0]["idacc"];


                            EP.EffettuaScritturaIdRelated("LIQRIT", importo, idAccRiten, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveRiten, idrelDebit, descrdet);
                            EP.EffettuaScritturaIdRelated("LIQRIT", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveRiten, idrelated, descrdet);
                            break;

                        case 15: { /*manca causale*/
                            //Liquidazione IVA Consolidata INTERNA,  ORMAI IN DISUSO 
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("PAGAM", importo, idAccIvaPaymentInternal, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 16: { /*manca causale*/
                            //Liquidazione IVA Consolidata ESTERNA, ORMAI IN DISUSO                                
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("PAGAM", importo, idAccIvaPaymentExternal, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 13: //ACCONTO IVA
                        case 12: { /*manca causale*/
                            //Liquidazione IVA
                            //if (usaContiPresentazioneDocumenti && esercizio <2017) break; //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");

                            if ((rIvaExpense == null)) {
                                    rIvaExpense = RintracciaLiquidazioneIVA(rLiquidazione["idexp"]);
                             }

                            string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 17: { /*manca causale*/
                            //Liquidazione IVA 12
                            //if (usaContiPresentazioneDocumenti && esercizio < 2017) break;  //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");
                                if ((rIvaExpense == null)) {
                                    rIvaExpense = RintracciaLiquidazioneIVA(rLiquidazione["idexp"]);
                                }
                                string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPayment12, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 23: { /*manca causale*/
                            //Liquidazione IVA Split
                            //if (usaContiPresentazioneDocumenti && esercizio <2017) break;  //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                                var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");
                                if ((rIvaExpense == null)){
                                    rIvaExpense=RintracciaLiquidazioneIVA(rLiquidazione["idexp"]);
                                }
                            string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPaymentSplit, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 4: {
                            //14910  mettere qualcosa tipo cascon§2019§16§RITEN§17 
                            //     in base al tipo contabilizzazione dell'impegno collegato e al codice ritenuta 

                            //Ritenute/Contributi
                            object myaccFornitore = idAccFornitore;
                            //Si tratta del mov. di spesa per i contributi!
                            //Effettua una scrittura	Debito conto erario	 a Banca o 
                            //							Debito (generico)    a banca
                            object codicerit = rLiquidazione["autocode"];
                            int taxcode2 = CfgFn.GetNoNullInt32(codicerit);
                            object idser = Conn.DO_READ_VALUE("expenselast",
                                QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "idser");
                            int idregPrincipale = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense",
                                QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "idreg")); //idreg movimento principale


                            string idrelatedDebitoContoErario =
                                idrelatedDebitFor(rLiquidazione["idpayment"], taxcode2); // cascon§2019§16§RITEN§17 

                            TaxInfo tax2 = TaxInfo.getInfo(taxInfo, taxcode2);
                            if (tax2 == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage($"Il codice {taxcode2} non è il codice di una ritenuta esistente",
                                    "Errore");
                                return false;
                            }

                            DataRow motiveRow2 = tax2.getInfo(CfgFn.GetNoNullInt32(idser));
                            if (motiveRow2 == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    $"Il codice {tax2.taxRef()} non è il codice di una ritenuta configurata per l'EP.",
                                    "Errore");
                                return false;
                            }


                            //Vede se c'è un conto intermedio
                            object idaccmotiveRitdeb = motiveRow2["idaccmotive_debit"];
                            object idaccmotivecost = motiveRow2["idaccmotive_cost"];
                            object idaccmotiveRitpay = motiveRow2["idaccmotive_pay"];

                            object idepexp = DBNull.Value;
                            //se c'è il conto "debito conto erario", lo usa come conto per la scrittura standard
                            if (idaccmotiveRitdeb != DBNull.Value) {
                                DataRow[] contiIntermedi = EP.GetAccMotiveDetails(idaccmotiveRitdeb);
                                if (contiIntermedi.Length > 0) {
                                    myaccFornitore = contiIntermedi[0]["idacc"];
                                }

                                var list = getIdImpegnoBudget(rLiquidazione["idpayment"], codicerit,
                                    rLiquidazione["idreg"], importo);
                                if (list.Count > 0) {
                                    idepexp = list[0].idepexp;
                                }
                            }

                            int idregAutomatismo = CfgFn.GetNoNullInt32(rLiquidazione["idreg"]);
                            if (idregPrincipale == idregAutomatismo) {
                                //task 14931  Ritenute negative su compensi diversi da CSA
                                DataRow[] contiPay = EP.GetAccMotiveDetails(idaccmotiveRitpay);
                                if (idaccmotiveRitpay != DBNull.Value && contiPay.Length == 0) {
                                    object nmov = Conn.DO_READ_VALUE("expense",
                                        QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "nmov");
                                    ShowMessage(
                                        $"La causale di liquidazione della ritenuta {tax2.taxRef()} non è ben configurata per l'E/P (n.movimento {nmov})");
                                    return false;
                                }

                                object idaccPay = contiPay[0]["idacc"];
                                //Ritenuta negativa
                                DataTable tRegs = tHelp.GetIdRegFor(codicerit, rLiquidazione["idexp"]);
                                foreach (DataRow ttr in tRegs.Rows) {
                                    decimal amountToConsider = importo * CfgFn.GetNoNullDecimal(ttr["quota"]);
                                    int idregToConsider = CfgFn.GetNoNullInt32(ttr["idreg"]);

                                    EP.EffettuaScritturaIdRelated("APPCONTRIB", amountToConsider,
                                        idaccPay, //DEBITO VERSO ERARIO in questo caso (task 14931)
                                        idregToConsider, //era: rLiquidazione["idreg"]
                                        rLiquidazione["idupb"], null, idaccmotiveRitpay,
                                        $"ritenuta§{rLiquidazione["idpayment"]}§{taxcode2}", //ritenuta§468614§19
                                        (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                                }
                            }
                            else {

                                //Contributo
                                EP.EffettuaScritturaImpegnoBudget("APPCONTRIB", importo, myaccFornitore,
                                    rLiquidazione["idreg"], rLiquidazione["idupb"],
                                    null, idaccmotivecost, idepexp, null, idrelatedDebitoContoErario,
                                    (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);


                            }

                            EP.EffettuaScritturaIdRelated("APPCONTRIB", importo, idaccPayment, //conto transitori BANCA
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotiveRitdeb,
                                idrelDebit, //idrelated, 
                                (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]
                            );


                            //Effettua la scrittura sul debito conto ente usando l'anagrafica DIPARTIMENTO
                            // ossia quella del movimento della p. di giro

                            //EP.EffettuaScrittura("APPCONTRIB", importo, myaccFornitore,
                            //    rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotive);

                                  
                            break;
                        }

                        case 30: { //Nuovi riepiloghi CSA
                            if (!generaScritturePagamentoRiepPartition(EP, rLiquidazione["idexp"],
                                rLiquidazione["idreg"],idaccPayment, false)) return false;
                            break;
                        }

                        case 31: { //Nuovi versamenti CSA
                            if (!generaScritturePagamentoVerPartition(EP, rLiquidazione["idexp"],
                                rLiquidazione["idreg"], idaccPayment, false)) return false;
                            break;
                        }

                        case 20: { /*manca causale*/
                            //Ritenute e contributi da import CSA   VERSAMENTI
                            if (usaContiPresentazioneDocumenti) break;

                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            // DEBITO (conto generico)      A       BANCA pagamento
                            object idregToConsider = rLiquidazione["idreg"];
                            // prendo la stessa anagrafica sui due dettagli
                            if (autocode != 0) {
                                // prendo l'anagrafica associata all'ente CSA 
                                idregToConsider = Conn.DO_READ_VALUE("csa_agency", QHS.CmpEq("idcsa_agency", autocode),
                                    "idreg");
                            }

                            EP.EffettuaScrittura("PAGAM", importo, idAccFornitore,
                                idregToConsider, rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        default:
                            //Deve generare una scrittura netta dal debiti vs fornitore a banca, e una serie di scritture
                            // da debiti vs fornitore ai vari conti di debito vs enti x ritenute dip.
                            //Nulla accade x i contributi !!
                            if (autokind == 21 && usaContiPresentazioneDocumenti) break; //LORDI

                            // Scritture sulle ritenute, ove presenti
                            string filtroDettaglio = QHS.CmpEq("idexp", rLiquidazione["idexp"]);
                            DataTable tDettaglioRitenute = Conn.RUN_SELECT("expensetaxview",
                                "idexp,taxcode, taxref, idaccmotive_debit,idaccmotive_pay,employtax,admintax",
                                null, filtroDettaglio, null, true);
                            foreach (DataRow taxRow2 in tDettaglioRitenute.Rows) {
                                object codicerit = taxRow2["taxcode"];
                                decimal importoRitenuta = CfgFn.GetNoNullDecimal(taxRow2["employtax"]);
                                decimal contributo = CfgFn.GetNoNullDecimal(taxRow2["admintax"]);

                                DataTable tRegs = tHelp.GetIdRegFor(codicerit, rLiquidazione["idexp"]);
                                //Prende i conti associati alla causale se non ci sono già
                                object idaccPay = idAccFornitore;
                                object idaccmotiveRitpay = taxRow2["idaccmotive_pay"];
                                if (idaccmotiveRitpay == DBNull.Value && (importoRitenuta > 0)) {
                                    object nmov = Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", taxRow2["idexp"]),
                                        "nmov");
                                    ShowMessage("La ritenuta di codice " + taxRow2["taxref"] +
                                                " non è stata configurata per l'E/P (n.movimento " + nmov + ")");
                                    return false;
                                }

                                idaccmotiveRitpay = taxRow2["idaccmotive_pay"];
                                DataRow[] contiPay = EP.GetAccMotiveDetails(idaccmotiveRitpay);
                                if (idaccmotiveRitpay != DBNull.Value && contiPay.Length == 0) {
                                    object nmov = Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", taxRow2["idexp"]),
                                        "nmov");
                                    ShowMessage("La causale di liquidazione della ritenuta " + taxRow2["taxref"]
                                                                                             +
                                                                                             " non è ben configurata per l'E/P (n.movimento " +
                                                                                             nmov + ")");
                                    return false;
                                }

                                if (contiPay.Length > 0) {
                                    idaccPay = contiPay[0]["idacc"];
                                }


                                //Effettua la scrittura debito CONTO erario A debito VERSO erario nel caso di 
                                // liq.diretta e debito conto erario configurato, per la parte CONTRIBUTO
                                object idaccmotiveRitdeb = taxRow2["idaccmotive_debit"];
                                if (liqDiretta && idaccmotiveRitdeb != DBNull.Value && contributo != 0) {
                                    DataRow[] contiDeb = EP.GetAccMotiveDetails(idaccmotiveRitdeb);
                                    //Effettua scrittura debito conto inps a conto pag. ritenute									
                                    foreach (DataRow rEntry2 in contiDeb) {
                                        //Il foreach in realtà troverà al massimo una riga
                                        EP.EffettuaScrittura("APPCONTRIB", contributo, rEntry2["idacc"],
                                            idregauto, rLiquidazione["idupb"], null, null, null, idaccmotiveRitdeb,
                                            (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                                    }

                                    foreach (DataRow ttr in tRegs.Rows) {
                                        decimal amountToConsider = contributo * CfgFn.GetNoNullDecimal(ttr["quota"]);
                                        int idregToConsider = CfgFn.GetNoNullInt32(ttr["idreg"]);

                                        EP.EffettuaScrittura("APPCONTRIB", -amountToConsider, idaccPay,
                                            idregToConsider, //era: rLiquidazione["idreg"]
                                            rLiquidazione["idupb"], null, null, null, idaccmotiveRitdeb,
                                            (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                                    }
                                }

                            }

                            // conti banca = importo  /*manca causale*/
                             EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                    rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated,
                                    (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);

                            decimal importoRecuperoSplitPaymentCommerciale = CfgFn.GetNoNullDecimal(
                                Conn.DO_READ_VALUE("expenseclawback",
                                    QHS.AppAnd(QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                                        QHS.CmpEq("idclawback", idclawbackSplitPayment)),
                                    "SUM(amount)")
                            );

                            decimal importoRecuperoIvaEstera = CfgFn.GetNoNullDecimal(
                                Conn.DO_READ_VALUE("expenseclawback",
                                    QHS.AppAnd(QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                                        QHS.CmpEq("idclawback", idclawbackIvaEstera)),
                                    "SUM(amount)")
                            );
                            decimal importoNettoDaSplitPayment = importo - importoRecuperoSplitPaymentCommerciale;
                            decimal importoNettoDaIvaEstera = importo - importoRecuperoIvaEstera;
                            object idaccmotive = null;
                            // Gestione dei movimenti di spesa definiti RECUPERI
                            // Se la spesa è un recupero allora nel caso sia configurato tale recupero il conto di debito
                            // cambia dal conto principale al conto del recupero
                            if (rLiquidazione["idclawback"] != DBNull.Value) {
                                string filterClawBack = QHC.CmpEq("idclawback", rLiquidazione["idclawback"]);
                                DataRow[] clawBack = tClawBackSetup.Select(filterClawBack);
                                if (clawBack.Length > 0) {
                                    if (clawBack[0]["idaccmotive"] != DBNull.Value) {
                                        object idaccmotiveCb = clawBack[0]["idaccmotive"];
                                        DataRow[] contiDebRecupero = EP.GetAccMotiveDetails(idaccmotiveCb);
                                        if (contiDebRecupero.Length > 0) {
                                            idAccFornitore = contiDebRecupero[0]["idacc"];
                                            idaccmotive = idaccmotiveCb;
                                        }
                                    }
                                }
                            }

                            if (importoRecuperoSplitPaymentCommerciale != 0) {
                                if (idaccRecuperoSplitPayment == DBNull.Value) {
                                    ShowMessage(
                                        "La causale di liquidazione del recupero split Payment (16_SPLIT_PAYMENT_C) non è stata configurata per l'E/P");
                                    return false;
                                }
                            }

                            if (importoRecuperoIvaEstera != 0) {
                                if (idaccRecuperoSplitPayment == DBNull.Value) {
                                    ShowMessage(
                                        "La causale di liquidazione del recupero IVA ESTERA non è stata configurata per l'E/P");
                                    return false;
                                }
                            }

                            // A questo punto genera la scrittura da debiti vs fornitore a banca							
                            if (importoRecuperoIvaEstera != 0) {
                                generaScritturaDebito(importoNettoDaIvaEstera, importoRecuperoIvaEstera,
                                    idAccFornitore, idaccRecuperoIvaEstera, rLiquidazione["idreg"],
                                    rLiquidazione["idupb"],
                                    rLiquidazione["idexp"], idaccmotive, false, rLiquidazione["description"],
                                    rLiquidazione["idfin"], false);
                            }
                            else {
                                bool isPGiro = (CfgFn.GetNoNullInt32(rLiquidazione["finflag"]) & 2) != 0;
                                //Se il pagamento è un recupero generico, marca l'idrelated.
                                object idclawback = rLiquidazione["idclawback"];
                                if ((idclawback != null) && (idclawback != DBNull.Value) && (idclawback != idclawbackIvaEstera) && (idclawback != idclawbackSplitPayment)) {
                                    generaScritturaDebito(importoNettoDaSplitPayment,
                                        importoRecuperoSplitPaymentCommerciale,
                                        idAccFornitore, idaccRecuperoSplitPayment, rLiquidazione["idreg"],
                                        rLiquidazione["idupb"],
                                        rLiquidazione["idexp"], idaccmotive, false, rLiquidazione["description"],
                                        rLiquidazione["idfin"], isPGiro, $"recupero§{rLiquidazione["idclawback"]}");
                                }
                                else {
                                    generaScritturaDebito(importoNettoDaSplitPayment,
                                        importoRecuperoSplitPaymentCommerciale,
                                        idAccFornitore, idaccRecuperoSplitPayment, rLiquidazione["idreg"],
                                        rLiquidazione["idupb"],
                                        rLiquidazione["idexp"], idaccmotive, false, rLiquidazione["description"],
                                        rLiquidazione["idfin"], isPGiro);
                                }
                            }

                            break;
                    }
                }
            }



            if (rVariazioni.Length > 0) {
                foreach (DataRow rVar in rVariazioni) {

                    int idexp = CfgFn.GetNoNullInt32(rVar["idexp"]);
                    if (listaMovSpesa.Contains(idexp)) continue;

                    //L'importo serve sempre, lo mettiamo già nella variabile!
                    decimal importo = CfgFn.GetNoNullDecimal(rVar["amount"]); //dovrebbe essere di segno negativo
                    if (importo == 0) continue;

                    string filterExp = QHS.AppAnd(QHS.CmpEq("idexp", idexp), QHS.CmpEq("ayear", rVar["yvar"]));
                    DataTable tSpesa = Conn.RUN_SELECT("expenseview",
                        "idexp,ymov, nmov, ypay,npay,amount,idreg,idupb,autokind,autocode,idclawback,idaccdebit,idpayment,transmissiondate,description,doc,finflag,idfin",
                        null, filterExp, null, true);
                    DataRow rLiquidazione = tSpesa.Rows[0];
                    if (rLiquidazione["transmissiondate"] == DBNull.Value) continue;


                    // Scritture sul movimento di spesa
                    object idAccFornitore = rLiquidazione["idaccdebit"];
                    if (idAccFornitore == DBNull.Value) {
                        idAccFornitore = EP.GetSupplierAccountForRegistry(null, rLiquidazione["idreg"]);
                    }

                    string idrelDebit = "expense§" + rLiquidazione["idexp"]; //+ "§debit" 15040 rimuovo


                    decimal importoPrincipale = CfgFn.GetNoNullDecimal(rLiquidazione["amount"]);
                    DateTime dataRifPrincipale = (DateTime) rLiquidazione["transmissiondate"];
                    decimal variazioniPrincipale = CfgFn.GetNoNullDecimal(Conn.DO_READ_VALUE("expensevar",
                        QHS.AppAnd(QHS.CmpEq("yvar", Conn.GetEsercizio()), QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                            QHS.CmpLe("adate", dataRifPrincipale), QHS.IsNull("kpaymenttransmission")),
                        "sum(amount)", null));
                    importoPrincipale += variazioniPrincipale;

                    decimal quota = -1;
                    if (importoPrincipale != 0) {
                        quota = importo / importoPrincipale; //è -1 se annullo totale, o quota di -1 se annullo parziale
                    }


                    //importo è l'importo della variazione, e dovrebbe essere negativo. E' usato nei vari rami per invertire le scritture
                    // originali
                    //Dobbiamo distinguere i principali casi:
                    // Mandati normali, eventualmente con ritenute
                    // Mandati x LIQUIDAZIONE RITENUTE (autokind= LIQRT)
                    // (A BREVE): Mandati x LIQUIDAZIONE IVA imm/differita(autokind=LPIva che deve diventare LIIVA/LDIVA!)                    
                    byte autokind = CfgFn.GetNoNullByte(rLiquidazione["autokind"]);
                    int autocode = CfgFn.GetNoNullInt32(rLiquidazione["autocode"]);
                    string descrdet = descrFaseSpesa + " n° " + rLiquidazione["nmov"].ToString() + "/" +
                                      rLiquidazione["ymov"].ToString() +
                                      " Mand. " + " n° " + rLiquidazione["npay"].ToString() + "/" +
                                      rLiquidazione["ypay"].ToString();
                    string idrelated = "expense§" + rLiquidazione["idexp"];
                    switch (autokind) {
                        case 3: //Reintegro fondo economale
                        case 1: //Apertura fondo economale
                            //Reintegro Fondo Piccole Spese
                            object codicefps = rLiquidazione["autocode"];
                            DataRow fpsRow = null;
                            if (codicefps == DBNull.Value) {
                                DataRow[] fpsRows = pSpeseSetup.Select();
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }
                            else {
                                DataRow[] fpsRows = pSpeseSetup.Select(QHC.CmpEq("idpettycash", codicefps));
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }

                            object idaccmotiveFps = DBNull.Value;
                            decimal importofornitore = importo;
                            if ((fpsRow != null) && (fpsRow["idacc"] != DBNull.Value)) {
                                idAccFornitore = fpsRow["idacc"];
                                importofornitore = -importo;
                            }

                            // A questo punto genera la scrittura da debiti  a banca							
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null,
                                idaccmotiveFps, idrelated, descrdet);

                            //14947 mettere idrelated simile a foeco§codice fondo invece di idrelDebit, analogamente nelle distinte incasso
                            EP.EffettuaScritturaIdRelated("PAGAM", importofornitore, idAccFornitore,
                                rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveFps, "foeco§" + autocode, descrdet);

                            break;
                        case 2: //Liquidazione ritenute
                            //Liquidazione ritenute: effettua una scrittura dal conto di pagamento delle ritenute
                            // al conto della BANCA
                            if (usaContiPresentazioneDocumenti) break;
                            object codiceriten = rLiquidazione["autocode"];
                            int taxcode = CfgFn.GetNoNullInt32(codiceriten);

                            TaxInfo tax = TaxInfo.getInfo(taxInfo, taxcode);
                            if (tax == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + codiceriten + " non è il codice di una ritenuta esistente",
                                    "Errore");
                                return false;
                            }

                            DataRow motiveRow = tax.getInfo(CfgFn.GetNoNullInt32(0));
                            if (motiveRow == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + tax.taxRef() +
                                    " non è il codice di una ritenuta configurata per l'EP.", "Errore");
                                return false;
                            }


                            //Prende la causale di pagamento associato alla liqudazione (pay) della ritenuta 
                            object idaccmotiveRiten = motiveRow["idaccmotive_pay"];
                            if (idaccmotiveRiten == DBNull.Value) {
                                ShowMessage("La ritenuta di codice " + tax.taxRef() +
                                            " non è stata configurata per l'E/P");
                                return false;
                            }

                            //Per ogni conto associato alla causale genera una scrittura 
                            DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveRiten);
                            if (rEntries.Length == 0) {
                                ShowMessage("La ritenuta di codice " + tax.taxRef() +
                                            " non è ben configurata per l'E/P");
                                return false;
                            }

                            object idAccRiten = rEntries[0]["idacc"];


                            EP.EffettuaScritturaIdRelated("LIQRIT", importo, idAccRiten, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null,
                                idaccmotiveRiten, idrelDebit, descrdet);

                            EP.EffettuaScritturaIdRelated("LIQRIT", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, idaccmotiveRiten, idrelated, descrdet);
                            break;

                        case 15: { /*manca causale*/
                            //Liquidazione IVA Consolidata INTERNA,  ORMAI IN DISUSO
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated, descrdet);

                            EP.EffettuaScrittura("PAGAM", importo, idAccIvaPaymentInternal,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 16: { /*manca causale*/
                            //Liquidazione IVA Consolidata ESTERNA, ORMAI IN DISUSO                                
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated, descrdet);

                            EP.EffettuaScrittura("PAGAM", importo, idAccIvaPaymentExternal,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 13: //ACCONTO IVA
                        case 12: { /*manca causale*/
                            //Liquidazione IVA
                            //if (usaContiPresentazioneDocumenti && esercizio < 2017) break;  //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");
                            string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 17: { /*manca causale*/
                            //Liquidazione IVA 12
                            //if (usaContiPresentazioneDocumenti && esercizio < 2017) break;  //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");
                            string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPayment12, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 23: { /*manca causale*/
                            //Liquidazione IVA Split
                            //if (usaContiPresentazioneDocumenti && esercizio < 2017) break;  //ripristino a seguito di task 9849
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment, rLiquidazione["idreg"],
                                rLiquidazione["idupb"], null, null, idrelated, descrdet);
                            var rIvaExpense = Conn.readObject("ivapayexpense", q.eq("idexp", rLiquidazione["idexp"]),
                                "yivapay,nivapay");
                            string idrelatedIvaPay = null;
                            if (rIvaExpense != null)
                                idrelatedIvaPay = _composeObjects("ivapay", rIvaExpense["yivapay"],
                                    rIvaExpense["nivapay"]);
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idAccIvaPaymentSplit,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelatedIvaPay, descrdet);
                            break;
                        }

                        case 4: {
                            //Ritenute/Contributi
                            object myaccFornitore = idAccFornitore;
                            //Si tratta del mov. di spesa per i contributi!
                            //Effettua una scrittura	Debito conto erario	 a Banca o 
                            //							Debito (generico)  a banca
                            object codicerit = rLiquidazione["autocode"];
                            int taxcode3 = CfgFn.GetNoNullInt32(codicerit);
                            object idser = Conn.DO_READ_VALUE("expenselast",
                                QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "idser");
                            int idregPrincipale = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense",
                                QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "idreg")); //idreg movimento principale

                            string idrelatedDebitoContoErario =
                                idrelatedDebitFor(rLiquidazione["idpayment"], taxcode3); // cascon§2019§16§RITEN§17 

                            TaxInfo tax3 = TaxInfo.getInfo(taxInfo, taxcode3);
                            if (tax3 == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + taxcode3 + " non è il codice di una ritenuta esistente", "Errore");
                                return false;
                            }

                            DataRow motiveRow3 = tax3.getInfo(CfgFn.GetNoNullInt32(idser));
                            if (motiveRow3 == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + tax3.taxRef() +
                                    " non è il codice di una ritenuta configurata per l'EP.", "Errore");
                                return false;
                            }

                            //Vede se c'è un conto intermedio
                            object idaccmotivecost = motiveRow3["idaccmotive_cost"];
                            object idaccmotiveRitdeb = motiveRow3["idaccmotive_debit"];
                            object idaccmotiveRitpay = motiveRow3["idaccmotive_pay"];

                            object idepexp = DBNull.Value;
                            //se c'è il conto "debito conto erario", lo usa come conto per la scrittura standard
                            if (idaccmotiveRitdeb != DBNull.Value) {
                                DataRow[] contiIntermedi = EP.GetAccMotiveDetails(idaccmotiveRitdeb);
                                if (contiIntermedi.Length > 0) {
                                    myaccFornitore = contiIntermedi[0]["idacc"];
                                }

                                var list = getIdImpegnoBudget(rLiquidazione["idpayment"], codicerit,
                                    rLiquidazione["idreg"], importo);
                                if (list.Count > 0) {
                                    idepexp = list[0].idepexp;
                                }
                            }

                            int idregAutomatismo = CfgFn.GetNoNullInt32(rLiquidazione["idreg"]);
                            if (idregPrincipale == idregAutomatismo) {
                                //task 14931  Ritenute negative su compensi diversi da CSA
                                DataRow[] contiPay = EP.GetAccMotiveDetails(idaccmotiveRitpay);
                                if (idaccmotiveRitpay != DBNull.Value && contiPay.Length == 0) {
                                    object nmov = Conn.DO_READ_VALUE("expense",
                                        QHS.CmpEq("idexp", rLiquidazione["idpayment"]), "nmov");
                                    ShowMessage(
                                        $"La causale di liquidazione della ritenuta {tax3.taxRef()} non è ben configurata per l'E/P (n.movimento {nmov})");
                                    return false;
                                }

                                object idaccPay = contiPay[0]["idacc"];
                                //Ritenuta negativa
                                DataTable tRegs = tHelp.GetIdRegFor(codicerit, rLiquidazione["idexp"]);
                                foreach (DataRow ttr in tRegs.Rows) {
                                    decimal amountToConsider = importo * CfgFn.GetNoNullDecimal(ttr["quota"]);
                                    int idregToConsider = CfgFn.GetNoNullInt32(ttr["idreg"]);

                                    EP.EffettuaScritturaIdRelated("APPCONTRIB", amountToConsider,
                                        idaccPay, //DEBITO VERSO ERARIO in questo caso (task 14931)
                                        idregToConsider, //era: rLiquidazione["idreg"]
                                        rLiquidazione["idupb"], null, idaccmotiveRitpay,
                                        $"ritenuta§{rLiquidazione["idpayment"]}§{taxcode3}", //ritenuta§468614§19
                                        (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                                }
                            }
                            else {
                                //Contributo
                                EP.EffettuaScritturaImpegnoBudget("APPCONTRIB", importo, myaccFornitore,
                                    rLiquidazione["idreg"], rLiquidazione["idupb"],
                                    null, idaccmotivecost, idepexp, null, idrelatedDebitoContoErario,
                                    (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);


                            }


                            EP.EffettuaScritturaIdRelated("APPCONTRIB", importo, idaccPayment, //conto transitori BANCA
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotiveRitdeb,
                                idrelDebit, //idrelated, 
                                (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]
                            );

                            break;
                            //Effettua la scrittura sul debito conto ente usando l'anagrafica DIPARTIMENTO
                            // ossia quella del movimento della p. di giro

                            //EP.EffettuaScrittura("APPCONTRIB", importo, myaccFornitore,
                            //    rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotive);


                        }

                        case 30: { //Nuovi versamenti CSA
                            if (!generaScritturePagamentoRiepPartition(EP, rLiquidazione["idexp"],
                                rLiquidazione["idreg"], idaccPayment, true)) return false;
                            break;
                        }

                        case 31: { //Nuovi riepiloghi CSA
                            if (!generaScritturePagamentoVerPartition(EP, rLiquidazione["idexp"],
                                rLiquidazione["idreg"], idaccPayment, true)) return false;
                            break;
                        }

                        case 20: { /*manca causale*/
                            //Ritenute e contributi da import CSA   VERSAMENTI
                            if (usaContiPresentazioneDocumenti) break;
                            EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated, descrdet);

                            object idregToConsider = rLiquidazione["idreg"];
                            // prendo la stessa anagrafica sui due dettagli
                            if (autocode != 0) {
                                // prendo l'anagrafica associata all'ente CSA 
                                idregToConsider = Conn.DO_READ_VALUE("csa_agency", QHS.CmpEq("idcsa_agency", autocode),
                                    "idreg");
                            }

                            EP.EffettuaScrittura("PAGAM", importo, idAccFornitore,
                                idregToConsider, rLiquidazione["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        default: /*manca causale*/
                            // conti banca = importo 
                            //Se il pagamento è un recupero generico, marca l'idrelated.
                            object idclawback = rLiquidazione["idclawback"];
                            if ((idclawback != null) && (idclawback != DBNull.Value) && (idclawback != idclawbackIvaEstera) && (idclawback != idclawbackSplitPayment)) {
                                EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                    rLiquidazione["idreg"], rLiquidazione["idupb"], null, null,
                                    $"recupero§{rLiquidazione["idclawback"]}", 
                                    (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                            }
                            else {
                                EP.EffettuaScritturaIdRelated("PAGAM", importo, idaccPayment,
                                    rLiquidazione["idreg"], rLiquidazione["idupb"], null, null, idrelated,
                                    (rLiquidazione["doc"] + " ").TrimStart() + rLiquidazione["description"]);
                            }

                            //vede se esiste un importo recupero per il movimento principale
                            decimal importoRecuperoSplitPaymentCommerciale = CfgFn.GetNoNullDecimal(
                                Conn.DO_READ_VALUE("expenseclawback",
                                    QHS.AppAnd(QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                                        QHS.CmpEq("idclawback", idclawbackSplitPayment)),
                                    "SUM(amount)")
                            );
                            decimal importoRecuperoIvaEstera = CfgFn.GetNoNullDecimal(
                                Conn.DO_READ_VALUE("expenseclawback",
                                    QHS.AppAnd(QHS.CmpEq("idexp", rLiquidazione["idexp"]),
                                        QHS.CmpEq("idclawback", idclawbackIvaEstera)),
                                    "SUM(amount)")
                            );

                            //caso normale : importo positivo,   importoRecuperoSplitPaymentCommerciale positivo
                            //caso variazione: importo è negativo, importoRecuperoSplitPaymentCommerciale ma l'ho moltiplicato per la quota
                            //                          quindi quotaImportoRecuperoSplitPaymentCommerciale è negativo
                            //                  sottraendo ottengo l'effetto di sommare  e quindi ridurre il valore negativo
                            decimal quotaImportoRecuperoSplitPaymentCommerciale =
                                importoRecuperoSplitPaymentCommerciale * quota;
                            decimal importoNettoDaSplitPayment = importo - quotaImportoRecuperoSplitPaymentCommerciale;
                            decimal quotaImportoRecuperoIvaEstera = importoRecuperoIvaEstera * quota;
                            decimal importoNettoDaIvaEstera = importo - quotaImportoRecuperoIvaEstera;

                            // Gestione dei movimenti di spesa definiti RECUPERI
                            // Se la spesa è un recupero allora nel caso sia configurato tale recupero il conto di debito
                            // cambia dal conto principale al conto del recupero
                            if (rLiquidazione["idclawback"] != DBNull.Value) {
                                string filterClawBack = QHC.CmpEq("idclawback", rLiquidazione["idclawback"]);
                                DataRow[] clawBack = tClawBackSetup.Select(filterClawBack);
                                if (clawBack.Length > 0) {
                                    if (clawBack[0]["idaccmotive"] != DBNull.Value) {
                                        object idaccmotiveCb = clawBack[0]["idaccmotive"];
                                        DataRow[] contiDebRecupero = EP.GetAccMotiveDetails(idaccmotiveCb);
                                        if (contiDebRecupero.Length > 0) {
                                            idAccFornitore = contiDebRecupero[0]["idacc"];
                                        }
                                    }
                                }
                            }

                            if (importoRecuperoSplitPaymentCommerciale != 0) {
                                if (idaccRecuperoSplitPayment == DBNull.Value) {
                                    ShowMessage(
                                        "La causale di liquidazione del recupero split Payment (16_SPLIT_PAYMENT_C) non è stata configurata per l'E/P");
                                    return false;
                                }
                            }

                            if (importoRecuperoIvaEstera != 0) {
                                if (idaccRecuperoSplitPayment == DBNull.Value) {
                                    ShowMessage(
                                        "La causale di liquidazione del recupero IVA ESTERA non è stata configurata per l'E/P");
                                    return false;
                                }
                            }


                            // A questo punto genera la scrittura da debiti vs fornitore a banca		
                            // attenzione che importoNettoDaSplitPayment e importoRecuperoSplitPaymentCommerciale sono NEGATIVI
                            if (importoRecuperoIvaEstera != 0) {
                                generaScritturaDebito(importoNettoDaIvaEstera, quotaImportoRecuperoIvaEstera,
                                    idAccFornitore, idaccRecuperoSplitPayment, rLiquidazione["idreg"],
                                    rLiquidazione["idupb"],
                                    rLiquidazione["idexp"], null, true, rLiquidazione["description"],
                                    rLiquidazione["idfin"], false);
                            }
                            else {
                                bool isPGiro = (CfgFn.GetNoNullInt32(rLiquidazione["finflag"]) & 2) != 0;
                                generaScritturaDebito(importoNettoDaSplitPayment,
                                    quotaImportoRecuperoSplitPaymentCommerciale,
                                    idAccFornitore, idaccRecuperoSplitPayment, rLiquidazione["idreg"],
                                    rLiquidazione["idupb"],
                                    rLiquidazione["idexp"], null, true, rLiquidazione["description"],
                                    rLiquidazione["idfin"], isPGiro);
                            }

                            break;

                    }





                }
            }



            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0 && !EP.D.HasChanges()) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        class InfoDebitoContributo {
            public object idreg;
            public object idepexp;
            public string idrelated;
            public object idaccmotive;
            public decimal amount;

            public InfoDebitoContributo(object idreg, object idepexp, string idrelated, decimal amount,
                object idaccmotive) {
                this.idreg = idreg;
                this.idepexp = idepexp;
                this.idrelated = idrelated;
                this.amount = amount;
                this.idaccmotive = idaccmotive;
            }
        }

        string idrelatedDebitFor(object idexp, object taxcode) {
            object expensephase = _rConfig["expensephase"];
            object idExpFaseImpegno = Conn.DO_READ_VALUE("expenselink",
                QHS.AppAnd(QHS.CmpEq("idchild", idexp), QHS.CmpEq("nlevel", expensephase)), "idparent");

            //Vede se è pagamento di una prestazione professionale 
            // NO: in questo caso il debito sarà chiuso in fase di pagamento fattura, 
            // mentre per eventuali contributi sarà fatto in fase di liquidazione ritenute

            //Vede se è pagamento di una prestazione occasionale 
            //gli impegni di budget ad essa associati possono essere di tipo CASCON, CASCON-RITEN e CASCON-SPESA.
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            DataTable contOccasionale = Conn.RUN_SELECT("expensecasualcontractview", "ycon,ncon", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idexp", idExpFaseImpegno)), null, false);
            if (contOccasionale != null && contOccasionale.Rows.Count > 0) {
                DataRow rExpCon = contOccasionale.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                return _composeObjects("cascon", ycon, ncon, "RITEN", taxcode);
            }

            //Vede se è pagamento di una prestazione dipendente 
            //gli impegni di budget ad essa associati possono essere di tipo WAGEADD-RITEN.

            DataTable contWageAdd = Conn.RUN_SELECT("expensewageadditionview", "ycon,ncon", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idexp", idExpFaseImpegno)), null, false);
            if (contWageAdd != null && contWageAdd.Rows.Count > 0) {
                DataRow rExpCon = contWageAdd.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                return _composeObjects("wageadd", ycon, ncon, "RITEN", taxcode);
            }
            //Vede se è pagamento di un cedolino

            DataTable contPayroll = Conn.RUN_SELECT("expensepayrollview", "idpayroll", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idexp", idExpFaseImpegno)), null, false);
            if (contPayroll != null && contPayroll.Rows.Count > 0) {
                DataRow rExpCon = contPayroll.Rows[0];
                object idpayroll = rExpCon["idpayroll"];
                return _composeObjects("payroll", idpayroll, "RITEN", taxcode);
            }

            //Vede se è pagamento di un contratto professionale

            DataTable contProfService = Conn.RUN_SELECT("expenseprofserviceview", "ycon,ncon", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idexp", idExpFaseImpegno)), null, false);
            if (contProfService != null && contProfService.Rows.Count > 0) {
                DataRow rExpCon = contProfService.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                return _composeObjects("profservice", ycon, ncon, "RITEN", taxcode);
            }

            //Vede se è pagamento di una missione
            //gli impegni di budget ad essa associati possono essere di tipo anticipo o saldo, ma i debiti sugli anticipi non possono essere collegati
            //    a impegni "provvisori", quindi le scritture sui debiti relativi ad anticipi dovrebbero avere la stessa causale della missione
            // Alternativamente non è possibile movimentare anticipi su cap. di spesa se si usano causali di anticipo specifiche. La chiusura di 
            //  debiti per anticipi su partite di giro non è associata ad impegni di budget
            //In questa sede dobbiamo considerare quelli di tipo RITEN ove presenti
            // 4 "Pagamento o saldo della missione"
            // 5 "Anticipo della missione su partita di giro"
            // 6 "Anticipo della missione sul capitolo di spesa"
            DataTable contItineration = Conn.RUN_SELECT("expenseitinerationview", "yitineration,nitineration", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idexp", idExpFaseImpegno),
                    QHS.CmpNe("movkind", 5)), null, false);
            if (contItineration != null && contItineration.Rows.Count > 0) {
                DataRow rExpCon = contItineration.Rows[0];
                object yitineration = rExpCon["yitineration"];
                object nitineration = rExpCon["nitineration"];
                return _composeObjects("itineration", yitineration, nitineration, "RITEN", taxcode);
            }

            return null;

        }

        List<InfoDebitoContributo>
            getIdImpegnoBudget(object idexp, object taxcode, object idreg, decimal defaultAmount) {
            // Dato un impegno e un codice ritenuta cerca un impegno di budget da associare 
            object expensephase = _rConfig["expensephase"];
            object idExpFaseImpegno = Conn.DO_READ_VALUE("expenselink",
                QHS.AppAnd(QHS.CmpEq("idchild", idexp), QHS.CmpEq("nlevel", expensephase)), "idparent");

            //Vede se è pagamento di una prestazione professionale 
            // NO: in questo caso il debito sarà chiuso in fase di pagamento fattura, 
            // mentre per eventuali contributi sarà fatto in fase di liquidazione ritenute

            //Vede se è pagamento di una prestazione occasionale 
            //gli impegni di budget ad essa associati possono essere di tipo CASCON, CASCON-RITEN e CASCON-SPESA.
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            string idRelatedConn;
            string idRelatedConnRiten;

            DataTable contOccasionale = Conn.RUN_SELECT("expensecasualcontract", "ycon,ncon", null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contOccasionale != null && contOccasionale.Rows.Count > 0) {
                DataRow rExpCon = contOccasionale.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                idRelatedConn = _composeObjects("cascon", ycon, ncon);
                idRelatedConnRiten = _composeObjects("cascon", ycon, ncon, "RITEN", taxcode);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConnRiten, idreg, defaultAmount);
            }

            //Vede se è pagamento di una prestazione dipendente 
            //gli impegni di budget ad essa associati possono essere di tipo WAGEADD-RITEN.

            DataTable contWageAdd = Conn.RUN_SELECT("expensewageaddition", "ycon,ncon", null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contWageAdd != null && contWageAdd.Rows.Count > 0) {
                DataRow rExpCon = contWageAdd.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                idRelatedConn = _composeObjects("wageadd", ycon, ncon);
                idRelatedConnRiten = _composeObjects("wageadd", ycon, ncon, "RITEN", taxcode);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConnRiten, idreg, defaultAmount);
            }
            //Vede se è pagamento di un cedolino

            DataTable contPayroll = Conn.RUN_SELECT("expensepayroll", "idpayroll", null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contPayroll != null && contPayroll.Rows.Count > 0) {
                DataRow rExpCon = contPayroll.Rows[0];
                object idpayroll = rExpCon["idpayroll"];
                idRelatedConn = _composeObjects("payroll", idpayroll);
                idRelatedConnRiten = _composeObjects("payroll", idpayroll, "RITEN", taxcode);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConnRiten, idreg, defaultAmount);
            }

            //Vede se è pagamento di un contratto professionale

            DataTable contProfService = Conn.RUN_SELECT("expenseprofservice", "ycon,ncon", null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contProfService != null && contProfService.Rows.Count > 0) {
                DataRow rExpCon = contProfService.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                idRelatedConn = _composeObjects("profservice", ycon, ncon);
                idRelatedConnRiten = _composeObjects("profservice", ycon, ncon, "RITEN", taxcode);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConnRiten, idreg, defaultAmount);
            }

            //Vede se è pagamento di una missione
            //gli impegni di budget ad essa associati possono essere di tipo anticipo o saldo, ma i debiti sugli anticipi non possono essere collegati
            //    a impegni "provvisori", quindi le scritture sui debiti relativi ad anticipi dovrebbero avere la stessa causale della missione
            // Alternativamente non è possibile movimentare anticipi su cap. di spesa se si usano causali di anticipo specifiche. La chiusura di 
            //  debiti per anticipi su partite di giro non è associata ad impegni di budget
            //In questa sede dobbiamo considerare quelli di tipo RITEN ove presenti
            // 4 "Pagamento o saldo della missione"
            // 5 "Anticipo della missione su partita di giro"
            // 6 "Anticipo della missione sul capitolo di spesa"
            DataTable contItineration = Conn.RUN_SELECT("expenseitinerationview", "yitineration,nitineration", null,
                QHS.AppAnd(QHS.CmpEq("idexp", idExpFaseImpegno),
                    QHS.CmpNe("movkind", 5)), null, false);
            if (contItineration != null && contItineration.Rows.Count > 0) {
                DataRow rExpCon = contItineration.Rows[0];
                object yitineration = rExpCon["yitineration"];
                object nitineration = rExpCon["nitineration"];
                idRelatedConn = _composeObjects("itineration", yitineration, nitineration);
                idRelatedConnRiten = _composeObjects("itineration", yitineration, nitineration, "RITEN", taxcode);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConnRiten, idreg, defaultAmount);
            }


            DataTable contCsaImport = Conn.RUN_SELECT("csa_import_expense", "idcsa_import", null,
                QHS.CmpEq("idexp", idexp), null, false);
            if (contCsaImport != null && contCsaImport.Rows.Count > 0) {
                DataRow rExpCsa = contCsaImport.Rows[0];
                object idcsa = rExpCsa["idcsa_import"];
                idRelatedConn = _composeObjects("csaimport", idcsa);
                return getIdExpImpegnoFromIdRelated(idRelatedConn, idRelatedConn, idreg, defaultAmount);
            }

            return new List<InfoDebitoContributo>();
        }

        /// <summary>
        /// Ottiene l'elenco degli idexp  dei pagamenti di un documento 
        /// </summary>
        /// <returns></returns>
        List<object> getPagamentiDocumento(DataRow doc) {
            var res = new List<object>();
            if (doc.Table.TableName == "mandate" && CfgFn.GetNoNullInt32(doc["yman"]) >= minimoAnnoImpegniDiBudget) {
                var sql = "select el.idexp from " +
                          " expensemandate m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.idmankind", doc["idmankind"]),
                              QHS.CmpEq("m.yman", doc["yman"]),
                              QHS.CmpEq("m.nman", doc["nman"]));
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "invoice" && tipoFatturaAV(doc["idinvkind"]) == "A") {
                var sql = "select m.idexp from " +
                          " expenseinvoice m " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.idinvkind", doc["idinvkind"]),
                              QHS.CmpEq("m.yinv", doc["yinv"]),
                              QHS.CmpEq("m.ninv", doc["ninv"]));
                var expInv = Conn.SQLRunner(sql);
                foreach (DataRow r in expInv.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "casualcontract") {
                var sql = "select el.idexp from " +
                          " expensecasualcontract m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.ycon", doc["ycon"]),
                              QHS.CmpEq("m.ncon", doc["ncon"]));
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "itineration") {
                var sql = "select el.idexp from " +
                          " expenseitineration m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.CmpEq("m.iditineration", doc["iditineration"]);
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "payroll") {
                var sql = "select el.idexp from " +
                          " expensepayroll m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.CmpEq("m.idpayroll", doc["idpayroll"]);
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "parasubcontract") {
                var sql = "select el.idexp from " +
                          " expensepayroll m " +
                          " join payroll p on p.idpayroll=m.idpayroll " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.CmpEq("P.idcon", doc["idcon"]);
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "profservice" &&
                CfgFn.GetNoNullInt32(doc["ycon"]) >= minimoAnnoImpegniDiBudget) {
                var sql = "select el.idexp from " +
                          " expenseprofservice m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.ycon", doc["ycon"]),
                              QHS.CmpEq("m.ncon", doc["ncon"]));
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            if (doc.Table.TableName == "wageaddition") {
                var sql = "select el.idexp from " +
                          " expensewageaddition m " +
                          " join expenselink elk on m.idexp = elk.idparent " +
                          "join expenselast  el on elk.idchild = el.idexp " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.ycon", doc["ycon"]),
                              QHS.CmpEq("m.ncon", doc["ncon"]));
                var expMan = Conn.SQLRunner(sql);
                foreach (DataRow r in expMan.Rows) {
                    res.Add(r["idexp"]);
                }
            }

            return res;
        }

        /// <summary>
        /// Ottiene l'elenco degli idexp  dei pagamenti di un documento avente un dato documento
        /// </summary>
        /// <returns></returns>
        List<object> getIncassiDocumento(DataRow doc) {
            var res = new List<object>();
            if (doc.Table.TableName == "estimate" && CfgFn.GetNoNullInt32(doc["yestim"]) >= minimoAnnoImpegniDiBudget) {
                var sql = "select el.idinc from " +
                          " incomeestimate m " +
                          " join incomelink elk on m.idinc = elk.idparent " +
                          "join incomelast  el on elk.idchild = el.idinc " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.idestimkind", doc["idestimkind"]),
                              QHS.CmpEq("m.yestim", doc["yestim"]),
                              QHS.CmpEq("m.nestim", doc["nestim"]));
                var incEst = Conn.SQLRunner(sql);
                if ((incEst != null) && incEst.Rows.Count > 0) {
                    foreach (DataRow r in incEst.Rows) {
                        res.Add(r["idinc"]);
                    }
                }
            }

            if (doc.Table.TableName == "invoice" && tipoFatturaAV(doc["idinvkind"]) == "V") {
                var sql = "select m.idinc from " +
                          " incomeinvoice m " +
                          " where " +
                          QHS.AppAnd(QHS.CmpEq("m.idinvkind", doc["idinvkind"]),
                              QHS.CmpEq("m.yinv", doc["yinv"]),
                              QHS.CmpEq("m.ninv", doc["ninv"]));
                var incInv = Conn.SQLRunner(sql);
                if ((incInv != null) && incInv.Rows.Count > 0) {
                    foreach (DataRow r in incInv.Rows) {
                        res.Add(r["idinc"]);
                    }
                }
            }

            return res;
        }

        List<InfoDebitoContributo> getIdExpImpegnoFromIdRelated(string idRelatedConn, string idRelatedConnRiten,
            object idreg, decimal defaultAmount) {
            string filterSpecific;
            bool useDefault = true;
            if (idreg == DBNull.Value || idreg == null) {
                filterSpecific = QHS.DoPar(QHS.AppOr(QHS.CmpEq("idrelated", idRelatedConnRiten),
                    QHS.Like("idrelated", idRelatedConnRiten + "§%")));
            }
            else {
                filterSpecific = QHS.CmpEq("idrelated", idRelatedConnRiten + "§" + idreg);
            }

            DataTable impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                "idepexp,idreg,totcurramount,idrelated,idaccmotive",
                null, QHS.AppAnd(filterSpecific,
                    //QHS.CmpEq("ayear", esercizio),
                    QHS.CmpEq("nphase", 2)
                ), null, false);

            if (impegniBudget.Rows.Count == 0) {
                impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                    "idepexp,totcurramount,idreg,idrelated,idaccmotive",
                    null, QHS.AppAnd(QHS.CmpEq("idrelated", idRelatedConnRiten),
                        //QHS.CmpEq("ayear", esercizio),
                        QHS.CmpEq("nphase", 2)

                    ), null, false);
            }

            if (impegniBudget.Rows.Count == 0) {
                impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                    "idepexp,totcurramount,idreg,idrelated,idaccmotive",
                    null, QHS.AppAnd(QHS.CmpEq("idrelated", idRelatedConn),
                        //QHS.CmpEq("ayear", esercizio),
                        QHS.CmpEq("nphase", 2)
                    ), null, false);
                //useDefault = true;
            }

            if (impegniBudget.Rows.Count > 1) useDefault = false;

            var result = new List<InfoDebitoContributo>();
            foreach (DataRow r in impegniBudget.Rows) {
                result.Add(new InfoDebitoContributo(r["idreg"], r["idepexp"], r["idrelated"].ToString(),
                    useDefault ? defaultAmount : CfgFn.GetNoNullDecimal(r["totcurramount"]), r["idaccmotive"]));
            }

            return result;
        }

        //Cambia il conto di debito di un movimento di spesa ed eventuali scritture ad esso collegate
        //void cambiaContoDebito(object idexp, object idacc) {
        //    string idrel = "expense§" + idexp + "§debit";
        //    Conn.DO_UPDATE("expenselast", QHS.CmpEq("idexp", idexp),
        //        new string[] {"idacc"}, new string[] {QHS.quote(idacc)}, 1);
        //    Conn.DO_UPDATE("entrydetail", QHS.CmpEq("idrelated", idrel),
        //        new string[] {"idacc"}, new string[] {QHS.quote(idacc)}, 1);

        //}

        //Attenzione che il totale e gli importi potrebbero essere negativi

        /// <summary>
        /// Effettua la scrittura con idrelated expense..debit
        /// </summary>
        /// <param name="idepexp"></param>
        /// <param name="idepacc"></param>
        /// <param name="idaccmotive"></param>
        /// <param name="amount"></param>
        /// <param name="idAcc"></param>
        /// <param name="idReg"></param>
        /// <param name="idUpb"></param>
        /// <param name="idexp"></param>
        /// <param name="isVariazione"></param>
        /// <param name="description"></param>
        /// <returns></returns>
        decimal singolaScritturaDebitoIdRelated(object idepexp, object idepacc, object idaccmotive, decimal amount,
            object idAcc,
            object idReg,
            object idUpb,
            string idrelated, bool isVariazione, object description = null) {
            if (amount == 0) return 0;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }

            //string idrelated = idexp != DBNull.Value ? "expense§" + idexp  : null; // //+ "§debit" 15040 rimuovo
            decimal importoScrittura = isVariazione
                ? importoScritturaInAvere(amount, idAcc, "PAGAM")
                : importoScritturaInDare(amount, idAcc, "PAGAM");
            EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScrittura,
                idAcc, idReg, idUpb, null, idaccmotive, idepexp, idepacc, idrelated, description);
            if (idepexp != null && idepexp != DBNull.Value)
                EP.aggiornaDebito(CfgFn.GetNoNullInt32(idepexp), isVariazione ? amount : -amount);

            return importoScrittura;
        }

        /// <summary>
        /// Effettua una serie di scritture su un elenco di importi (amounts) e poi un ultima a concorrenza del totale, senza impegno di budget
        /// 
        /// </summary>
        /// <param name="amounts">Associazione impegno di budget - importo</param>
        /// <param name="importoPagamento"></param>
        /// <param name="idAcc"></param>
        /// <param name="idReg"></param>
        /// <param name="idUpb"></param>
        /// <param name="idaccmotive"></param>
        /// <param name="idexp"></param>
        /// <param name="isVariazione">True se il totale ha segno opposto rispetto agli importi singoli</param>
        /// <param name="description"></param>
        bool spezzaScritturaDebito(Dictionary<int, importo_causale> amounts, decimal importoPagamento, object idAcc,
            object idReg, object idUpb, object idaccmotive, bool isVariazione, string idrelatedMain, object description = null, bool riproporziona = false) {
            if (amounts.Count == 0 && importoPagamento == 0) return true;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }

            decimal somma = sommaImporti(amounts); //somma importi del documento      
            //QueryCreator.MarkEvent($"importoPagamento = {importoPagamento}  somma = {somma}");
            if (isVariazione) somma = -somma;
            decimal proporzione = (somma == 0) ? 1 : (importoPagamento / somma);
            if (proporzione > 1) proporzione = 1;
            if (riproporziona && somma == 0 && amounts.Keys.Count > 1) {
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("Non è stato trovato un debito aperto sugli impegni di budget considerati.");
                sb.AppendLine("Impegni di budget coinvolti:");
                foreach (var id in amounts.Keys) {
                    var r = Conn.RowObjectSelect("epexp", "yepexp,nepexp", q.eq("idepexp", id))[0];
                    sb.AppendLine($"{r["yepexp"]}/{r["nepexp"]}");
                }

                ShowMessage(sb.ToString(), "Errore");
                return false;
            }

            if (!riproporziona) proporzione = 1;
            //string idrelated = idexp != DBNull.Value ? "expense§" + idexp  : null;  //+ "§debit" 15040 rimuovo
            foreach (var idepexp in amounts.Keys) {
                decimal importoSegnoCorretto = isVariazione ? -amounts[idepexp].amount : amounts[idepexp].amount;

                if (importoSegnoCorretto == importoPagamento) {
                    //se variazione importoPagamento è già negativo quindi non devo ricambiarlo di segno con importoScritturaInAvere
                    decimal importoScrittura = importoScritturaInDare(importoPagamento, idAcc, "PAGAM");
                    //object curr_idepexp = DBNull.Value;
                    //if (idepexp != 0) curr_idepexp = idepexp;
                    EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScrittura,
                        idAcc, idReg, idUpb, null, amounts[idepexp].idaccmotive,
                        idepexp, null, amounts[idepexp].idrelated, description);
                    EP.aggiornaDebito(idepexp, isVariazione ? importoPagamento : -importoPagamento);
                    return true;
                }
            }

            foreach (var idepexp in amounts.Keys) {
                decimal importo = amounts[idepexp].amount;
                decimal quota = CfgFn.RoundValuta(importo * proporzione); //quota è positiva

                decimal importoScrittura = isVariazione
                    ? importoScritturaInAvere(quota, idAcc, "PAGAM")
                    : importoScritturaInDare(quota, idAcc, "PAGAM");
                if (importoScrittura != 0) {
                    //QueryCreator.MarkEvent($"Importo impegno {importo} quota {quota } importoScrittura{importoScrittura}");
                    //object curr_idepexp = DBNull.Value;
                    //if (idepexp != 0) curr_idepexp = idepexp;
                    EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScrittura, idAcc, idReg, idUpb, null, amounts[idepexp].idaccmotive,
                                                      idepexp, null, amounts[idepexp].idrelated, description);                    
                    
                    
                    EP.aggiornaDebito(idepexp, isVariazione ? importoScrittura : -importoScrittura);
                }

                if (isVariazione) quota = -quota;
                importoPagamento -= quota;
                if (riproporziona) {
                    

                    if (isVariazione) {
                        somma += importo;
                    }
                    else {
                        somma -= importo;
                    }

                    proporzione = (somma == 0) ? 1 : (importoPagamento / somma);
                    if (proporzione > 1) proporzione = 1;
                }

                //QueryCreator.MarkEvent($"proporzione {proporzione} somma {somma} importoPagamento{importoPagamento}");
            }

            //if (importoPagamento!=0) QueryCreator.MarkEvent("residuo:" + importoPagamento);
            //Se non ci sono impegni di budget nel dictionary passa tutto da qui
            if (UsaImpegniDiBudget) {
                // Se è prevista in configurazione la generazione degli impegni di budget genera un dettaglio scrittura di importo pari al residuo 
                decimal importoScritturaResiduo = importoScritturaInDare(importoPagamento, idAcc, "PAGAM");
                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScritturaResiduo, idAcc, idReg, idUpb, null, idaccmotive,
                    null, null,
                    idrelatedMain, description);

            }
            
            return true;
        }

        bool spezzaScritturaDebitoNoBudget(Dictionary<string, importo_causale> amounts, decimal importoPagamento, object idAcc,
            object idReg, object idUpb, object idaccmotive, bool isVariazione, string idrelatedMain, object description = null, bool riproporziona = false) {
            
            if (amounts.Count == 0 && importoPagamento == 0) return true;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }            
            // Se in configurazione non è prevista la generazione impegni di budget usa la stessa ripartizione dell'incasso per generare 
            // dettagli scrittura ripartiti 
            foreach (var idrelated in amounts.Keys) {
                decimal importoSegnoCorretto = isVariazione ? -amounts[idrelated].amount : amounts[idrelated].amount;
                decimal importoScritturaRipartito = importoScritturaInDare(importoSegnoCorretto, idAcc, "PAGAM");
                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScritturaRipartito, idAcc, idReg, idUpb, null, idaccmotive, null, null, idrelated, description);  
            }
            
            return true;
		}

        decimal sommaImporti(Dictionary<int, importo_causale> amounts) {

            decimal sum = 0;
            foreach (var k in amounts.Keys) {
                sum += amounts[k].amount;
            }

            return sum;
        }


        decimal singolaScritturaCreditoIdRelated(object idepexp, object idepacc, object idaccmotive, decimal amount,
            object idAcc,
            object idReg,
            object idUpb,
            string idrelated, bool isVariazione, object description = null) {
            if (amount == 0) return 0;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }

            //string idrelated = idinc != DBNull.Value ? "income§" + idinc : null;//+ "§credit" 15040 tolgo tutto
            if (isVariazione) amount = -amount;
            decimal importoScritturaAA = isVariazione
                ? importoScritturaInDare(amount, idAcc, "INCAS")
                : importoScritturaInAvere(amount, idAcc, "INCAS");
            EP.EffettuaScritturaImpegnoBudget("INCAS", importoScritturaAA, idAcc, idReg, idUpb, null, idaccmotive,
                idepexp, idepacc, idrelated, description);
            if (idepacc != null && idepacc != DBNull.Value)
                EP.aggiornaCredito(CfgFn.GetNoNullInt32(idepacc), isVariazione ? -amount : amount);
            return importoScritturaAA;
        }

        /// <summary>
        ///      Se isVariazione=true vuol dire che totale è minore di  0
        /// </summary>
        /// <param name="amounts"></param>
        /// <param name="importoIncasso"></param>
        /// <param name="idAcc"></param>
        /// <param name="idReg"></param>
        /// <param name="idUpb"></param>
        /// <param name="idaccmotive"></param>
        /// <param name="idinc"></param>
        /// <param name="isVariazione"></param>
        /// <param name="description"></param>
        bool spezzaScritturaCredito(Dictionary<int, importo_causale> amounts, decimal importoIncasso, object idAcc,
            object idReg,
            object idUpb,
            object idaccmotive, bool isVariazione, string idrelatedMain, object description = null,
            bool riproporziona = false) {
            if (amounts.Count == 0 && importoIncasso == 0) return true;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }

            decimal somma = sommaImporti(amounts);
            if (isVariazione) somma = -somma;
            decimal proporzione = (somma == 0) ? 1 : importoIncasso / somma;
            if (proporzione > 1) proporzione = 1;
            int nNoZero = 0;
            foreach (var x in amounts.Values) {
                if (x.amount != 0) nNoZero++;
            }

            if (riproporziona && somma == 0 && nNoZero > 1) { //amounts.Keys.Count
                StringBuilder sb = new StringBuilder();
                sb.AppendLine("Non è stato trovato un credito aperto sugli accertamenti di budget considerati.");
                sb.AppendLine("Accertamenti di budget coinvolti:");
                foreach (var id in amounts.Keys) {
                    var r = Conn.RowObjectSelect("epacc", "yepacc,nepacc", q.eq("idepacc", id))[0];
                    sb.AppendLine($"{r["yepacc"]}/{r["nepacc"]}");
                }

                ShowMessage(sb.ToString(), "Errore");
                return false;

            }

            if (!riproporziona) proporzione = 1;
            //string idrelated = idinc != DBNull.Value ? "income§" + idinc : null; //+ "§credit" 15040 tolgo tutto
            foreach (var idepinc in amounts.Keys) {
                decimal importoSegnoCorretto = isVariazione ? -amounts[idepinc].amount : amounts[idepinc].amount;

                if (CfgFn.RoundValuta(importoSegnoCorretto) == CfgFn.RoundValuta(importoIncasso)) {
                    //se variazione importoIncasso è  negativo quindi devo ricambiarlo di segno 
                    decimal importoScrittura2 = importoScritturaInAvere(importoIncasso, idAcc, "INCAS");
                    //object curr_idepinc = idepinc;
                    //if (idepinc != 0) curr_idepinc = idepinc;
                    EP.EffettuaScritturaImpegnoBudget("INCAS", importoScrittura2,
                        idAcc, idReg, idUpb, null, amounts[idepinc].idaccmotive, null, idepinc,
                        amounts[idepinc].idrelated, description); //idrelated
                    EP.aggiornaCredito(idepinc, isVariazione ? -importoIncasso : importoIncasso);
                    return true;
                }
            }


            foreach (var idepinc in amounts.Keys) {
                decimal importo = amounts[idepinc].amount; //positivo
                decimal quota = CfgFn.RoundValuta(importo * proporzione); //quota è positiva

                decimal importoScrittura = isVariazione
                    ? importoScritturaInDare(quota, idAcc, "INCAS")
                    : importoScritturaInAvere(quota, idAcc, "INCAS");

                //decimal importoScritturaAA = importoScritturaInAvere(quota, idAcc, "INCAS");//se variazione quota è negativo
                if (importoScrittura != 0) {
                    //object curr_idepinc = DBNull.Value;
                    //if (idepinc != 0) curr_idepinc = idepinc;
                    EP.EffettuaScritturaImpegnoBudget("INCAS", importoScrittura, idAcc, idReg, idUpb, null,
                        amounts[idepinc].idaccmotive, null, idepinc, amounts[idepinc].idrelated,
                        description); //idrelated
                    EP.aggiornaCredito(idepinc, isVariazione ? -importoScrittura : importoScrittura);
                }

                if (isVariazione) quota = -quota;
              
                    importoIncasso -= quota; //Se importo negativo,  importo incasso è negativo, qui l'importo diminuisce ancor di più
                 
                if (riproporziona) {
                    if (isVariazione) {
                        somma += importo;
                    }
                    else {
                            somma -= importo;
                    }
                    proporzione = (somma == 0) ? 1 : (importoIncasso / somma);
                    if (proporzione > 1) proporzione = 1;
                }
            }

            if (UsaImpegniDiBudget) {
                // Se è prevista in configurazione la generazione degli impegni di budget genera un dettaglio scrittura di importo pari al residuo 
                // laddove non sia riuscito a ripartire sugli impegni di budget
                decimal importoScritturaResiduo = importoScritturaInAvere(importoIncasso, idAcc, "INCAS");
                EP.EffettuaScritturaImpegnoBudget("INCAS", importoScritturaResiduo, idAcc, idReg, idUpb, null, idaccmotive,
                    null,
                    null,
                    idrelatedMain, description);
            }
            
            return true;
        }

        bool spezzaScritturaCreditoNoBudget(Dictionary<string, importo_causale> amounts, decimal importoIncasso, object idAcc, object idReg, object idUpb, object idaccmotive,
                                            bool isVariazione, string idrelatedMain, object description = null, bool riproporziona = false) {
            if (amounts.Count == 0 && importoIncasso == 0) return true;
            if (idAcc == DBNull.Value) {
                ShowMessage("Idacc null");
            }
            // Se in configurazione non è prevista generazione impegni di budget usa la stessa ripartizione dell'incasso per generare dettagli ripartiti
            foreach (var idrelated in amounts.Keys) {
                decimal importoSegnoCorretto = isVariazione ? -amounts[idrelated].amount : amounts[idrelated].amount;
                decimal importoScritturaRipartito = importoScritturaInAvere(importoSegnoCorretto, idAcc, "INCAS");
                EP.EffettuaScritturaImpegnoBudget("INCAS", importoScritturaRipartito, idAcc, idReg, idUpb, null, idaccmotive,
                                                    null, null, idrelated, description);
            }
            return true;
		}

        class importo_causale {
            public decimal amount;
            public object idaccmotive;
            public string idrelated;

            public importo_causale(decimal amount, object idaccmotive, string idrelated) {
                this.amount = amount;
                this.idaccmotive = idaccmotive;
                this.idrelated = idrelated;
            }

        }

        Dictionary<int, importo_causale> ottieniImportiImpegnoDaTabellaMovLast(DataRow[] RowsDett, string fieldIdMov,
            string fieldAmount, bool isAnnullo) {
            Dictionary<int, importo_causale> importiImpegno = new Dictionary<int, importo_causale>();
            if (isAnnullo) { // su distinta variazione prendo sempre importo original
                fieldAmount += "original"; 
			}
            
            foreach (DataRow r in RowsDett) {

                int idepmov = CfgFn.GetNoNullInt32(r[fieldIdMov]);
                if (importiImpegno.ContainsKey(idepmov)) continue;

                decimal amount = CfgFn.GetNoNullDecimal(r[fieldAmount]);
                if ((amount) == 0 && (!isAnnullo)) {// sto rigenerando scrittura dell'elenco di trasmissione originale quando il movimento è stato annullato
                    decimal originalamount = CfgFn.GetNoNullDecimal(r[fieldAmount + "original"]);
                    if ((originalamount!=0) && (amount==0)) amount = originalamount;
                }
                object causale = r["idaccmotive"];

                importiImpegno[idepmov] = new importo_causale(amount, causale,
                    r["idrelated"].ToString());

            }

            return importiImpegno;
        }


        Dictionary<string, importo_causale> ottieniImportiDaTabellaMovLastNoBudget(DataRow[] RowsDett, string fieldNameIdrelated,
           string fieldAmount, bool isAnnullo) {
            Dictionary<string, importo_causale> importiImpegnoFittizio = new Dictionary<string, importo_causale>();
            if (isAnnullo) {// su distinta variazione prendo sempre importo original
                fieldAmount += "original"; 
			}
            
            foreach (DataRow r in RowsDett) {
                // imposto chiave con idrelated dettaglio
                string idrelated = r[fieldNameIdrelated].ToString();
                if (importiImpegnoFittizio.ContainsKey(idrelated)) continue;
                
                decimal amount = CfgFn.GetNoNullDecimal(r[fieldAmount]);
                if ((amount) == 0 && (!isAnnullo)) {// sto rigenerando scrittura dell'elenco di trasmissione originale quando il movimento è stato annullato
                    decimal originalamount = CfgFn.GetNoNullDecimal(r[fieldAmount + "original"]);
                    if ((originalamount != 0) && (amount == 0)) amount = originalamount;
                }
                object causale = r["idaccmotive"];

                importiImpegnoFittizio[idrelated] = new importo_causale(amount, causale,
                    r["idrelated"].ToString());

            }

            return importiImpegnoFittizio;
        }

        /// <summary>
        /// Se non ci sono impegni di budget restituisce un Dictionary vuoto
        /// </summary>
        /// <param name="t"></param>
        /// <param name="fieldIdMov">idepexp o idepacc</param>
        /// <param name="fieldAmount"></param>
        /// <param name="isAnnullo"></param>
        /// <returns></returns>
        Dictionary<int, importo_causale> ottieniImportiImpegnoDaTabellaIdrelated(DataTable t, string fieldIdMov,
            string fieldAmount, bool isAnnullo) {
            Dictionary<int, importo_causale> importiImpegno = new Dictionary<int, importo_causale>();
            foreach (var r in t.Select(QHC.IsNotNull(fieldIdMov))) {

                int idepmov = CfgFn.GetNoNullInt32(r[fieldIdMov]);
                if (importiImpegno.ContainsKey(idepmov)) continue;

                decimal amount = CfgFn.GetNoNullDecimal(r[fieldAmount]);
                object causale = r["idaccmotive"];
                if (fieldIdMov == "idepexp") {
                    decimal debitoCorrente = EP.getCurrentDebitForIdEpExp(idepmov);
                    if (!isAnnullo) amount = debitoCorrente;
                    if (debitoCorrente == 0 && isAnnullo) amount = CfgFn.GetNoNullDecimal(r[fieldAmount]);
                }

                //Non esiste una gestione sul credito analoga al debito al momento
                if (fieldIdMov == "idepacc") {
                    decimal creditoCorrente = EP.getCurrentCreditForIdEpAcc(idepmov);
                    if (!isAnnullo) amount = creditoCorrente;
                    if (creditoCorrente == 0 && isAnnullo) amount = CfgFn.GetNoNullDecimal(r[fieldAmount]);
                }

                importiImpegno[idepmov] = new importo_causale(amount, causale, r["idrelated"].ToString());

            }

            return importiImpegno;
        }

        Dictionary<int, object> ottieniCausaliCostoImpegnoDaTabella(DataTable t, string fieldIdEpExp,
            string fieldIdaccmotive) {
            Dictionary<int, object> causaliImpegno = new Dictionary<int, object>();
            foreach (var r in t.Select(QHC.IsNotNull(fieldIdEpExp))) {
                int idepexp = CfgFn.GetNoNullInt32(r[fieldIdEpExp]);
                object causale = r[fieldIdaccmotive];
                causaliImpegno[idepexp] = causale;
            }

            return causaliImpegno;
        }

        Dictionary<int, double> allProrata = new Dictionary<int, double>();

        double abatableRateOfYear(int anno) {
            if (allProrata.ContainsKey(anno)) return allProrata[anno];
            double prorata =
                CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("iva_prorata", QHS.CmpEq("ayear", anno), "prorata"));
            allProrata[anno] = prorata;
            return prorata;
        }

        void generaScritturaCredito(decimal importo,
            object idAccCredito, object idReg, object idUpb, object idinc, object idaccmotive, bool isVariazione,
            object description, object idfin, bool pGiro) {

            DataTable dettFattura = Conn.RUN_SELECT("invoicedetailview",
                "idinvkind,idepacc,idepexp,idaccmotive, taxable_euro,iva_euro,unabatable_euro,flagvariation,invoicekind,yinv,ninv,rownum,isnull(detaildescription,description) as description",
                null,
                QHS.AppOr(QHS.CmpEq("idinc_taxable", idinc), QHS.CmpEq("idinc_iva", idinc)), null, false);
            decimal totaleScritto = 0;
            if (dettFattura != null && dettFattura.Rows.Count > 0) {
                DataRow rDettFattura = dettFattura.Rows[0];
                idaccmotive = rDettFattura["idaccmotive"];
                //var imponibili = new Dictionary<int, importo_causale>();
                //var ivaindet = new Dictionary<int, importo_causale>();
                object descriptionFatt = nomeFattura(rDettFattura);
                int movkind =
                    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("incomeinvoice", QHS.CmpEq("idinc", idinc), "movkind"));
                double abatablerate = CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("invoicekindyearview",
                    QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idinvkind", dettFattura.Rows[0]["idinvkind"])),
                    "abatablerate"));
                decimal ivaNoMov = 0;
                foreach (DataRow rDett in dettFattura.Rows) {
                    decimal segno = 1;
                    if (rDett["flagvariation"].ToString().ToUpper() == "S") {
                        segno = -1;
                    }

                    string idrelatedDett =
                        $"inv§{rDett["idinvkind"]}§{rDett["yinv"]}§{rDett["ninv"]}§{rDett["rownum"]}";

                    double imponibile = CfgFn.GetNoNullDouble(rDett["taxable_euro"]);
                    decimal iva = CfgFn.GetNoNullDecimal(rDett["iva_euro"]); //era GetNoNullDouble
                    //double ivaIndetraibileLorda = CfgFn.GetNoNullDouble(rDett["unabatable_euro"]);
                    //double ivaDetraibileLorda = iva - ivaIndetraibileLorda;
                    //double ivaDetraibile = CfgFn.RoundValuta(ivaDetraibileLorda * abatablerate);
                    //double ivaIndetraibile = iva - ivaDetraibile;
                    decimal imponibileDec = Convert.ToDecimal(imponibile);
                    //decimal ivaIndetraibileDec = Convert.ToDecimal(ivaIndetraibile);
                    //Se 1 totale 2 tot.iva 3 imponibile  
                    //Se è split va saltata? no
                    if (movkind == 1) {
                        totaleScritto += singolaScritturaCreditoIdRelated(rDett["idepexp"], rDett["idepacc"],
                            idaccmotive,
                            imponibileDec * segno,
                            idAccCredito, idReg, idUpb, idrelatedDett, isVariazione, descriptionFatt);

                        //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepacc"]), idaccmotive, imponibileDec * segno);
                        //aggiornaImporti(ivaindet, CfgFn.GetNoNullInt32(rDett["idepacc"]), idaccmotive, ivaIndetraibileDec * segno);

                        totaleScritto += singolaScritturaCreditoIdRelated(DBNull.Value, DBNull.Value, idaccmotive,
                            iva * segno, idAccCredito,
                            idReg, idUpb, idrelatedDett, isVariazione, descriptionFatt);
                        //ivaNoMov += ivaIndetraibileDec * segno;
                    }

                    if (movkind == 2) {
                        //aggiornaImporti(ivaindet, CfgFn.GetNoNullInt32(rDett["idepacc"]), idaccmotive, ivaIndetraibileDec * segno);
                        totaleScritto += singolaScritturaCreditoIdRelated(DBNull.Value, DBNull.Value, idaccmotive,
                            iva * segno, idAccCredito,
                            idReg, idUpb, idrelatedDett, isVariazione, descriptionFatt);

                        //ivaNoMov += importoIva;
                    }

                    if (movkind == 3) {
                        totaleScritto += singolaScritturaCreditoIdRelated(rDett["idepexp"], rDett["idepacc"],
                            idaccmotive,
                            imponibileDec * segno,
                            idAccCredito, idReg, idUpb, idrelatedDett, isVariazione, descriptionFatt);

                        //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepacc"]), idaccmotive, imponibileDec * segno);
                    }
                }

                string idrelatedMainInv =
                    $"inv§{rDettFattura["idinvkind"]}§{rDettFattura["yinv"]}§{rDettFattura["ninv"]}";

                //singolaScritturaCredito(DBNull.Value, DBNull.Value, idaccmotive, ivaNoMov, idAccCredito, idReg, idUpb, idinc, isVariazione, descriptionFatt);
                singolaScritturaCreditoIdRelated(DBNull.Value, DBNull.Value, idaccmotive, importo - totaleScritto,
                    idAccCredito,
                    idReg, idUpb, idrelatedMainInv, isVariazione, descriptionFatt);
                //spezzaScritturaCredito(imponibili, importo, idAccCredito, idReg, idUpb, idaccmotive,idinc, isVariazione, descriptionFatt);     
                return;
            }

            object idIncFaseAccertamento = Conn.DO_READ_VALUE("incomelink", QHS.AppAnd(QHS.CmpEq("idchild", idinc),
                QHS.CmpEq("nlevel", Conn.GetSys("incomephase"))), "idparent");

            //Vede se è incasso di un contratto attivo 
            DataTable dettCAttivo = Conn.RUN_SELECT("incomelastestimatedetailview",
                "idepacc,idaccmotive,amount as totalcredit, originalamount as totalcreditoriginal,nestim,yestim,rownum,estimkind,idestimkind, linktoinvoice", null,
                QHS.CmpEq("idinc", idinc), null, false);
            Dictionary<int, importo_causale> tabellaCredito = null;
            Dictionary<string, importo_causale> tabellaIncassoRipartito = null;
            string idrelmain = null;
            if ( UsaImpegniDiBudget) {
                if (dettCAttivo == null || dettCAttivo.Rows.Count == 0) {
                    dettCAttivo = Conn.RUN_SELECT("estimatedetailview",
                        "idepacc,idaccmotive,taxable_euro as totalcredit,nestim,yestim,rownum,estimkind,idestimkind", null,
                        QHS.AppAnd(QHS.CmpEq("idinc_taxable", idIncFaseAccertamento), QHS.IsNull("stop")), null, false);
                    dettCAttivo.Columns.Add("idrelated", typeof(string));
                    foreach (DataRow rDet in dettCAttivo.Rows) {
                        rDet["idrelated"] =
                            $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}§{rDet["rownum"]}";
                        idrelmain = $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}";
                    }
                    tabellaCredito = ottieniImportiImpegnoDaTabellaIdrelated(dettCAttivo, "idepacc", "totalcredit", isVariazione);
                }
                else {
                    dettCAttivo.Columns.Add("idrelated", typeof(string));
                    foreach (DataRow rDet in dettCAttivo.Rows) {
                        rDet["idrelated"] = $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}§{rDet["rownum"]}";
                        idrelmain = $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}";
                    }
                    //Se il conto è flaggato con flagenablebudgetprev=S, allora idepacc sarà valorizzato.
                    DataRow[] RowsCA_withidepacc = dettCAttivo.Select(QHC.IsNotNull("idepacc"));
                    //Serve per fare lo spessaScritturaCredito sui dettagli CA con Acc. di budget
                    tabellaCredito = ottieniImportiImpegnoDaTabellaMovLast(RowsCA_withidepacc, "idepacc", "totalcredit", isVariazione);

                    object descriptionDet = nomeCAttivo(dettCAttivo.Rows[0]);
                    //Se il conto è flaggato con flagenablebudgetprev = N, allora idepacc varrà null.
                    DataRow[] RowsCA_withoutidepacc = dettCAttivo.Select(QHC.IsNull("idepacc"));
                    
                    tabellaIncassoRipartito = ottieniImportiDaTabellaMovLastNoBudget(RowsCA_withoutidepacc, "idrelated", "totalcredit", isVariazione);
                    //Agisce sui dettagli CA senza Acc. di budget
                    spezzaScritturaCreditoNoBudget(tabellaIncassoRipartito, importo, idAccCredito, idReg, idUpb, dettCAttivo.Rows[0]["idaccmotive"],
                                        isVariazione, idrelmain, descriptionDet, true);

                }
                if (tabellaCredito!= null && tabellaCredito.Count!= 0 ) {
                    object descriptionDet = nomeCAttivo(dettCAttivo.Rows[0]);
                    //deve considerare l'importo al netto della quota usata prima, ossia la parte che ha ripartito col no-budget
                    decimal somma = sommaImportiNoBudget(tabellaIncassoRipartito);
                    if (isVariazione) {
                        somma = -somma;
                    }
                    importo = importo - somma;//se passa di qui, allora dopo farà il return e non userà più 'importo'
                    spezzaScritturaCredito(tabellaCredito, importo, idAccCredito, idReg, idUpb, dettCAttivo.Rows[0]["idaccmotive"], isVariazione, idrelmain,
                     descriptionDet, true);
                    return;
                }

                //Calcola quanto ha ripartito col NoBudget, se ha ripartito tutto, allora esce.
                //Non consideriamo il Budget, ossia tabellaCredito, perchè se questa fosse valorizzata avrebbe chiamato spezzaScritturaCredito() e poi sarebbe uscito.
                decimal RipartitoNoBudget = sommaImportiNoBudget(tabellaIncassoRipartito);
                if (importo == RipartitoNoBudget) {
                    return;
                }
                if (isVariazione) {
                    RipartitoNoBudget = -RipartitoNoBudget;
                }
                importo = importo-RipartitoNoBudget;
            }
            else {
                if (dettCAttivo != null && dettCAttivo.Rows.Count > 0) {
                    dettCAttivo.Columns.Add("idrelated", typeof(string));
                    foreach (DataRow rDet in dettCAttivo.Rows) {
                        rDet["idrelated"] = $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}§{rDet["rownum"]}";
                        idrelmain = $"estim§{rDet["idestimkind"]}§{rDet["yestim"]}§{rDet["nestim"]}";
                    }

                    object descriptionDet = nomeCAttivo(dettCAttivo.Rows[0]);
                    // usa la stessa ripartizione dell'incasso in incomelastestimatedetail per i dettagli scritture
                    if ((tabellaCredito == null || tabellaCredito.Count == 0) && (!UsaImpegniDiBudget)) {
                        tabellaIncassoRipartito = ottieniImportiDaTabellaMovLastNoBudget(dettCAttivo.Select(), "idrelated", "totalcredit", isVariazione);
                        //}
                        //"Contratto attivo " + dettCAttivo.Rows[0]["estimkind"] + " n." + dettCAttivo.Rows[0]["nestim"] +" / " + dettCAttivo.Rows[0]["yestim"];
                        spezzaScritturaCreditoNoBudget(tabellaIncassoRipartito, importo, idAccCredito, idReg, idUpb, dettCAttivo.Rows[0]["idaccmotive"],
                                            isVariazione, idrelmain, descriptionDet, true);
                        return;
                    }
                }
			}

            string idrelated = "income§" + idinc; //+ "§credit" 15040 tolgo tutto
            if (pGiro) {
                //var idfin= Conn.readValue("incomeyear",q.eq("idinc",idinc) & q.eq("ayear","ayear"), "idfin" )
                idaccmotive = Conn.readValue("finlast", q.eq("idfin", idfin), "idaccmotive");
                DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotive);
                if (contiPrinc.Length > 0) {
                    //in fase di incasso sarà preso il conto dal conto/causale del capitolo finanziario, sempre in caso di autokind null e capitolo su p. di giro
                    idAccCredito = contiPrinc[0]["idacc"];
                }// task 16335
                //In fase di trasm. incasso sarà messo nell'idrelated della chiusura credito l'idinc dell'accertamento, in caso di autokind null e p.di giro
                object idIncFaseUno = Conn.DO_READ_VALUE("incomelink",
                    QHS.AppAnd(QHS.CmpEq("idchild", idinc), QHS.CmpEq("nlevel", 1)), "idparent");
                idrelated = "pgiro§" + idIncFaseUno;
            }

            decimal importoScrittura = // isVariazione ? importoScritturaInDare(importo, idAccCredito, "INCAS") :
                importoScritturaInAvere(importo, idAccCredito, "INCAS");
            EP.EffettuaScritturaIdRelated("INCAS", importoScrittura, idAccCredito, idReg, idUpb, null, idaccmotive,
                idrelated, description);
        }

        decimal sommaImportiNoBudget(Dictionary<string, importo_causale> amounts) {
            if ((amounts == null) || (amounts.Count == 0))
                return 0;
            decimal sum = 0;
            foreach (var k in amounts.Keys) {
                sum += amounts[k].amount;
            }

            return sum;
        }


        Dictionary<int, string> codiceFattura = new Dictionary<int, string>();

        string nomeFattura(DataRow r) {
            string codiceFatt = "";
            if (r["idinvkind"] != DBNull.Value) {
                int idinvkind = CfgFn.GetNoNullInt32(r["idinvkind"]);
                if (codiceFattura.ContainsKey(idinvkind)) {
                    codiceFatt = codiceFattura[idinvkind];
                }
                else {
                    object codFatt = Conn.readValue("invoicekind", q.eq("idinvkind", idinvkind), "codeinvkind");
                    if (codFatt != null) {
                        codiceFatt = codFatt.ToString();
                        codiceFattura[idinvkind] = codiceFatt;
                    }
                }
            }

            return "Fattura " + codiceFatt + " n." + r["ninv"] + " / " + r["yinv"];
        }

        string nomeCPassivo(DataRow r) {
            return "Contratto passivo " + r["idmankind"] + " n." + r["nman"] + " / " + r["yman"];
        }

        string nomeCAttivo(DataRow r) {
            return "Contratto attivo " + r["idestimkind"] + " n." + r["nestim"] + " / " + r["yestim"];
        }

        string nomeParcella(DataRow r) {
            return "Parcella " + " n." + r["ncon"] + " / " + r["ycon"];
        }

        string nomeOccasionale(DataRow r) {
            return "Contratto occasionale " + " n." + r["ncon"] + " / " + r["ycon"];
        }

        string nomeCompensoDipendente(DataRow r) {
            return "Compenso a dipendente " + " n." + r["ncon"] + " / " + r["ycon"];
        }

        string nomeMissione(DataRow r) {
            return "Missione " + " n." + r["nitineration"] + " / " + r["yitineration"];
        }

        string nomeCedolino(DataRow r) {
            DataTable t = Conn.RUN_SELECT("payrollview", "idpayroll,npayroll,fiscalyear,ycon, ncon", null,
                QHS.CmpEq("idpayroll", r["idpayroll"]), null, false);
            if (t.Rows.Count == 0) {
                ShowMessage("Cedolino di id " + r["idpayroll"] + " non trovato.", "Errore", true);
                return "Errore nella ricerca del cedolino";
            }

            DataRow rr = t.Rows[0];
            return $"Cedolino  n.{rr["fiscalyear"]}/{rr["npayroll"]} -Contratto {rr["ycon"]}/{rr["ncon"]}";
        }

        /// <summary>
        /// Genera una scrittura sul debito suddividendolo tra gli impegni di budget in modo opportuno
        /// </summary>
        /// <param name="importoNettoDaSplit"></param>
        /// <param name="importoIvaSplit"></param>
        /// <param name="idAccDebito"></param>
        /// <param name="idAccIvaSplit"></param>
        /// <param name="idReg"></param>
        /// <param name="idUpb"></param>
        /// <param name="idexp">id movimento di spesa del pagamento</param>
        /// <param name="idaccmotive">causale</param>
        /// <param name="isVariazione"></param>
        /// <param name="descrMov"></param>
        /// <returns></returns>
        bool generaScritturaDebito(decimal importoNettoDaSplit,
            decimal importoIvaSplit /* importoRecuperoSplitPaymentCommerciale */,
            object idAccDebito, object idAccIvaSplit,
            object idReg, object idUpb, object idexp, object idaccmotive, bool isVariazione, object descrMov,
            object idfin, bool pGiro,
            object idrelated = null) {
            //QueryCreator.MarkEvent($"importoNettoDaSplit:{importoNettoDaSplit}  importoIvaSplit:{importoIvaSplit} isvariazione:{isVariazione} descrMov:{descrMov} ");
            //Vede se è contabilizzazione fattura
            DataTable dettFattura = Conn.RUN_SELECT("invoicedetailview",
                "invoicekind,yinv,ninv,rownum," +
                "invoicekind_main, yinv_main, ninv_main, rownum_main," +
                "idinvkind, idinvkind_main ,flagbit, " +
                "idepexp,idepacc,taxable_euro,iva_euro,idaccmotive, unabatable_euro,flagvariation,isnull(detaildescription,description) as description",
                null,
                QHS.AppOr(QHS.CmpEq("idexp_taxable", idexp), QHS.CmpEq("idexp_iva", idexp)), null, false);

 

            if (dettFattura != null && dettFattura.Rows.Count > 0) {
                // Lettura eventuale causale di costo dal documento
                DataRow rDettFattura = dettFattura.Rows[0];
                int flagInvoice = CfgFn.GetNoNullInt32(rDettFattura["flagbit"]);
                bool bollaDoganale = ((flagInvoice & 1) != 0);
                bool fatturaSpedizioniere = ((flagInvoice & 2) != 0);
                idaccmotive = rDettFattura["idaccmotive"];
                //var imponibili = new Dictionary<int, importo_causale>();
                //var ivaindet = new Dictionary<int, importo_causale>();
                object description = nomeFattura(dettFattura.Rows[0]);
                //QueryCreator.MarkEvent(description.ToString());
                int movkind =
                    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expenseinvoice", QHS.CmpEq("idexp", idexp), "movkind"));
                double abatablerate = CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("invoicekindyearview",
                    QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idinvkind", dettFattura.Rows[0]["idinvkind"])),
                    "abatablerate"));
                decimal totaleScritto = 0;
                decimal totaleIvaSplitScritto = 0;
                decimal invertiSeVariazione = isVariazione ? -1 : 1;
                foreach (DataRow rDett in dettFattura.Select()) {
                    //QHC.AppOr(QHC.IsNotNull("idepexp"),QHC.IsNotNull("idepacc"))
                    string idrelatedDett =
                        $"inv§{rDett["idinvkind"]}§{rDett["yinv"]}§{rDett["ninv"]}§{rDett["rownum"]}";
                    int attivita = tipoAttivita(rDett["idinvkind"]);
                    bool istituzionale = (attivita == 1);


                    decimal segno = 1;
                    if (rDett["flagvariation"].ToString().ToUpper() == "S") {
                        segno = -1;
                        //Se la NC è collegata ad un dettaglio fattura, il dettaglio scritture dovrà essere valorizzato col dett. fattura madre
                        if ((rDett["rownum_main"] != null) && (rDett["rownum_main"] != DBNull.Value)) {
                         idrelatedDett =
                                $"inv§{rDett["idinvkind_main"]}§{rDett["yinv_main"]}§{rDett["ninv_main"]}§{rDett["rownum_main"]}";
                        }
                    }
                    //else {
                    //    if (isVariazione) segno = -1;
                    //}

                    double imponibile = CfgFn.GetNoNullDouble(rDett["taxable_euro"]);
                    double iva = CfgFn.GetNoNullDouble(rDett["iva_euro"]);
                    double ivaIndetraibileLorda = CfgFn.GetNoNullDouble(rDett["unabatable_euro"]);
                    double ivaDetraibileLorda = iva - ivaIndetraibileLorda;
                    double ivaDetraibile = CfgFn.RoundValuta(ivaDetraibileLorda * abatablerate);
                    double ivaIndetraibile = iva - ivaDetraibile;
                    decimal imponibileDec = Convert.ToDecimal(imponibile);
                    decimal ivaIndetraibileDec = Convert.ToDecimal(ivaIndetraibile);
                    //Se 1 totale 2 tot.iva 3 imponibile  
                    //Se è split va saltata? no
                    if (movkind == 1) { //totale
                        if (importoIvaSplit != 0) {
                            //C'è recupero iva split commerciale
                            var scrittura = singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"],
                                idaccmotive,
                                imponibileDec * segno, idAccDebito, idReg, idUpb, idrelatedDett, isVariazione,
                                description);
                            totaleScritto += scrittura;
                            //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive,imponibileDec * segno);                           
                            //aggiornaImporti(ivaindet, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive, ivaIndetraibileDec * segno);
                        }
                        else {
                            //NON C'è recupero split commerciale
                            if (importoNettoDaSplit != 0) {
                                //L'importo non è completamente stornato
                                var scrittura = singolaScritturaDebitoIdRelated(fatturaSpedizioniere ? DBNull.Value:rDett["idepexp"], rDett["idepacc"],
                                    idaccmotive,
                                    (imponibileDec + ivaIndetraibileDec) * segno, idAccDebito, idReg, idUpb,
                                    idrelatedDett, //  devo sommare le iva indetraibili non posso chiudere un debito senza imp. di budget
                                    isVariazione, description);
                                totaleScritto += scrittura; //+ ivaIndetraibileDec
                                //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive, (imponibileDec)*segno);    //+ ivaIndetraibileDec
                            }
                            else {
                                //storno totale       SIA PER COMMERCIALE CHE PER ISTITUZIONALE stornate totalmente
                                decimal importoPerStornototale =
                                    istituzionale ? imponibileDec + ivaIndetraibileDec : imponibileDec;

                                var scrittura = singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"],
                                    idaccmotive,
                                    importoPerStornototale * segno, idAccDebito, idReg, idUpb, idrelatedDett,
                                    isVariazione, description);


                                totaleScritto += scrittura;
                                //Per il commerciale l'imponibile va sul debito vs fornitori  , tutta l'iva (inclusa iva indetraibile) va su iva a debito
                                //Per l'istituzionale imponibile + iva va su debito vs fornitori
                                //Per l'istituzionale deve  aggiungere anche l'iva indetraibile all'imponibile 


                                //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive, (imponibileDec)*segno);    //+ ivaIndetraibileDec
                            }
                        }
                    }

                    if (movkind == 2) { //solo iva
                        if (importoIvaSplit != 0) {
                     
                            object idclawbackSplitPayment = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "15_SPLIT_PAYMENT"), "idclawback");
                            object idclawbackSplitPaymentComm = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "16_SPLIT_PAYMENT_C"), "idclawback");
                            object idclawbackSplitPaymentIst = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "IVAESTERA_IST"), "idclawback");
                            object idclawbackIvaEstera = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "IVAESTERA_COMM"), "idclawback");
                            List<object> ListRecuperi = new List<object>(
                                new Object[] {idclawbackSplitPayment,idclawbackIvaEstera, idclawbackSplitPaymentComm,idclawbackSplitPaymentIst
                                });

                            //Se c'è associato un incasso di recupero iva split commerciale e non vi sono note di credito contabilizzate da una var movimento
                            //ripartisco l'iva sui singoli dettagli in altrettanti dettagli scrittura su conto di debito opportuno
                            var rContabilizzazioniNoteCredito = Conn.RowObjectSelect("expensevarview", "idexp,idinvkind,yinv,ninv,amount",
                                                                           q.and(q.isNotNull("idinvkind"),
                                                                           q.eq("idexp", idexp)));
                            //IVAESTERA_COMM Recupero IVA estera commerciale

                            var rRecuperi = Conn.RowObjectSelect("incomeview", "idpayment,idinc",
                                                                         q.and(q.eq("autokind", 6),
                                                                               q.eq("autocode", idclawbackIvaEstera),
                                                                               q.eq("idpayment", idexp)));

                            if ((rContabilizzazioniNoteCredito.Count ==0) && (rRecuperi.Count>0)) {
                                decimal importoDaUsareDet = CfgFn.GetNoNullDecimal(rDett["iva_euro"]);
                                var scrittura = singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"],
                                                        idaccmotive,
                                                        importoDaUsareDet * segno, idAccIvaSplit, idReg, idUpb, idrelatedDett, isVariazione,
                                                        description);
                                totaleIvaSplitScritto += scrittura;
                            }
           
                        }
                        else {
                            if (importoNettoDaSplit != 0) {
                                singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"], idaccmotive,
                                    (ivaIndetraibileDec) * segno, idAccDebito, idReg, idUpb, idrelatedDett, //
                                    isVariazione, description);

                                totaleScritto +=
                                    (ivaIndetraibileDec) * segno; //CINZIA TI FACCIO VEDERE CHE... + ivaIndetraibileDec
                                //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive, (imponibileDec)*segno);    //+ ivaIndetraibileDec
                            }
                            else {
                                decimal importoPerStornototale = istituzionale ? ivaIndetraibileDec : 0;
                                //storno totale       SIA PER COMMERCIALE CHE PER ISTITUZIONALE stornate totalmente
                                totaleScritto += singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"],
                                    idaccmotive,
                                    importoPerStornototale * segno, idAccDebito, idReg, idUpb, idrelatedDett,
                                    isVariazione, description);

                                //Per il commerciale non deve fare nulla 
                                //Per l'istituzionale iva va su debito vs fornitori
                                //Per l'istituzionale deve  aggiungere anche l'iva indetraibile all'imponibile 


                            }
                        }

                    }

                    if (movkind == 3) { //imponibile
                        totaleScritto += singolaScritturaDebitoIdRelated(rDett["idepexp"], rDett["idepacc"],
                            idaccmotive,
                            imponibileDec * segno,
                            idAccDebito, idReg, idUpb, idrelatedDett, isVariazione, description);

                        //aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive, imponibileDec * segno);
                    }
                }

                string idrelatedMainInv =
                    $"inv§{rDettFattura["idinvkind"]}§{rDettFattura["yinv"]}§{rDettFattura["ninv"]}";

                //idrelated expense§idexp§debit
                singolaScritturaDebitoIdRelated(DBNull.Value, DBNull.Value, idaccmotive,
                    importoNettoDaSplit - totaleScritto,
                    idAccDebito, idReg, idUpb, idrelatedMainInv, isVariazione, description);
                //bool res = spezzaScritturaDebito(imponibili, importoNettoDaSplit, idAccDebito, idReg, idUpb, idaccmotive, idexp, isVariazione,description,false);

                //rettifica del task 14947 caso 5a ) commerciale - 18630 deve prendere l'idrelated del documento iva CON dettaglio
                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoIvaSplit- totaleIvaSplitScritto, idAccIvaSplit, idReg, "0001", null,
                    idaccmotive, null,
                    null,
                    $"inv§{rDettFattura["idinvkind"]}§{rDettFattura["yinv"]}§{rDettFattura["ninv"]}",
                    description);
                return true;
            }


            decimal importo = importoNettoDaSplit;
            if (importoIvaSplit != 0) {
                ShowMessage(
                    "Attenzione, il movimento di descrizione " + descrMov + " è associato ad un recupero iva split ma "
                    + " non contabilizza una fattura.", "Avviso", false);
                importo += importoIvaSplit;
            }

            object idExpFaseImpegno = Conn.DO_READ_VALUE("expenselink", QHS.AppAnd(QHS.CmpEq("idchild", idexp),
                QHS.CmpEq("nlevel", Conn.GetSys("itinerationphase"))), "idparent");

           
            DataTable dettCPassivo = Conn.RUN_SELECT("expenselastmandatedetailview",
                "idepexp,idaccmotive,amount as totaldebit,originalamount as totaldebitoriginal,nman,yman,rownum,mandatekind,idmankind", null,
                QHS.CmpEq("idexp", idexp), null, false);
            Dictionary<int, importo_causale> tabellaDebito = null;
            Dictionary<string, importo_causale> tabellaPagamentoRipartito = null;
            string idrelmain = null;
            if (UsaImpegniDiBudget) {
                if (dettCPassivo == null || dettCPassivo.Rows.Count == 0) {
                    dettCPassivo = Conn.RUN_SELECT("mandatedetailview",
                     "idepexp,rowtotal as totaldebit,idaccmotive, idmankind,mankind,nman,yman,rownum", null,
                    QHS.AppAnd(QHS.CmpEq("idexp_taxable", idExpFaseImpegno), QHS.IsNull("stop")), null, false);
                    dettCPassivo.Columns.Add("idrelated", typeof(string));
       
                    foreach (DataRow rDet in dettCPassivo.Rows) {
                        rDet["idrelated"] = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}§{rDet["rownum"]}";
                        idrelmain = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}";
 
                    }
                    tabellaDebito = ottieniImportiImpegnoDaTabellaIdrelated(dettCPassivo, "idepexp", "totaldebit", isVariazione);
                }
                else {
                    dettCPassivo.Columns.Add("idrelated", typeof(string));
                    foreach (DataRow rDet in dettCPassivo.Rows) {
                      rDet["idrelated"] = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}§{rDet["rownum"]}";
                        idrelmain = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}";
                    }
                    //Se il conto è flaggato con flagenablebudgetprev=S, allora idepexp sarà valorizzato.
                    DataRow[] RowsCP_withidepexp = dettCPassivo.Select(QHC.IsNotNull("idepexp"));
                    //Serve per fare lo spessaScritturaCredito sui dettagli CP con Imp. di budget
                    tabellaDebito = ottieniImportiImpegnoDaTabellaMovLast(RowsCP_withidepexp, "idepexp", "totaldebit", isVariazione);
                    
                    object descriptionDet = nomeCPassivo(dettCPassivo.Rows[0]);

                    //Se il conto è flaggato con flagenablebudgetprev = N, allora idepexp varrà null.
                    DataRow[] RowsCP_withoutidepexp = dettCPassivo.Select(QHC.IsNull("idepexp"));

                    tabellaPagamentoRipartito = ottieniImportiDaTabellaMovLastNoBudget(RowsCP_withoutidepexp, "idrelated", "totaldebit", isVariazione);
                    //Agisce sui dettagli CP senza Imp. di budget
                    spezzaScritturaDebitoNoBudget(tabellaPagamentoRipartito, importo, idAccDebito, idReg, idUpb, dettCPassivo.Rows[0]["idaccmotive"],
                                        isVariazione, idrelmain, descriptionDet, true);
                }
                if (tabellaDebito != null && tabellaDebito.Count != 0) {
                    object descriptionDet = nomeCPassivo(dettCPassivo.Rows[0]);
                    decimal somma = sommaImportiNoBudget(tabellaPagamentoRipartito);
                    if (isVariazione) {
                        somma = -somma;
                    }
                    importo = importo - somma;//se passa di qui, allora dopo farà il return e non userà più 'importo'
                    return spezzaScritturaDebito(tabellaDebito, importo, idAccDebito, idReg, idUpb, dettCPassivo.Rows[0]["idaccmotive"], isVariazione, idrelmain,
                    descriptionDet,
                    true);
                }
                //Calcola quanto ha ripartito col NoBudget, se ha ripartito tutto, allora esce.
                //Non consideriamo il Budget, ossia tabellaDebito, perchè se questa fosse valorizzata avrebbe chiamato spezzaScritturaDebito() e poi sarebbe uscito.
                decimal RipartitoNoBudget = sommaImportiNoBudget(tabellaPagamentoRipartito);
                if (importo == RipartitoNoBudget) {
                    return true;
                }
                if (isVariazione) {
                    RipartitoNoBudget = -RipartitoNoBudget;
                }
                importo = importo - RipartitoNoBudget;
                
            }
            else {
                if (dettCPassivo != null && dettCPassivo.Rows.Count > 0) {
                    dettCPassivo.Columns.Add("idrelated", typeof(string));
                    foreach (DataRow rDet in dettCPassivo.Rows) {
                        rDet["idrelated"] = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}§{rDet["rownum"]}";
                        idrelmain = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}";
                    }

                    DataRow rdettCPassivo = dettCPassivo.Rows[0];
                    idaccmotive = rdettCPassivo["idaccmotive"];
                    object description = nomeCPassivo(dettCPassivo.Rows[0]);
                    QueryCreator.MarkEvent(description.ToString());
                    //Ripartisce l'importo del movimento di spesa tra i dettagli contabilizzati nell'impegno finanziario
                    // usa la stessa ripartizione del pagamento in expenselastmandatedetail per i dettagli scritture
                    if ((tabellaDebito == null || tabellaDebito.Count == 0) && (!UsaImpegniDiBudget)) {
                        tabellaPagamentoRipartito = ottieniImportiDaTabellaMovLastNoBudget(dettCPassivo.Select(), "idrelated", "totaldebit", isVariazione);
                    }
                    return spezzaScritturaDebitoNoBudget(tabellaPagamentoRipartito, importo, idAccDebito, idReg, idUpb,
                                                 idaccmotive, isVariazione, idrelmain, description, true);
                
                }
			}

            /*
            //Vede se è pagamento di un contratto passivo 
            DataTable dettCPassivo = Conn.RUN_SELECT("mandatedetailview",
                "idepexp,rowtotal as totaldebit,idaccmotive, idmankind,mankind,nman,yman,rownum", null,
                QHS.AppAnd(QHS.CmpEq("idexp_taxable", idExpFaseImpegno), QHS.IsNull("stop")), null, false);
            string idrelmain = null;
            if (dettCPassivo != null && dettCPassivo.Rows.Count > 0) {
                dettCPassivo.Columns.Add("idrelated", typeof(string));
                foreach (DataRow rDet in dettCPassivo.Rows) {
                    rDet["idrelated"] = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}§{rDet["rownum"]}";
                    idrelmain = $"man§{rDet["idmankind"]}§{rDet["yman"]}§{rDet["nman"]}";
                }

                DataRow rdettCPassivo = dettCPassivo.Rows[0];
                idaccmotive = rdettCPassivo["idaccmotive"];
                object description = nomeCPassivo(dettCPassivo.Rows[0]);
                QueryCreator.MarkEvent(description.ToString());
                //QueryCreator.MarkEvent($"Total idepexp {rdettCPassivo["idepexp"]} debit = {rdettCPassivo["totaldebit"]}");
                //Ripartisce l'importo del movimento di spesa tra i dettagli contabilizzati nell'impegno finanziario
                return spezzaScritturaDebito(
                    ottieniImportiImpegnoDaTabellaIdrelated(dettCPassivo, "idepexp", "totaldebit", isVariazione),null,
                    importo,
                    idAccDebito, idReg, idUpb, idaccmotive, isVariazione, idrelmain, description, true);

            }
            */

            //Vede se è pagamento di una prestazione professionale 
            // NO: in questo caso il debito sarà chiuso in fase di pagamento fattura, 
            // mentre per eventuali contributi sarà fatto in fase di liquidazione ritenute
            DataTable contParcella = Conn.RUN_SELECT("expenseprofserviceview", "ycon,ncon,idaccmotive,curramount", null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contParcella != null && contParcella.Rows.Count > 0) {
                DataRow rExpCon = contParcella.Rows[0];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];

                object description = nomeParcella(contParcella.Rows[0]);
                //QueryCreator.MarkEvent(description.ToString());
                DataTable parcella = Conn.RUN_SELECT("profservice", "idinvkind,yinv,ninv,idaccmotive", null,
                    QHS.AppAnd(QHS.CmpEq("ycon", ycon), QHS.CmpEq("ncon", ncon), QHS.IsNotNull("idinvkind")), null,
                    false);
                if (parcella != null && parcella.Rows.Count > 0) {
                    DataRow rParcella = parcella.Rows[0];
                    idaccmotive = rParcella["idaccmotive"];
                    //prende gli impegni di budget dei  dett. fattura ove ne esistano
                    dettFattura = Conn.RUN_SELECT("invoicedetailview",
                        "invoicekind,yinv,ninv,rownum,idexp_taxable,idexp_iva," +
                        "idinvkind,idepexp,taxable_euro,iva_euro,idaccmotive, unabatable_euro,flagvariation,isnull(detaildescription,description) as description",
                        null,
                        QHS.AppAnd(
                            QHS.CmpEq("idinvkind", rParcella["idinvkind"]), QHS.CmpEq("yinv", rParcella["yinv"]),
                            QHS.CmpEq("ninv", rParcella["ninv"])
                        ),
                        null, false);

                    if (dettFattura != null && dettFattura.Rows.Count > 0) {
                        DataRow rdettFattura = dettFattura.Rows[0];
                        if (idaccmotive == DBNull.Value || idaccmotive == null) {
                            idaccmotive = rdettFattura["idaccmotive"];
                        }

                        string idrelmainInvoice =
                            $"inv§{rdettFattura["idinvkind"]}§{rdettFattura["yinv"]}§{rdettFattura["ninv"]}";
                        var imponibili = new Dictionary<int, importo_causale>();
                        var ivaindet = new Dictionary<int, importo_causale>();
                        object descrFatt = nomeFattura(dettFattura.Rows[0]);
                        //"Fattura " + dettFattura.Rows[0]["invoicekind"] + " n." +dettFattura.Rows[0]["ninv"] +" / " + dettFattura.Rows[0]["yinv"];
                        //QueryCreator.MarkEvent(descrFatt.ToString());
                        double abatablerate = CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("invoicekindyearview",
                            QHS.AppAnd(QHS.CmpEq("ayear", esercizio),
                                QHS.CmpEq("idinvkind", dettFattura.Rows[0]["idinvkind"])), "abatablerate"));
                        bool riproporzionaDettagli = true;
                        string filterDetails = null;
                        if (UsaImpegniDiBudget) { 
                              filterDetails = QHC.IsNotNull("idepexp");
                        }
                        foreach (DataRow rDett in dettFattura.Select(filterDetails )) {
                            //QueryCreator.MarkEvent("Dettagli collegati");
                            if (rdettFattura["idexp_taxable"] != DBNull.Value ||
                                rdettFattura["idexp_iva"] != DBNull.Value) riproporzionaDettagli = false;
                            decimal segno = 1;
                            // Se nota di credito
                            if (rDett["flagvariation"].ToString().ToUpper() == "S") {
                                segno = -1;
                            }

                            double imponibile = CfgFn.GetNoNullDouble(rDett["taxable_euro"]);
                            double iva = CfgFn.GetNoNullDouble(rDett["iva_euro"]);
                            double ivaIndetraibileLorda = CfgFn.GetNoNullDouble(rDett["unabatable_euro"]);
                            double ivaDetraibileLorda = iva - ivaIndetraibileLorda;
                            double ivaDetraibile = CfgFn.RoundValuta(ivaDetraibileLorda * abatablerate);
                            double ivaIndetraibile = iva - ivaDetraibile;
                            decimal imponibileDec = Convert.ToDecimal(imponibile);
                            decimal ivaIndetraibileDec = Convert.ToDecimal(ivaIndetraibile);

                            if (rDett["idepexp"]!=DBNull.Value)
                                aggiornaImporti(imponibili, CfgFn.GetNoNullInt32(rDett["idepexp"]), idaccmotive,
                                    (imponibileDec + ivaIndetraibileDec) * segno,
                                    $"inv§{rDett["idinvkind"]}§{rDett["yinv"]}§{rDett["ninv"]}§{rDett["rownum"]}");
                            else {
                                // se non c'è impegno di budget su dettaglio crea direttamente una scrittura su conto debito
                                // per questo dettaglio fattura non valorizzando idepexp, l'importo sarà in Dare o in avere a seconda se 
                                // si tratta di una distinta normale o di variazione /annullamento
                                decimal importoscrittD = isVariazione  ? importoScritturaInAvere((imponibileDec + ivaIndetraibileDec) * segno, idAccDebito, "PAGAM"): 

                                importoScritturaInDare((imponibileDec + ivaIndetraibileDec) * segno, idAccDebito, "PAGAM");
                                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoscrittD, 
                                    idAccDebito, idReg, idUpb, null,
                                    idaccmotive, null,
                                    null,
                                    $"inv§{rDett["idinvkind"]}§{rDett["yinv"]}§{rDett["ninv"]}§{rDett["rownum"]}", descrFatt);
							    }

                        }
                 
                        if (imponibili._HasRows()) // se ci sono impegni di budget sui dettagli fattura esaminati
                            // crea una scrittura ripartita
                            // sulla base della tabella di ripartizione imponibili che ha riempito ciclando sui dettagli fattura
                            return spezzaScritturaDebito(imponibili, importoNettoDaSplit, idAccDebito, idReg, idUpb,
                                idaccmotive, isVariazione, idrelmainInvoice, descrFatt, riproporzionaDettagli);
                        return true;
                    }
                }

                string idRelatedConn = _composeObjects("profservice", ycon, ncon);
                string filter = "((idrelated LIKE '" + idRelatedConn + "§%' AND NOT idrelated LIKE '" + idRelatedConn +
                                "§RITEN§%')OR(" + QHS.CmpEq("idrelated", idRelatedConn) + "))";

                DataTable impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                    "idepexp,idaccmotive,idrelated,totcurramount as totaldebit",
                    null, QHS.AppAnd(filter, QHS.CmpEq("nphase", 2)), null, false); //QHS.CmpEq("ayear", esercizio),
                if (impegniBudget.Rows.Count > 0) {
                    return spezzaScritturaDebito(
                        ottieniImportiImpegnoDaTabellaIdrelated(impegniBudget, "idepexp", "totaldebit", isVariazione), importo,
                        idAccDebito, idReg, idUpb, idaccmotive, isVariazione, null, description, true);
                }
                //Caso residuale: Chiude direttamente il debito della parcella, qualora non sia riuscito nè a trovare fatture 
                //nè a chiudere il debito sulle fatture. Forse questo caso è superato da anni, ma lo teniamo ancora
                //se isVariazione importo è già negativo, non c'è bisogno di invertire con importoScritturaInAvere
                decimal importoScritturaD = //isVariazione  ? importoScritturaInAvere(importo, idAccDebito, "PAGAM"): 
                    importoScritturaInDare(importo, idAccDebito, "PAGAM");
                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScritturaD, idAccDebito, idReg, idUpb, null,
                    idaccmotive, null,
                    null,
                    idRelatedConn, description); //+ ""expense§" + idexp      §debit" 15040 rimuovo  
                return true;
            }



            //Vede se è pagamento di una prestazione occasionale 
            //gli impegni di budget ad essa associati possono essere di tipo CASCON, CASCON-RITEN e CASCON-SPESA.
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            DataTable contOccasionale = Conn.RUN_SELECT("expensecasualcontractview", "ycon,ncon,idaccmotive,curramount",
                null,
                QHS.CmpEq("idexp", idExpFaseImpegno), null, false);
            if (contOccasionale != null && contOccasionale.Rows.Count > 0) {
                DataRow rExpCon = contOccasionale.Rows[0];
                idaccmotive = rExpCon["idaccmotive"];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];

                object description = nomeOccasionale(rExpCon);
                string idRelatedConn = _composeObjects("cascon", ycon, ncon);
                string filter = "((idrelated LIKE '" + idRelatedConn + "§%' AND NOT idrelated LIKE '" + idRelatedConn +
                                "§RITEN§%')OR(" + QHS.CmpEq("idrelated", idRelatedConn) + "))";

                DataTable impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                    "idepexp, idaccmotive,idrelated,totcurramount as totaldebit ",
                    null, QHS.AppAnd(filter, QHS.CmpEq("nphase", 2)), null, null,
                    false); //QHS.CmpEq("ayear", esercizio),

                if (impegniBudget.Rows.Count > 0) {
                    return spezzaScritturaDebito(
                        ottieniImportiImpegnoDaTabellaIdrelated(impegniBudget, "idepexp", "totaldebit", isVariazione), importo,
                        idAccDebito, idReg, idUpb, idaccmotive, isVariazione, null, description, true);
                }

                decimal importoScritturaDD = // isVariazione ? importoScritturaInAvere(importo, idAccDebito, "PAGAM"):
                    importoScritturaInDare(importo, idAccDebito, "PAGAM");
                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScritturaDD, idAccDebito, idReg, idUpb, null,
                    idaccmotive, null,
                    null,
                    idRelatedConn, description); //+ "§debit"  15040 rimuovo    "expense§" + idexp 
                return true;
            }

            //Vede se è pagamento di una prestazione dipendente 
            //gli impegni di budget ad essa associati possono essere di tipo CASCON, CASCON-RITEN e CASCON-SPESA.
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            DataTable contWageAdd = Conn.RUN_SELECT("expensewageadditionview", "ycon,ncon,idaccmotive,curramount", null,
                QHS.AppAnd(QHS.CmpEq("idexp", idExpFaseImpegno), QHS.CmpEq("ayear", esercizio)), null, false);
            if (contWageAdd != null && contWageAdd.Rows.Count > 0) {
                DataRow rExpCon = contWageAdd.Rows[0];
                idaccmotive = rExpCon["idaccmotive"];
                object ycon = rExpCon["ycon"];
                object ncon = rExpCon["ncon"];
                object description = nomeCompensoDipendente(rExpCon);

                string idRelatedConn = _composeObjects("wageadd", ycon, ncon);
                string filter = "((idrelated LIKE '" + idRelatedConn + "§%' AND NOT idrelated LIKE '" + idRelatedConn +
                                "§RITEN§%')OR(" + QHS.CmpEq("idrelated", idRelatedConn) + "))";
                return effettuaScritturaSuElencoImpegni(filter, importo, idAccDebito, idReg, idUpb, idaccmotive,
                    isVariazione, idRelatedConn, description);
            }

            //Vede se è pagamento di una missione
            //gli impegni di budget ad essa associati possono essere di tipo anticipo o saldo, ma i debiti sugli anticipi non possono essere collegati
            //    a impegni "provvisori", quindi le scritture sui debiti relativi ad anticipi dovrebbero avere la stessa causale della missione
            // Alternativamente non è possibile movimentare anticipi su cap. di spesa se si usano causali di anticipo specifiche. La chiusura di 
            //  debiti per anticipi su partite di giro non è associata ad impegni di budget
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            // 4 "Pagamento o saldo della missione"
            // 5 "Anticipo della missione su partita di giro"
            // 6 "Anticipo della missione sul capitolo di spesa"
            DataTable contItineration = Conn.RUN_SELECT("expenseitinerationview",
                "iditineration,yitineration,nitineration,idaccmotive,curramount",
                null,
                QHS.AppAnd(QHS.CmpEq("idexp", idExpFaseImpegno), QHS.CmpEq("ayear", esercizio),
                    QHS.CmpNe("movkind", 5)),
                null, false);
            if (contItineration != null && contItineration.Rows.Count > 0) {
                DataRow rExpCon = contItineration.Rows[0];
                idaccmotive = rExpCon["idaccmotive"];
                object iditineration = rExpCon["iditineration"];
                object yitineration = rExpCon["yitineration"];
                object nitineration = rExpCon["nitineration"];
                object description = nomeMissione(rExpCon);

                string idRelatedConn = _composeObjects("itineration", iditineration);
                string filter = "((idrelated LIKE '" + idRelatedConn + "§%' AND NOT idrelated LIKE '" + idRelatedConn +
                                "§RITEN§%')OR(" + QHS.CmpEq("idrelated", idRelatedConn) + "))";
                return effettuaScritturaSuElencoImpegni(filter, importo, idAccDebito, idReg, idUpb, idaccmotive,
                    isVariazione, idRelatedConn, descrMov);
            }

            //Vede se è pagamento di un cedolino
            //gli impegni di budget ad essa associati possono essere di tipo CASCON, CASCON-RITEN e CASCON-SPESA.
            //In questa sede dobbiamo saltare quelli di tipo RITEN ove presenti
            DataTable contPayroll = Conn.RUN_SELECT("expensepayrollview",
                "idcon, description,idpayroll,idaccmotive,curramount", null,
                QHS.AppAnd(QHS.CmpEq("idexp", idExpFaseImpegno), QHS.CmpEq("ayear", esercizio)), null, false);
            if (contPayroll != null && contPayroll.Rows.Count > 0) {
                DataRow rExpCon = contPayroll.Rows[0];
                idaccmotive = rExpCon["idaccmotive"];
                object description = nomeCedolino(rExpCon); //rExpCon["description"];
                object idpayroll = rExpCon["idpayroll"];
                string idRelatedConn = _composeObjects("payroll", idpayroll);
                string filter = "((idrelated LIKE '" + idRelatedConn + "§%' AND NOT idrelated LIKE '" + idRelatedConn +
                                "§RITEN§%')OR(" + QHS.CmpEq("idrelated", idRelatedConn) + "))";
                return effettuaScritturaSuElencoImpegni(filter, importo, idAccDebito, idReg, idUpb, idaccmotive,
                    isVariazione, idRelatedConn, description);
            }
            if (idrelated == null) {
                idrelated = "expense§" + idexp; //+ "§debit"  15040 rimuovo
            }
            if (pGiro) {
                //var idfin= Conn.readValue("incomeyear",q.eq("idinc",idinc) & q.eq("ayear","ayear"), "idfin" )
                idaccmotive = Conn.readValue("finlast", q.eq("idfin", idfin), "idaccmotive");
                DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotive);
                if (contiPrinc.Length > 0) {
                    //in fase di incasso sarà preso il conto dal conto/causale del capitolo finanziario, sempre in caso di autokind null e capitolo su p. di giro
                    idAccDebito = contiPrinc[0]["idacc"];
                }//16335
                object idExpFaseUno = Conn.DO_READ_VALUE("expenselink",
                    QHS.AppAnd(QHS.CmpEq("idchild", idexp), QHS.CmpEq("nlevel", 1)), "idparent");
                //In fase di trasm. incasso sarà messo nell'idrelated della chiusura credito l'idinc dell'accertamento, in caso di autokind null e p.di giro
                object idIncLinked =
                    Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", idExpFaseUno), "idinc_linked");
                if ((idIncLinked != null) &&(idIncLinked!=DBNull.Value)){
                    idrelated = "pgiro§" + idIncLinked;
                }
            }

            //Senza documento
            decimal importoScrittura = //isVariazione  ? importoScritturaInAvere(importo, idAccDebito, "PAGAM") : 
                importoScritturaInDare(importo, idAccDebito, "PAGAM");
            EP.EffettuaScritturaIdRelated("PAGAM", importoScrittura, idAccDebito, idReg, idUpb, null, idaccmotive,
                idrelated.ToString(), descrMov);
            return true;
        }

        void aggiornaImporti(Dictionary<int, importo_causale> valori, int id, object idaccmotive, decimal valore,
            string idrelated) {
            if (valori.ContainsKey(id)) {
                var c = valori[id];
                c.amount += valore;
            }
            else {
                valori[id] = new importo_causale(valore, idaccmotive, idrelated);
            }
        }

        /// <summary>
        /// Verifica se la missione è ancora in fase di anticipo
        /// </summary>
        /// <param name="itineration"></param>
        /// <returns></returns>
        private bool getFaseAnticipoMissione(DataRow itineration) {
            if (itineration == null || itineration.RowState == DataRowState.Deleted) return true;
            if (itineration["start"] == DBNull.Value) return true;
            DateTime start = (DateTime) itineration["start"];

            //if (datacontabile < (DateTime)datainizio) phase = true;
            if (DateSys < start) return true;
            if ((DateTime) Conn.GetSys("datacontabile") < (DateTime) itineration["start"]) return true;
            return false;
        }


        private bool getRealFaseAnticipoMissione(DataRow itineration) {
            if (itineration == null || itineration.RowState == DataRowState.Deleted) return true;
            if (itineration["start"] == DBNull.Value) return true;
            DateTime start = (DateTime) itineration["start"];

            //if (datacontabile < (DateTime)datainizio) phase = true;
            if (DateSys < start) return true;
            return false;
        }
        ///// <summary>
        ///// Verifica se la missione è stata inserita da web
        ///// </summary>
        ///// <param name="curr"></param>
        ///// <returns></returns>
        //bool checkWeb(DataRow curr) {
        //    if (curr==null) return true;
        //    if (curr.RowState ==DataRowState.Added) return false;
        //    object flagweb = curr["flagweb"];

        //    if (flagweb != DBNull.Value) {
        //        return (flagweb.ToString().ToUpper() == "S");
        //    }
        //    return false;
        //}


        bool effettuaScritturaSuElencoImpegni(string filter, decimal importo, object idAccDebito, object idReg,
            object idUpb,
            object idAccMotive, bool isVariazione, string idrelMain, object description = null) {

            DataTable impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                "idepexp,idaccmotive,idrelated, totcurramount as totaldebit ",
                null, QHS.AppAnd(filter, QHS.CmpEq("nphase", 2)), null, null, false); //QHS.CmpEq("ayear", esercizio),
            //string idrelated = "expense§" + idexp ;//+ "§debit"  15040 rimuovo
            if (impegniBudget.Rows.Count > 0) {
                return spezzaScritturaDebito(
                    ottieniImportiImpegnoDaTabellaIdrelated(impegniBudget, "idepexp", "totaldebit", isVariazione), importo,
                    idAccDebito, idReg, idUpb, idAccMotive, isVariazione, idrelMain, description, true);
            }
            else {
                //Se variazione importo è già negativo, inutile cambiarlo da capo di segno
                decimal importoScrittura = //isVariazione ? importoScritturaInAvere(importo, idAccDebito, "PAGAM") :
                    importoScritturaInDare(importo, idAccDebito, "PAGAM");

                EP.EffettuaScritturaImpegnoBudget("PAGAM", importoScrittura, idAccDebito, idReg, idUpb, null,
                    idAccMotive, null,
                    null, idrelMain, description);
                return true;
            }

        }

        static string _composeObjects(params object[] o) {
            if (o == null) return null;
            if (o.Length == 0) return null;
            string res = "";
            foreach (object oo in o) {
                if (res != "") res += "§";
                res += oo.ToString();
            }

            return res;
        }

        private bool generaScrittureElencoTrasmIncasso(DataRow curr, BudgetFunction bf) {

            if (curr["noep"].ToString() == "S") return false;
            if (curr["transmissiondate"] == DBNull.Value) return false;

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            //Il conto banca è quello di presentazione documenti alla banca oppure se non configurato è quello di pagamento alla banca
            object idaccProceeds = _rConfig["idacc_bankprodoc"];
            //Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", esercizio), "idacc_bankprodoc");

            if (idaccProceeds == DBNull.Value) {
                idaccProceeds = getAccountTreasurer(curr["idtreasurer"], "C");
                if (idaccProceeds == DBNull.Value) {
                    return false;
                }
            }

            string filterEserc = QHS.CmpEq("ayear", esercizio);
            DataTable pSpeseSetup = Conn.RUN_SELECT("pettycashsetup", "*", null, filterEserc, null, true);

            DateTime dataRiferimento = (DateTime) curr["transmissiondate"];
            string descrFase = "";
            object faseObj = Conn.DO_READ_VALUE("incomephase", QHS.CmpEq("nphase", Conn.GetSys("maxincomephase")),
                "description");
            if (faseObj != null) descrFase = faseObj.ToString();

            object doc = "Dist. Trasm. Reversali " + curr["yproceedstransmission"] + "/" +
                         curr["nproceedstransmission"];
            DataRow mainEntry = EP.SetUniqueEntry(doc, dataRiferimento, doc, curr["transmissiondate"],
                EP_functions.GetIdForDocument(curr));
            DataTable tTreasurer = Conn.RUN_SELECT("treasurer", "*", null,
                QHS.CmpEq("idtreasurer", curr["idtreasurer"]), null, true);
            if (tTreasurer == null || tTreasurer.Rows.Count == 0) {
                ShowMessage("Il tesoriere non è stato selezionato", "Errore");
                return false;
            }

            DataRow rTreasuer = tTreasurer.Rows[0];
            CopySecurity(rTreasuer, mainEntry);
            EP.ClearDetails(mainEntry);

            //Conto per i crediti da debitori
            object idAccFornitore = EP.GetAccountForSupplier();
            object idAccIvaRefund = EP.GetAccountForIvaRefund();
            object idAccIvaRefundInternal = EP.GetAccountForMainIvaRefundInternal();
            object idAccIvaRefundExternal = EP.GetAccountForMainIvaRefund();

            string filtroReversali = QHC.IsNotNull("kproceedstransmission");
            string filtroVariazioni = QHC.IsNotNull("kproceedstransmission");

            DataTable tProceeds;
            if (DS.Tables.Contains("proceeds")) {
                tProceeds = DS.Tables["proceeds"];
            }
            else {
                if (DS.Tables.Contains("proceedsview")) {
                    tProceeds = DS.Tables["proceedsview"];
                }
                else {
                    tProceeds = Conn.RUN_SELECT("proceeds", "*", null, QHS.CmpKey(curr), null, false);
                }
            }

            DataTable tVar = null;
            if (DS.Tables.Contains("incomevarview")) {
                tVar = DS.Tables["incomevarview"];
            }
            else {
                tVar = Conn.RUN_SELECT("incomevarview", "*", null, QHS.CmpKey(curr), null, false);
            }

            DataRow[] rReversali = tProceeds.Select(filtroReversali);
            DataRow[] rVariazioni = tVar.Select(filtroVariazioni);

            DataTable tClawBackSetup = Conn.RUN_SELECT("clawbacksetupview", "idclawback,idaccmotive,idreg", null,
                filterEserc, null, true);
            List<int> listaMovIncasso = new List<int>();

            // Se ci sono reversali allora ha senso inserire(modificare) i dettagli scrittura 
            // altrimenti i dettagli resteranno impostati a zero e, quindi, verranno cancellati
            if (rReversali.Length > 0) {
                string filterreve = QHS.AppAnd(filterEserc,
                    QHS.CmpEq("ypro", esercizio),
                    QHS.FieldIn("npro", rReversali));
                DataTable tEntrata = Conn.RUN_SELECT("incomeview",
                    "idinc,ymov, nmov, ypro, npro,amount,idreg,idupb,autokind, autocode,idpayment,idacccredit,description,finflag,idfin",
                    null, filterreve, null, true);



                foreach (DataRow rIncasso in tEntrata.Rows) {
                    string idrelated = "income§" + rIncasso["idinc"];
                    listaMovIncasso.Add(CfgFn.GetNoNullInt32(rIncasso["idinc"]));

                    // Scritture sull'incasso
                    object idAccCliente = rIncasso["idacccredit"];
                    bool contoCreditoreBloccato = idAccCliente != DBNull.Value;
                    object idAccClientenoMov = EP.GetCustomerAccountForRegistry(null, rIncasso["idreg"]);

                    if (idAccCliente == DBNull.Value)
                        idAccCliente = idAccClientenoMov;


                    decimal importo = CfgFn.GetNoNullDecimal(rIncasso["amount"]);
                    decimal variazioni = CfgFn.GetNoNullDecimal(Conn.DO_READ_VALUE("incomevar",
                        QHS.AppAnd(QHS.CmpEq("yvar", Conn.GetEsercizio()), QHS.CmpEq("idinc", rIncasso["idinc"]),
                            QHS.CmpLe("adate", dataRiferimento), QHS.IsNull("kproceedstransmission")),
                        "sum(amount)", null));
                    importo += variazioni;

                    string idrelatedCredit = "income§" + rIncasso["idinc"]; //+ "§credit" 15040 tolgo tutto
                    byte autokind = CfgFn.GetNoNullByte(rIncasso["autokind"]);
                    int autocode = CfgFn.GetNoNullInt32(rIncasso["autocode"]);


                    string descrdet = descrFase + " n° " + rIncasso["nmov"].ToString() + "/" +
                                      rIncasso["ymov"].ToString() +
                                      " Revers. " + " n° " + rIncasso["npro"].ToString() + "/" +
                                      rIncasso["ypro"].ToString();
                    switch (autokind) {
                        case 7:
                            //Chiusura Fondo Piccole Spese
                            object codicefps = rIncasso["autocode"];
                            DataRow fpsRow = null;
                            if (codicefps == DBNull.Value) {
                                DataRow[] fpsRows = pSpeseSetup.Select();
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }
                            else {
                                DataRow[] fpsRows = pSpeseSetup.Select(QHC.CmpEq("idpettycash", codicefps));
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }

                            object idaccmotiveFps = DBNull.Value;
                            decimal importofornitore = importo;
                            if ((fpsRow != null) && (fpsRow["idacc"] != DBNull.Value)) {
                                idAccFornitore = fpsRow["idacc"];
                                importofornitore = -importo;
                            }

                            // A questo punto genera la scrittura da  banca	a credito
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds, rIncasso["idreg"],
                                rIncasso["idupb"], null, idaccmotiveFps, idrelated, descrdet);

                            //14947 mettere idrelated simile a foeco§codice fondo invece di idrelDebit, analogamente nelle distinte incasso
                            EP.EffettuaScritturaIdRelated("INCAS", importofornitore, idAccFornitore,
                                rIncasso["idreg"], rIncasso["idupb"], null, idaccmotiveFps, "foeco§" + autocode,
                                descrdet);
                            break;
                        case 15: {
                            //Liquidazione IVA Consolidata INTERNA  OBSOLETO
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefundInternal,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 16: {
                            //Liquidazione IVA Consolidata ESTERNA  OBSOLETO
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefundExternal,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 12: {
                            if (usaContiPresentazioneDocumenti) break;
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefund,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 4: {
                            //14910 idrelated di incassi ritenute e contributi: 
                            //   idrelated di incassi ritenute e contributi: mettere idexp (del pagamento principale)+codice ritenuta/contributo


                            //Ritenute/Contributi
                            object myAccFornitore = idAccFornitore;


                            //Si tratta di un contributo
                            object codicerit = rIncasso["autocode"];
                            int taxcode = CfgFn.GetNoNullInt32(codicerit);
                            object idser = Conn.DO_READ_VALUE("expenselast", QHS.CmpEq("idexp", rIncasso["idpayment"]),
                                "idser");
                            string idrelatedDebitoContoErario =
                                "ritenuta§" + rIncasso["idpayment"].ToString() + "§" + codicerit.ToString();

                            TaxInfo tax = TaxInfo.getInfo(taxInfo, taxcode);
                            if (tax == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + taxcode + " non è il codice di una ritenuta esistente", "Errore");
                                return false;
                            }

                            DataRow motiveRow = tax.getInfo(CfgFn.GetNoNullInt32(idser));
                            if (motiveRow == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + tax.taxRef() +
                                    " non è il codice di una ritenuta configurata per l'EP.", "Errore");
                                return false;
                            }


                            //Deve effettuare la scrittura	Banca -> Debito vs erario 
                            //		o						Banca -> Debito generico 
                            object idaccmotive = motiveRow["idaccmotive_pay"];
                            if (idaccmotive != DBNull.Value) {
                                DataRow[] contiPay = EP.GetAccMotiveDetails(idaccmotive);
                                if (contiPay.Length > 0) {
                                    myAccFornitore = contiPay[0]["idacc"];
                                }
                            }

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, idaccmotive, idrelated, descrdet);
                            DataTable regs = _teh.GetIdRegFor(codicerit, rIncasso["idpayment"]);
                            foreach (DataRow rr in regs.Rows) {
                                decimal amountToConsider = importo * CfgFn.GetNoNullDecimal(rr["quota"]);
                                int idregToConsider = CfgFn.GetNoNullInt32(rr["idreg"]);
                                EP.EffettuaScritturaIdRelated("INCAS", amountToConsider, myAccFornitore,
                                    idregToConsider, // era:  rIncasso["idreg"], 
                                    rIncasso["idupb"], null, idaccmotive, idrelatedDebitoContoErario, descrdet);
                            }

                            break;
                        }

                        case 6: {
                            //14947 Usare sempre l'idrelated del documento e NON del dettagli nel caso di recuperi su fatture
                            //bisogna andare sul pagamento principale, vedere se è una fattura e in quel caso prendere quell'idrelated
                            if (rIncasso["idpayment"] != DBNull.Value) {
                                var rFattura = Conn.RowObjectSelect("expenseinvoice", "idexp,idinvkind,yinv,ninv",
                                    q.eq("idexp", rIncasso["idpayment"]))?.FirstOrDefault();
                              
                                    if (rFattura != null) {
                                    idrelatedCredit =
                                        $"inv§{rFattura["idinvkind"]}§{rFattura["yinv"]}§{rFattura["ninv"]}";

                                       
                            }

                            object idReg = rIncasso["idreg"];
                            object codiceRecupero = rIncasso["autocode"];
                            string filterRecupero = QHC.CmpEq("idclawback", codiceRecupero);
                            DataRow[] clawBackSetup = tClawBackSetup.Select(filterRecupero);
                            object idaccRecupero = idAccCliente;
                            object idaccmotiveCb = null;
                            object idregDebito = rIncasso["idreg"];
                            if (clawBackSetup.Length > 0) {
                                DataRow rClawBackSetup = clawBackSetup[0];
                                idaccmotiveCb = rClawBackSetup["idaccmotive"];
                                DataRow[] rContoRecupero = EP.GetAccMotiveDetails(idaccmotiveCb);
                                if (rContoRecupero.Length > 0) {
                                    if (!contoCreditoreBloccato) {
                                        idaccRecupero = rContoRecupero[0]["idacc"];
                                    }
                                }

                                if (clawBackSetup[0]["idreg"] != DBNull.Value) {
                                    idregDebito = clawBackSetup[0]["idreg"];
                                }

                            }
                            

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                idregDebito, //rIncasso["idreg"], task 12522
                                rIncasso["idupb"],
                                null, null, idrelated, descrdet);

                            decimal segnoPrimoDettaglio =
                                EP.signForAccount(idaccProceeds, "INCAS"); //segno del dettaglio precedente
                            decimal segnoSecondoDettaglio = EP.signForAccount(idaccRecupero, "INCAS");
                            decimal importoDaUsare = importo;
                            if (segnoSecondoDettaglio == segnoPrimoDettaglio) importoDaUsare = -importo;

                            object idclawback = codiceRecupero;
                                object idclawbackSplitPayment = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "15_SPLIT_PAYMENT"), "idclawback");
                                object idclawbackSplitPaymentComm = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "16_SPLIT_PAYMENT_C"), "idclawback");
                                object idclawbackSplitPaymentIst = Conn.DO_READ_VALUE("clawback", QHS.CmpEq("clawbackref", "IVAESTERA_IST"), "idclawback");
                                object idclawbackIvaEstera = Conn.DO_READ_VALUE("clawback",QHS.CmpEq("clawbackref", "IVAESTERA_COMM"), "idclawback");
                                List<object> ListRecuperi = new List<object>(
                                    new Object[] {idclawbackSplitPayment,idclawbackIvaEstera, idclawbackSplitPaymentComm,idclawbackSplitPaymentIst
                                    });
                                var rDettFattura = Conn.RowObjectSelect("invoicedetailview", "idexp_taxable,idinvkind,yinv,ninv,rownum, tax",
                                    q.and(q.eq("flagvariation","N"),q.eq("idexp_taxable", rIncasso["idpayment"]) | q.eq("idexp_iva", rIncasso["idpayment"]))
                                    );

                               var rContabilizzazioniNoteCredito = Conn.RowObjectSelect("expensevarview", "idexp,idinvkind,yinv,ninv,amount",
                                                                           q.and( q.isNotNull("idinvkind"),
                                                                           q.eq("idexp", rIncasso["idpayment"]) | q.eq("idexp", rIncasso["idpayment"])));

                                    // in presenza di note di credito contabilizate dal pagamento principale ci colleghiamo invece al documento iva principale
                                    if ((rDettFattura.Count == 0)||(rContabilizzazioniNoteCredito.Count >0)) {
                                        if ((idclawback != null) && (idclawback != DBNull.Value) && (ListRecuperi.Contains(idclawback))) {
                                            EP.EffettuaScritturaIdRelated("INCAS", importoDaUsare, idaccRecupero,
                                            idregDebito, rIncasso["idupb"], null, idaccmotiveCb, idrelatedCredit, descrdet);
                                        }
                                        else {
                                            EP.EffettuaScritturaIdRelated("INCAS", importoDaUsare, idaccRecupero,
                                                idregDebito, rIncasso["idupb"], null, idaccmotiveCb, //idrelatedCredit, 
                                                $"recupero§{idclawback}",
                                                descrdet);
                                        }
                                    }
                                    // se il recupero si riferisce all'iva di una fattura split genero scrittura diversamente
                                    // specificando i singoli dettagli, questo in assenza di note di credito
                                    else {
                                        // in assenza di note di credito
                                        if ((idclawback != null) && (idclawback != DBNull.Value) && (ListRecuperi.Contains(idclawback))) {
                                            foreach (var rDet in rDettFattura) {
                                            string idrelatedCreditDet =
                                            $"inv§{rDet["idinvkind"]}§{rDet["yinv"]}§{rDet["ninv"]}§{rDet["rownum"]}";
                                            decimal importoDaUsareDet = CfgFn.GetNoNullDecimal(rDet["tax"]);

                                             EP.EffettuaScritturaIdRelated("INCAS", importoDaUsareDet, idaccRecupero,
                                             idregDebito, rIncasso["idupb"], null, idaccmotiveCb, idrelatedCreditDet, descrdet);
                                            }
                                        }
                                        else
                                        EP.EffettuaScritturaIdRelated("INCAS", importoDaUsare, idaccRecupero,
                                                    idregDebito, rIncasso["idupb"], null, idaccmotiveCb, //idrelatedCredit, 
                                                    $"recupero§{idclawback}",
                                                    descrdet);
                                        }

                                       

                                    }
                               
                            //qui dovrebbe usare l'anagrafica del recupero ove presente, va creato un campo in clawbacksetup
                            break;
                        }

                        case 31: { //Nuovi versamenti CSA
                            if (!generaScrittureIncassoVerPartition(EP, rIncasso["idinc"], rIncasso["idreg"], idaccProceeds,false))
                                return false;
                            break;
                        }

                        case 30: { //Nuovi riepiloghi CSA
                            if (!generaScrittureIncassoRiepPartition(EP, rIncasso["idinc"], rIncasso["idreg"], idaccProceeds,false))
                                return false;
                            break;
                        }

                        case 20: {
                            if (usaContiPresentazioneDocumenti) break;

                            EP.EffettuaScrittura("INCAS", importo, idaccProceeds, rIncasso["idreg"], rIncasso["idupb"],
                                null, null, null, null, descrdet);

                            object idregToConsider = rIncasso["idreg"]; // prendo la stessa anagrafica sui due dettagli
                            if (autocode != 0) {
                                // prendo l'anagrafica associata all'ente CSA 
                                idregToConsider = Conn.DO_READ_VALUE("csa_agency", QHS.CmpEq("idcsa_agency", autocode),
                                    "idreg");
                            }

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idAccCliente, idregToConsider,
                                rIncasso["idupb"], null, null, idrelated, descrdet);
                            // EP.EffettuaScritturaIdRelated("INCAS", importo, idAccCredito, idReg, idUpb, null, idaccmotive, "income§" + idinc + "§credit",description);
                            break;
                        }

                        default: {
                            if (autokind == 21 && usaContiPresentazioneDocumenti) break;
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);

                            bool isPGiro = (CfgFn.GetNoNullInt32(rIncasso["finflag"]) & 2) != 0;
                            generaScritturaCredito(importo,
                                idAccCliente, rIncasso["idreg"], rIncasso["idupb"], rIncasso["idinc"], null, false,
                                rIncasso["description"], rIncasso["idfin"], isPGiro);
                            break;
                        }
                    }
                }
            }

            if (rVariazioni.Length > 0) {
                foreach (DataRow rVar in rVariazioni) {
                    int idinc = CfgFn.GetNoNullInt32(rVar["idinc"]);
                    if (listaMovIncasso.Contains(idinc)) continue;
                    string idrelatedCredit = "income§" + rVar["idinc"]; //+ "§credit" 15040 tolgo tutto
                    string idrelated = "income§" + rVar["idinc"];
                    //L'importo serve sempre, lo mettiamo già nella variabile!
                    decimal importo = CfgFn.GetNoNullDecimal(rVar["amount"]); //dovrebbe essere di segno negativo
                    if (importo == 0) continue;

                    string filterInc = QHS.AppAnd(QHS.CmpEq("idinc", idinc), QHS.CmpEq("ayear", rVar["yvar"]));
                    DataTable tEntrata = Conn.RUN_SELECT("incomeview",
                        "idinc,ymov,nmov, ypro, npro, amount,idreg,idupb,autokind, autocode,idpayment,idacccredit,transmissiondate,description,finflag,idfin",
                        null, filterInc, null, true);

                    DataRow rIncasso = tEntrata.Rows[0];
                    ////if (rIncasso["transmissiondate"] == DBNull.Value) continue;

                    // Scritture sull'incasso
                    object idAccCliente = rIncasso["idacccredit"];
                    bool contoCreditoreBloccato = idAccCliente != DBNull.Value;

                    object idAccClientenoMov = EP.GetCustomerAccountForRegistry(null, rIncasso["idreg"]);

                    if (idAccCliente == DBNull.Value)
                        idAccCliente = idAccClientenoMov;




                    byte autokind = CfgFn.GetNoNullByte(rIncasso["autokind"]);
                    int autocode = CfgFn.GetNoNullInt32(rIncasso["autocode"]);
                    string descrdet = descrFase + " n° " + rIncasso["nmov"].ToString() + "/" +
                                      rIncasso["ymov"].ToString() +
                                      " Revers. " + " n° " + rIncasso["npro"].ToString() + "/" +
                                      rIncasso["ypro"].ToString();
                    switch (autokind) {
                        case 7:
                            //Chiusura Fondo Piccole Spese
                            object codicefps = rIncasso["autocode"];
                            DataRow fpsRow = null;
                            if (codicefps == DBNull.Value) {
                                DataRow[] fpsRows = pSpeseSetup.Select();
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }
                            else {
                                DataRow[] fpsRows = pSpeseSetup.Select(QHC.CmpEq("idpettycash", codicefps));
                                if (fpsRows.Length == 1) fpsRow = fpsRows[0];
                            }

                            object idaccmotiveFps = DBNull.Value;
                            decimal importofornitore = importo;
                            if ((fpsRow != null) && (fpsRow["idacc"] != DBNull.Value)) {
                                idAccFornitore = fpsRow["idacc"];
                                importofornitore = -importo;
                            }

                            // A questo punto genera la scrittura da  banca	a credito
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, idaccmotiveFps, idrelated, descrdet);

                            //14947 mettere idrelated simile a foeco§codice fondo invece di idrelDebit, analogamente nelle distinte incasso
                            EP.EffettuaScritturaIdRelated("INCAS", importofornitore, idAccFornitore,
                                rIncasso["idreg"], rIncasso["idupb"], null, idaccmotiveFps, "foeco§" + autocode,
                                descrdet);
                            break;
                        case 15: {
                            //Liquidazione IVA Consolidata INTERNA  OBSOLETO
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);

                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefundInternal,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 16: {
                            //Liquidazione IVA Consolidata ESTERNA  OBSOLETO
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefundExternal,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 12: {
                            if (usaContiPresentazioneDocumenti) break;
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, idrelated, descrdet);
                            EP.EffettuaScrittura("INCAS", importo, idAccIvaRefund,
                                rIncasso["idreg"], rIncasso["idupb"], null, null, null, null, descrdet);
                            break;
                        }

                        case 4: {
                            //Ritenute/Contributi
                            object myAccFornitore = idAccFornitore;


                            //Si tratta di un contributo
                            object codicerit = rIncasso["autocode"];
                            int taxcode = CfgFn.GetNoNullInt32(codicerit);
                            object idser = Conn.DO_READ_VALUE("expenselast", QHS.CmpEq("idexp", rIncasso["idpayment"]),
                                "idser");

                            TaxInfo tax = TaxInfo.getInfo(taxInfo, taxcode);
                            if (tax == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + taxcode + " non è il codice di una ritenuta esistente", "Errore");
                                return false;
                            }

                            DataRow motiveRow = tax.getInfo(CfgFn.GetNoNullInt32(idser));
                            if (motiveRow == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                                ShowMessage(
                                    "Il codice " + tax.taxRef() +
                                    " non è il codice di una ritenuta configurata per l'EP.", "Errore");
                                return false;
                            }

                            //Deve effettuare la scrittura	Banca -> Debito vs erario 
                            //		o						Banca -> Debito generico 
                            object idaccmotive = motiveRow["idaccmotive_pay"];
                            if (idaccmotive != DBNull.Value) {
                                DataRow[] contiPay = EP.GetAccMotiveDetails(idaccmotive);
                                if (contiPay.Length > 0) {
                                    myAccFornitore = contiPay[0]["idacc"];
                                }
                            }

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                rIncasso["idreg"], rIncasso["idupb"], null, idaccmotive, idrelated, descrdet);
                            DataTable regs = _teh.GetIdRegFor(codicerit, rIncasso["idpayment"]);
                            foreach (DataRow rr in regs.Rows) {
                                decimal amountToConsider = importo * CfgFn.GetNoNullDecimal(rr["quota"]);
                                int idregToConsider = CfgFn.GetNoNullInt32(rr["idreg"]);
                                EP.EffettuaScrittura("INCAS", amountToConsider, myAccFornitore,
                                    idregToConsider, // era:  rIncasso["idreg"], 
                                    rIncasso["idupb"], null, null, null, idaccmotive, descrdet);
                            }

                            break;
                        }

                        case 6: {
                            object idReg = rIncasso["idreg"];
                            object codiceRecupero = rIncasso["autocode"];
                            string filterRecupero = QHC.CmpEq("idclawback", codiceRecupero);
                            DataRow[] clawBackSetup = tClawBackSetup.Select(filterRecupero);
                            object idaccRecupero = idAccCliente;
                            object idaccmotiveCb = null;
                            object idregDebito = rIncasso["idreg"];
                            if (clawBackSetup.Length > 0) {
                                DataRow rClawBackSetup = clawBackSetup[0];
                                idaccmotiveCb = rClawBackSetup["idaccmotive"];
                                DataRow[] rContoRecupero = EP.GetAccMotiveDetails(idaccmotiveCb);
                                if (rContoRecupero.Length > 0) {
                                    if (!contoCreditoreBloccato) idaccRecupero = rContoRecupero[0]["idacc"];
                                }
                            }

                            if (clawBackSetup[0]["idreg"] != DBNull.Value) {
                                idregDebito = clawBackSetup[0]["idreg"];
                            }

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds,
                                idregDebito, //rIncasso["idreg"], task 12522
                                rIncasso["idupb"], null, null, idrelated, descrdet);

                            decimal segnoPrimoDettaglio =
                                EP.signForAccount(idaccProceeds, "INCAS"); //segno del dettaglio precedente
                            decimal segnoSecondoDettaglio = EP.signForAccount(idaccRecupero, "INCAS");
                            decimal importoDaUsare = importo;
                            if (segnoSecondoDettaglio == segnoPrimoDettaglio) importoDaUsare = -importo;
                            EP.EffettuaScritturaIdRelated("INCAS", importoDaUsare, idaccRecupero,
                                idregDebito, rIncasso["idupb"], null, idaccmotiveCb, idrelatedCredit, descrdet);
                            break;

                        }

                        case 30: { //Nuovi versamenti CSA
                            if (!generaScrittureIncassoRiepPartition(EP, rIncasso["idinc"], rIncasso["idreg"], idaccProceeds,true))
                                return false;
                            break;
                        }

                        case 31: { //Nuovi riepiloghi CSA
                            if (!generaScrittureIncassoVerPartition(EP, rIncasso["idinc"], rIncasso["idreg"], idaccProceeds,true))
                                return false;
                            break;
                        }

                        case 20: {
                            if (usaContiPresentazioneDocumenti) break;

                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds, rIncasso["idreg"],
                                rIncasso["idupb"],
                                null, null, idrelated, descrdet);

                            object idregToConsider = rIncasso["idreg"]; // prendo la stessa anagrafica sui due dettagli
                            if (autocode != 0) {
                                // prendo l'anagrafica associata all'ente CSA 
                                idregToConsider = Conn.DO_READ_VALUE("csa_agency", QHS.CmpEq("idcsa_agency", autocode),
                                    "idreg");
                            }

                            EP.EffettuaScrittura("INCAS", importo, idAccCliente, idregToConsider, rIncasso["idupb"],
                                null, null, null, null, descrdet);
                            break;
                        }

                        default: {
                            EP.EffettuaScritturaIdRelated("INCAS", importo, idaccProceeds, rIncasso["idreg"],
                                rIncasso["idupb"],
                                null, null, idrelated, descrdet);

                            bool isPGiro = (CfgFn.GetNoNullInt32(rIncasso["finflag"]) & 2) != 0;
                            generaScritturaCredito(importo, idAccCliente, rIncasso["idreg"], rIncasso["idupb"],
                                rIncasso["idinc"], null, importo < 0, rIncasso["description"], rIncasso["idfin"],
                                isPGiro);
                            break;
                        }
                    }
                }
            }

            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0 && !EP.D.HasChanges()) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        private bool generaScrittureProvision(DataRow curr, BudgetFunction bf) {
            string doc = "Accantonamento" + curr["description"];
            if (curr["adate"] != DBNull.Value) {
                DateTime d = (DateTime) curr["adate"];
                doc += " del " + d.ToShortDateString();
            }

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            DataRow mainEntry = EP.SetEntry(doc, curr["adate"], curr["doc"], curr["docdate"],
                EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);

            object idaccmotive = curr["idaccmotive"];
            if (idaccmotive == DBNull.Value) {
                ShowMessage("Attenzione, il fondo di accantonamento non ha la causale di costo");
                return false;
            }

            DataRow[] rEntriesCosto = EP.GetAccMotiveDetails(idaccmotive);

            if (rEntriesCosto.Length != 1) {
                ShowMessage("La causale di costo dell'accantonamento non è ben configurata.", "Errore");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione, l'accantonamento non ha l'indicazione dell'UPB", "Errore");
                return false;
            }

            DateTime mainDate = (DateTime) curr["adate"];

            object idaccmotive_patrim = curr["idaccmotive_patrim"];
            if (idaccmotive_patrim == DBNull.Value) {
                ShowMessage(
                    "Attenzione, il fondo di accantonamento non ha la causale per lo stato patrimoniale passivo");
                return false;
            }

            DataRow[] rEntriesPatrim = EP.GetAccMotiveDetails(idaccmotive_patrim);
            if (rEntriesPatrim.Length != 1) {
                ShowMessage(
                    "La causale dello stato patrimoniale passivo dell'accantonamento non è ben configurata.", "Errore");
                return false;
            }

          
            //Prende solo i dettagli di quest'anno
            string filter = QHS.AppAnd(QHS.CmpEq("idprovision", curr["idprovision"]),
                QHS.CmpEq("year(adate)", Conn.GetEsercizio()));
            DataTable provDetail = Conn.RUN_SELECT("provisiondetail", "*", null, filter, null, true);

            object idaccCosto = rEntriesCosto[0]["idacc"];
            object idaccPatrim = rEntriesPatrim[0]["idacc"];

            if (provDetail.Rows.Count == 0) {
                ShowMessage("Nessuna scrittura da generare.", "Avviso");
                return false;
            }

            



            foreach (DataRow rdet in provDetail.Select(QHC.IsNull("idaccmotive"))) {
                string idrelated = EP_functions.GetIdForDocument(rdet);
                object idepexp = getIdEpExpByIdRelated(idrelated.ToString(), 2);
              
                string idepcontext = "MAN";
                DateTime currDate = (DateTime) rdet["adate"];
                if (currDate.Year != esercizio) continue;

                decimal amount = CfgFn.GetNoNullDecimal(rdet["amount"]);
                if (amount == 0) continue;
                DataRow subMain = EP.setCurrDate(currDate);
                CopySecurity(curr, subMain);
                EP.clearSubDetails(subMain);

                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                    amount,
                    idaccCosto, curr["idreg"], curr["idupb"], DBNull.Value, DBNull.Value,
                    curr, idaccmotive, null, idepexp, DBNull.Value, idrelated,
                    rdet["description"]);
                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                    -amount,
                    idaccPatrim, curr["idreg"], curr["idupb"], DBNull.Value, DBNull.Value,
                    //curr, idaccmotive_patrim, null, idepexp, DBNull.Value, idrelated,
                    curr, idaccmotive, null, idepexp, DBNull.Value, idrelated,
                    rdet["description"]);

            }

            foreach (DataRow rdet in provDetail.Select(QHC.IsNotNull("idaccmotive"))) {
                string idrelated = EP_functions.GetIdForDocument(rdet);
                object idepexp = getIdEpExpByIdRelated(idrelated.ToString(), 2);

                DateTime currDate = (DateTime) rdet["adate"];
                if (currDate.Year != esercizio) continue;
                string idrelatedRicavo = EP_functions.GetIdForDocument(rdet);
                object idepacc = getIdEpAccByIdRelated(idrelatedRicavo, 2);
                string idepcontextRicavo = "MAN";

                decimal amount = CfgFn.GetNoNullDecimal(rdet["amount"]);
                if (amount == 0) continue;
                DataRow subMain = EP.setCurrDate(currDate);
                CopySecurity(curr, subMain);
                EP.clearSubDetails(subMain);

                object idaccmotiveRicavo = rdet["idaccmotive"];
                DataRow[] rEntriesRicavo = EP.GetAccMotiveDetails(idaccmotiveRicavo);

                if (rEntriesRicavo.Length != 1) {
                    ShowMessage("La causale di ricavo della variazione sull'accantonamento non è ben configurata.",
                        "Errore");
                    return false;
                }

                object idaccRicavo = rEntriesRicavo[0]["idacc"];

                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextRicavo,
                    amount,
                    idaccRicavo, curr["idreg"], curr["idupb"], DBNull.Value, DBNull.Value,
                    curr, idaccmotiveRicavo, null, DBNull.Value, idepacc, idrelatedRicavo,
                    rdet["description"]);
                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextRicavo,
                    -amount,
                    idaccPatrim, curr["idreg"], curr["idupb"], DBNull.Value, DBNull.Value,
                    //curr, idaccmotive_patrim, null, idepexp, DBNull.Value, idrelated,
                    curr, idaccmotiveRicavo, null, idepexp, DBNull.Value, idrelatedRicavo,
                    rdet["description"]);

            }

            EP.RemoveEmptyDetails();

            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        private bool generaScrittureBankImport(DataRow curr, BudgetFunction bf) {
            //curr idbankimport
            // Per Pagamenti e Incassi Effettua scritture del Tipo CONTO PRESENTAZIONE DOCUMENTI IN BANCA a	BANCA
            object idaccPayment = _rConfig["idacc_bankpaydoc"];
            object idaccProceeds = _rConfig["idacc_bankprodoc"];
            if (!usaContiPresentazioneDocumenti) return false;
            string descrFaseEntrata = "";
            object faseObjE = Conn.DO_READ_VALUE("incomephase", QHS.CmpEq("nphase", Conn.GetSys("maxincomephase")),
                "description");
            if (faseObjE != null) descrFaseEntrata = faseObjE.ToString();

            string descrFaseSpesa = "";
            object faseObjS = Conn.DO_READ_VALUE("expensephase", QHS.CmpEq("nphase", Conn.GetSys("maxexpensephase")),
                "description");
            if (faseObjS != null) descrFaseSpesa = faseObjS.ToString();

            object doc = "Esiti Bancari" +
                         curr["ayear"].ToString().Substring(2, 2) + "/ " +
                         curr["idbankimport"];

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            DateTime dateToConsider = (DateTime) curr["adate"];
            if (dateToConsider.Year > CfgFn.GetNoNullInt32(curr["ayear"])) {
                dateToConsider = new DateTime(CfgFn.GetNoNullInt32(curr["ayear"]), 12, 31);
            }

            DataRow mainEntry =
                EP.SetEntry(doc, dateToConsider, doc, dateToConsider, EP_functions.GetIdForDocument(curr));
            EP.ClearDetails(mainEntry);

            string filter = QHS.CmpEq("idbankimport", curr["idbankimport"]);
            DataTable bankTransview = Conn.RUN_SELECT("banktransactionview", "*", null, filter, null, true);


            if (bankTransview.Rows.Count == 0) {
                ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }
            // Ciclo sulle esitazioni bancarie

            foreach (DataRow currTran in bankTransview.Select()) {
                string kind = currTran["kind"].ToString();

                object idaccPresToBank;
                object idtreasurer = currTran["idtreasurer"];
                string idepcontext;
                string idrelated;
                string descrdet = "";
                //"Pagamento n.... - Mandato n..." e idem per Incasso e Reversale.
                if (kind == "C") {
                    idaccPresToBank = idaccProceeds;
                    idepcontext = "INCAS";
                    idrelated = currTran["idinc"] != DBNull.Value ? "income§" + currTran["idinc"] : null;
                    descrdet = descrFaseEntrata + " n° " + currTran["ninc"].ToString() + "/" +
                               currTran["yinc"].ToString() +
                               " Revers. " + " n° " + currTran["npro"].ToString() + "/" + currTran["ypro"].ToString();
                }
                else {
                    idaccPresToBank = idaccPayment;
                    idepcontext = "PAGAM";
                    idrelated = currTran["idexp"] != DBNull.Value ? "expense§" + currTran["idexp"] : null;
                    descrdet = descrFaseSpesa + " n° " + currTran["nexp"].ToString() + "/" +
                               currTran["yexp"].ToString() +
                               " Mand. " + " n° " + currTran["npay"].ToString() + "/" + currTran["ypay"].ToString();
                }

                var idaccTreasurer = getAccountTreasurer(idtreasurer, kind);
                if (idaccTreasurer == DBNull.Value) {
                    ShowMessage(
                        "Conto cassiere non trovato (riga " + currTran["nban"] + " tipo " + currTran["kind"], "Errore");
                    return false;
                }

                // Pagamento  / Incassi

                // 1)Conto presentazione a banca A Banca

                object idreg = currTran["idreg"];
                object idupb = currTran["idupb"];
                decimal importo = CfgFn.GetNoNullDecimal(currTran["amount"]);

                //string idrelated = BudgetFunction.GetIdForDocument(curr); 
                EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccPresToBank, idreg, idupb, null, null,
                    idrelated, descrdet);
                EP.EffettuaScrittura(idepcontext, importo, idaccTreasurer, idreg, idupb, null, null, null, null,
                    descrdet);
            }

            EP.RemoveEmptyDetails();
            return true;
        }

        bool generaScrittureMissione(DataRow curr, BudgetFunction bf) {
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object doc =
                "Miss. " +
                curr["yitineration"].ToString().Substring(2, 2) + "/" +
                curr["nitineration"].ToString().PadLeft(6, '0');

            DataRow mainEntry = EP.SetEntry(curr["description"],
                curr["datecompleted"], //era adate, cambiato per task 8264 //era curr["stop"], task 8006 e 8002
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);
            var idaccmotMain = curr["idaccmotive"];
            if (idaccmotMain == DBNull.Value) {
                ShowMessage("Non è stata impostata la causale per la prestazione.");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione, la missione non ha l'indicazione dell'UPB");
                return false;
            }

            var idepcontext = "PRESTAZ";
            var idaccRegistry = EP.GetSupplierAccountForRegistry(curr["idaccmotivedebit"], curr["idreg"]);
            var idaccmotMainDebit = curr["idaccmotivedebit"];
            if (idaccmotMainDebit == DBNull.Value) {
                idaccmotMainDebit = idaccmotMain;
            }

            if (idaccRegistry == null || idaccRegistry == DBNull.Value) {
                ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                return false;
            }
            // L'anagrafica usata per la parte verso ente è quella della cfg. ritenute, eventualmente spacchettata 
            //  ove ci sia la ripartizione percentuale (in questo caso sarebbe opportuno usare la liq. diretta)
            //Invece l'anagrafica per la parte "conto ente" è quella della cfg. delle partite di giro

            //Effettua la scritt. residua sulla causale principale
            DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotMain);
            if (contiPrinc.Length == 0) {
                ShowMessage(
                    "Non sono state correttamente configurate le causali di costo principale. La scrittura non pareggerà.",
                    "Errore");
                return false;
            }

            string nomeDebito = nomeMissione(curr);

            object idAccCostoPrincipale = contiPrinc[0]["idacc"];

            string idrelated = BudgetFunction.GetIdForDocument(curr);
            object idepexp = getIdEpExpByIdRelated(idrelated, 2);
            //if ((idepexp == null || idepexp == DBNull.Value) && esercizio > 2015 && UsaImpegniDiBudget) {
            //    ShowMessage("Non è stato trovato alcun impegno di budget per la missione ");
            //    return false;
            //}


            decimal sommaspese = 0;
            //Effettua una serie di scritture per ogni tipo spesa per cui sia stata configurata una causale

            if (getFaseAnticipoMissione(curr)) {
                DataTable anticipi = Conn.RUN_SELECT("itinerationrefund", "*", null,
                    QHS.AppAnd(QHS.CmpEq("iditineration", curr["iditineration"]), QHS.CmpEq("flagadvancebalance", "A")),
                    null, false);
                foreach (DataRow rSpesa in anticipi.Rows) {
                    var causaleSpesaAnticipo = Conn.DO_READ_VALUE("itinerationrefundkind",
                        QHS.CmpEq("iditinerationrefundkind", rSpesa["iditinerationrefundkind"]),
                        "idaccmotive", null);
                    if (causaleSpesaAnticipo == DBNull.Value) {
                        continue;
                    }

                    DataRow[] contiSpesa = EP.GetAccMotiveDetails(causaleSpesaAnticipo);
                    if (contiSpesa.Length == 0) {
                        continue;
                    }

                    string idrelatedRef = idrelated + "§" + rSpesa["nrefund"];
                    object idepexpRef = getIdEpExpByIdRelated(idrelatedRef, 2);
                    //if ((idepexpRef == null || idepexpRef == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                    //    ShowMessage("Non è stato trovato alcun impegno di budget per la spesa " + rSpesa["description"],"Errore");
                    //    return false;
                    //}

                    decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                    decimal indennitaSupp = CfgFn.GetNoNullDecimal(rSpesa["extraallowance"]);
                    importospesa += indennitaSupp;
                    sommaspese += importospesa;
                    object idAccCosto = contiSpesa[0]["idacc"];

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importospesa,
                        idAccCosto,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, causaleSpesaAnticipo, idepexpRef, null, idrelatedRef, rSpesa["description"]);
                        curr, idaccmotMain, curr["idcostpartition"], idepexpRef, null, idrelatedRef, rSpesa["description"]);


                    EP.EffettuaScritturaImpegnoBudget(idepcontext, importospesa,
                        idaccRegistry,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, causaleSpesaAnticipo,
                        curr, idaccmotMain,
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        idepexpRef, null, idrelatedRef, nomeDebito);
                }
            }
            else {
                DataTable saldi = Conn.RUN_SELECT("itinerationrefund", "*", null,
                    QHS.AppAnd(QHS.CmpEq("iditineration", curr["iditineration"]), QHS.CmpEq("flagadvancebalance", "S")),
                    null, false);
                foreach (DataRow rSpesa in saldi.Rows) {
                    var causaleSpesaSaldo = Conn.DO_READ_VALUE("itinerationrefundkind",
                        QHS.CmpEq("iditinerationrefundkind", rSpesa["iditinerationrefundkind"]),
                        "idaccmotive", null);
                    if (causaleSpesaSaldo == DBNull.Value)
                        continue;
                    DataRow[] contiSpesa = EP.GetAccMotiveDetails(causaleSpesaSaldo);
                    if (contiSpesa.Length == 0) {
                        continue;
                    }

                    string idrelatedRef = idrelated + "§" + rSpesa["nrefund"];
                    object idepexpRef = getIdEpExpByIdRelated(idrelatedRef, 2);
                    //if ((idepexpRef == null || idepexpRef == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                    //    ShowMessage("Non è stato trovato alcun impegno di budget per la spesa " +
                    //        rSpesa["description"],"Errore");
                    //    return false;
                    //}

                    decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                    decimal indennitaSupp = CfgFn.GetNoNullDecimal(rSpesa["extraallowance"]);
                    importospesa += indennitaSupp;
                    sommaspese += importospesa;
                    object idAccCosto = contiSpesa[0]["idacc"];
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importospesa,
                        idAccCosto,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, causaleSpesaSaldo, idepexpRef, null, idrelatedRef, rSpesa["description"]);
                        curr, idaccmotMain, curr["idcostpartition"], idepexpRef, null, idrelatedRef, rSpesa["description"]);
                    EP.EffettuaScritturaImpegnoBudget(idepcontext, importospesa,
                        idaccRegistry,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, causaleSpesaSaldo,
                        curr, idaccmotMain,
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        idepexpRef, null, idrelatedRef, nomeDebito);
                }
            }

            DataRow rItinerationSetup = _rConfig;

            decimal admincarkm = CfgFn.GetNoNullDecimal(curr["admincarkm"]);
            decimal admincarkmcost = CfgFn.GetNoNullDecimal(curr["admincarkmcost"]);
            decimal admincartotalcost = CfgFn.RoundValuta(admincarkm * admincarkmcost);
            if ((admincartotalcost != 0) && (rItinerationSetup["idaccmotive_admincar"] != DBNull.Value)
                                         && (rItinerationSetup["idaccmotive_admincar"].ToString() !=
                                             idaccmotMain.ToString())) {
                object idaccmotiveAc = rItinerationSetup["idaccmotive_admincar"];
                DataRow[] contiAc = EP.GetAccMotiveDetails(idaccmotiveAc);
                if (contiAc.Length > 0) {
                    string idrelatedAdmin = idrelated + "§admin";
                    object idepexpAdmin = getIdEpExpByIdRelated(idrelatedAdmin, 2);
                    //if ((idepexpAdmin == null || idepexpAdmin == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                    //    ShowMessage("Non è stato trovato alcun impegno di budget per il costo relativo al mezzo amministrazione","Errore");
                    //    return false;
                    //}
                    sommaspese += admincartotalcost;

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, admincartotalcost,
                        contiAc[0]["idacc"],
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveAc, idepexpAdmin, null, idrelatedAdmin, "Rimborso mezzo amministrazione");
                        curr, idaccmotMain, curr["idcostpartition"], idepexpAdmin, null, idrelatedAdmin, "Rimborso mezzo amministrazione");

                    EP.EffettuaScritturaImpegnoBudget(idepcontext, admincartotalcost,
                        idaccRegistry,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveAc,
                        curr, idaccmotMain,
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        idepexpAdmin, null, idrelatedAdmin, nomeDebito);

                }
            }

            decimal owncarkm = CfgFn.GetNoNullDecimal(curr["owncarkm"]);
            decimal owncarkmcost = CfgFn.GetNoNullDecimal(curr["owncarkmcost"]);
            decimal owncartotalcost = CfgFn.RoundValuta(owncarkm * owncarkmcost);
            if ((owncartotalcost != 0) && (rItinerationSetup["idaccmotive_owncar"] != DBNull.Value)
                                       && (rItinerationSetup["idaccmotive_owncar"].ToString() !=
                                           idaccmotMain.ToString())) {

                object idaccmotiveOc = rItinerationSetup["idaccmotive_owncar"];
                DataRow[] contiOc = EP.GetAccMotiveDetails(idaccmotiveOc);
                if (contiOc.Length > 0) {
                    string idrelatedOwn = idrelated + "§own";
                    object idepexpOwn = getIdEpExpByIdRelated(idrelatedOwn, 2);
                    //if ((idepexpOwn == null || idepexpOwn == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                    //    ShowMessage("Non è stato trovato alcun impegno di budget per il costo relativo al mezzo proprio","Errore");
                    //    return false;
                    //}
                    sommaspese += owncartotalcost;

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, owncartotalcost,
                        contiOc[0]["idacc"],
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveOc, idepexpOwn, null, idrelatedOwn, "Rimborso mezzo proprio");
                        curr, idaccmotMain, curr["idcostpartition"], idepexpOwn, null, idrelatedOwn, "Rimborso mezzo proprio");

                    EP.EffettuaScritturaImpegnoBudget(idepcontext, owncartotalcost,
                        idaccRegistry,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveOc,
                        curr, idaccmotMain,
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        idepexpOwn, null, idrelatedOwn, nomeDebito);
                }

            }

            decimal footkm = CfgFn.GetNoNullDecimal(curr["footkm"]);
            decimal footkmcost = CfgFn.GetNoNullDecimal(curr["footkmcost"]);
            decimal foottotalcost = CfgFn.RoundValuta(footkm * footkmcost);
            if ((foottotalcost != 0) && (rItinerationSetup["idaccmotive_foot"] != DBNull.Value)) {
                object idaccmotiveF = rItinerationSetup["idaccmotive_foot"];
                DataRow[] contiF = EP.GetAccMotiveDetails(idaccmotiveF);
                if (contiF.Length > 0) {
                    string idrelatedFoot = idrelated + "§foot";
                    object idepexpFoot = getIdEpExpByIdRelated(idrelatedFoot, 2);
                    //if ((idepexpFoot == null || idepexpFoot == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                    //    ShowMessage("Non è stato trovato alcun impegno di budget per il costo relativo al mezzo proprio","Errore");
                    //    return false;
                    //}
                    sommaspese += foottotalcost;

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, foottotalcost,
                        contiF[0]["idacc"],
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveF, idepexpFoot, null, idrelatedFoot, "Rimborso spostamento a piedi");
                        curr, idaccmotMain, curr["idcostpartition"], idepexpFoot, null, idrelatedFoot, "Rimborso spostamento a piedi");

                    EP.EffettuaScritturaImpegnoBudget(idepcontext, foottotalcost,
                        idaccRegistry,
                        curr["idreg"], curr["idupb"],
                        curr["start"], curr["stop"],
                        //curr, idaccmotiveF,
                        curr, idaccmotMain,
                        //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                        idepexpFoot, null, idrelatedFoot, nomeDebito);
                }
            }

            decimal totale = CfgFn.GetNoNullDecimal(curr["totalgross"]);
            decimal netto = totale - sommaspese;


            //Per tutti i CONTRIBUTI:
            //Se è configurato il conto di debito 
            //	effettua la scrittura COSTO->debito conto ente  (idaccmotive_cost -> idaccmotive_debit)
            // altrimenti
            //  effettua la scrittura COSTO->debito verso ente   (idaccmotive_cost -> idaccmotive_pay)
            DataTable itinerationtax = Conn.RUN_SELECT("itinerationtax", "*", null,
                QHS.CmpEq("iditineration", curr["iditineration"]), null, false);

            foreach (DataRow rit in itinerationtax.Rows) {
                decimal amount = CfgFn.GetNoNullDecimal(rit["admintax"]);
                if (amount == 0) continue;

                object idaccmotiveCost = generaScritturaContributo(idepexp, amount, rit["taxcode"],
                    curr["idupb"], curr["start"], curr["stop"], idaccmotMain, rit, curr["idser"], curr,
                    nomeDebito, curr["idcostpartition"]); //doc.ToString()
                if (idaccmotiveCost == null) return false;

            }



            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, netto,
                idAccCostoPrincipale,
                curr["idreg"], curr["idupb"],
                curr["start"], curr["stop"],
                curr, idaccmotMain, curr["idcostpartition"], idepexp, null, idrelated, curr["description"]);


            //Effettua la scrittura sul conto di debito vs fornitore
            EP.EffettuaScritturaImpegnoBudget(idepcontext, netto,
                idaccRegistry,
                curr["idreg"], curr["idupb"],
                curr["start"], curr["stop"],
                //curr, idaccmotMainDebit,
                curr, idaccmotMain,
                //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
                idepexp, null, idrelated, nomeDebito //curr["description"]
            );

            EP.RemoveEmptyDetails();

            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        bool generaScrittureDipendente(DataRow curr, BudgetFunction bf) {
            object idregDistrained = curr["idreg_distrained"]; // solo per prestazioni pignoratizie
//            int esercizio = CfgFn.GetNoNullInt32(meta.GetSys("esercizio"));

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object doc = "Altri Compensi " +
                         curr["ycon"].ToString().Substring(2, 2) + "/" +
                         curr["ncon"].ToString().PadLeft(6, '0');

            string nomeDebito = nomeCompensoDipendente(curr);

            DataRow mainEntry = EP.SetEntry(curr["description"], curr["adate"],
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);
            object idaccmotMain = curr["idaccmotive"];
            if (idaccmotMain == DBNull.Value) {
                ShowMessage("Non è stata impostata la causale per la prestazione.");
                return false;
            }

            string idepcontext = "PRESTAZ";
            object idaccRegistry = EP.GetSupplierAccountForRegistry(curr["idaccmotivedebit"], curr["idreg"]);
            if (idaccRegistry == null || idaccRegistry == DBNull.Value) {
                ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                return false;
            }

            object idaccmotMainDebit = curr["idaccmotivedebit"];
            if (idaccmotMainDebit == DBNull.Value) {
                idaccmotMainDebit = idaccmotMain;
            }


            decimal totale = CfgFn.GetNoNullDecimal(curr["feegross"]);

            //Effettua la scritt. residua sulla causale principale
            DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotMain);
            if (contiPrinc.Length == 0) {
                ShowMessage("Non è stata configurata la causale principale di costo. La scrittura non pareggerà.",
                    "Errore");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione, il contratto non ha l'indicazione dell'UPB");
                return false;
            }



            string idrelated = BudgetFunction.GetIdForDocument(curr);
            //object idepexp = Conn.DO_READ_VALUE("epexp", QHS.AppAnd(QHS.CmpEq("idrelated", idrelated), QHS.CmpEq("nphase", 2)), "idepexp");
            object idepexp = getIdEpExpByIdRelated(idrelated, 2);
            //if ((idepexp == null || idepexp == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
            //    ShowMessage("Non è stato trovato alcun impegno di budget per il compenso","Errore");
            //    return false;
            //}





            //Per tutti i CONTRIBUTI:
            //Se è configurato il conto di debito 
            //	effettua la scrittura COSTO->debito conto ente  (idaccmotive_cost -> idaccmotive_debit)
            // altrimenti
            //  effettua la scrittura COSTO->debito verso ente   (idaccmotive_cost -> idaccmotive_pay)
            string filterContract = QHS.CmpKey(curr);
            DataTable wageadditiontax = Conn.RUN_SELECT("wageadditiontax", "*", null, filterContract, null, false);

            foreach (DataRow rit in wageadditiontax.Select()) {
                decimal amount = CfgFn.GetNoNullDecimal(rit["admintax"]);
                if (amount == 0) continue;

                object idaccmotiveCost = generaScritturaContributo(idepexp, amount, rit["taxcode"],
                    curr["idupb"], curr["start"], curr["stop"], idaccmotMain, rit, curr["idser"], curr, doc.ToString(), curr["idcostpartition"]);
                if (idaccmotiveCost == null) return false;

            }

            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, totale,
                contiPrinc[0]["idacc"],
                idregDistrained != DBNull.Value ? idregDistrained : curr["idreg"],
                curr["idupb"],
                curr["start"], curr["stop"],
                curr, idaccmotMain, curr["idcostpartition"], idepexp, null, idrelated, curr["description"]);


            //Effettua la scrittura sul conto di debito vs fornitore
            EP.EffettuaScritturaImpegnoBudget(idepcontext, totale,
                idaccRegistry,
                curr["idreg"], curr["idupb"],
                curr["start"], curr["stop"],
                // curr, idaccmotMainDebit, idepexp, null, idrelated);
                curr, idaccmotMain, idepexp, null, idrelated, nomeDebito);
            //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale


            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        bool generaScrittureCedolino(DataRow curr, BudgetFunction bf) {
            string filterContract = QHS.AppAnd(QHS.CmpEq("idcon", curr["idcon"]),
                QHS.CmpEq("ayear", Conn.GetSys("esercizio"))); //fiscalyear
            string filterCedolino = QHS.CmpEq("idpayroll", curr["idpayroll"]);
            DataTable parasubcontractview =
                Conn.RUN_SELECT("parasubcontractview", "*", null, filterContract, null, false);
            if (parasubcontractview.Rows.Count == 0) {
                ShowMessage(
                    "Contratto del cedolino non trovato nell'esercizio " + Conn.GetEsercizio() +
                    ", le scritture non saranno generate.",
                    "Errore");
                return false;
            }

            string nomeDebito = nomeCedolino(curr);
            DataRow currContratto = parasubcontractview.Rows[0];

            int annostop = esercizio;
            if (curr["stop"] != DBNull.Value) {
                annostop = ((DateTime) curr["stop"]).Year;
            }

            int annoContratto =
                CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract", QHS.CmpEq("idcon", curr["idcon"]), "ycon"));
            if (annostop < annoContratto) annostop = annoContratto;
            object flag = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annostop), "flag");
            bool annoStopAperto = flag != null && flag != DBNull.Value && ((CfgFn.GetNoNullInt32(flag) & 32) == 0);
            bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                 (annoStopAperto == false && annostop < esercizio);

            if (!daConsiderare) {
                ShowMessage("Il cedolino n. " + curr["npayroll"] + "/" + curr["fiscalyear"] +
                            " ha competenza in anni diversi quindi non sarà generato alcuna scrittura nell'anno " +
                            esercizio, "Avviso");
                return false;
            }

            object idcostpartition;

            if (curr["idcostpartition"] != DBNull.Value)
                idcostpartition = curr["idcostpartition"];
            else
                idcostpartition = currContratto["idcostpartition"];

            object idreg = currContratto["idreg"];
            object idupb = curr["idupb"];


            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object descr = "Contratto n." + currContratto["ncon"] + " del " +
                           currContratto["ycon"] + " - " +
                           "Cedolino n. " + curr["npayroll"] + "/" + curr["fiscalyear"];

            object doc = "Contr. " + currContratto["ncon"] + "/" +
                         currContratto["ycon"] +
                         " Cedolino " + curr["npayroll"] + "/" + curr["fiscalyear"];

            //"Cedolino n. " + curr["fiscalyear"] + "/" + curr["npayroll"];
            object dateTimeForEntry = Conn.GetSys("datacontabile");
            if (EP.currentRow != null) {
                dateTimeForEntry = EP.currentRow["adate"];
            }

            DataRow mainEntry = EP.SetEntry(descr, dateTimeForEntry,
                doc, dateTimeForEntry, EP_functions.GetIdForDocument(curr));
            CopySecurity(currContratto, mainEntry);
            EP.ClearDetails(mainEntry);
            object idaccmotMain = currContratto["idaccmotive"];

            if (idaccmotMain == DBNull.Value) {
                ShowMessage("Non è stata impostata la causale per la prestazione.");
                return false;
            }

            string idepcontext = "PRESTAZ";
            object idaccRegistry = EP.GetSupplierAccountForRegistry(
                currContratto["idaccmotivedebit"], currContratto["idreg"]);

            object idaccmotMainDebit = currContratto["idaccmotivedebit"];
            if (idaccmotMainDebit == DBNull.Value) {
                idaccmotMainDebit = idaccmotMain;
            }

            if (idaccRegistry == null || idaccRegistry.ToString() == "") {
                ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione,  il cedolino non ha l'indicazione dell'UPB");
                return false;
            }

            string idrelated = BudgetFunction.GetIdForDocument(curr);
            object idepexp = getIdEpExpByIdRelated(idrelated, 2);
            //if ((idepexp == null || idepexp == DBNull.Value) && UsaImpegniDiBudget &&
            //    esercizio > 2015) {
            //        ShowMessage("Non è stato trovato alcun impegno di budget per il contratto", "Errore");
            //    return false;
            //}

            decimal totale = CfgFn.GetNoNullDecimal(curr["feegross"]);

            //Effettua la scrittura sulla causale principale
            DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotMain.ToString());

            //Per tutti i CONTRIBUTI:
            //Se è configurato il conto di debito 
            //	effettua la scrittura COSTO->debito conto ente  (idaccmotive_cost -> idaccmotive_debit)
            // altrimenti
            //  effettua la scrittura COSTO->debito verso ente   (idaccmotive_cost -> idaccmotive_pay)
            DataTable payrolltax = Conn.RUN_SELECT("payrolltax", "*", null, filterCedolino, null, false);

            foreach (DataRow rit in payrolltax.Select()) {
                decimal amount = CfgFn.GetNoNullDecimal(rit["admintax"]);
                if (amount == 0) continue;

                //Se la causale di costo non è configurata, prende la causale principale
                object idaccmotiveCost = generaScritturaContributo(idepexp, amount, rit["taxcode"],
                    idupb, curr["start"], curr["stop"], idaccmotMain, rit, currContratto["idser"], currContratto,
                    nomeDebito, //descr.ToString()
                    idcostpartition
                );
                if (idaccmotiveCost == null) return false;
            }


            if (contiPrinc.Length == 0) {
                ShowMessage("Non è stata configurata la causale principale di costo. La scrittura non pareggerà.",
                    "Errore");
                return false;
            }
            else {
                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, totale,
                    contiPrinc[0]["idacc"],
                    idreg, idupb,
                    curr["start"], curr["stop"],
                    currContratto, idaccmotMain, idcostpartition, idepexp, null, idrelated, descr);
            }

            //Effettua la scrittura sul conto di debito vs fornitore
            EP.EffettuaScritturaImpegnoBudget(idepcontext, totale,
                idaccRegistry,
                idreg, idupb,
                curr["start"], curr["stop"],
                //curr, idaccmotMainDebit,
                currContratto, idaccmotMain,
                //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale 
                idepexp, null, idrelated, nomeDebito);



            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }


        private TaxEntryHelper _teh;

        class InfoContributi {
            public object idacc;
            public decimal importo;
            public object idreg;
            public string idrelated;
            public string idaccmotive;
            public object idepexp;

            public InfoContributi(object idacc, decimal importo, object idreg, string idrelated, string idaccmotive,
                object idepexp) {
                this.idacc = idacc;
                this.importo = importo;
                this.idreg = idreg;
                this.idrelated = idrelated;
                this.idaccmotive = idaccmotive;
                this.idepexp = idepexp;

            }
        }

        List<InfoContributi> getInfoForContributo(object idser, object taxcode, decimal importo, string idrelated) {
            if (_teh == null) {
                _teh = new TaxEntryHelper(Conn);
            }

            TaxInfo tax = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(taxcode));

            if (tax == null) { // (_tax.Select(QHC.CmpEq("taxcode", codiceriten)).Length == 0) 
                ShowMessage(
                    "Il codice " + taxcode + " non è il codice di una ritenuta esistente", "Errore");
                return null;
            }

            DataRow motiveRow = tax.getInfo(CfgFn.GetNoNullInt32(idser));
            if (motiveRow == null) {
                ShowMessage("Non è presente la causale di debito per il contributo di codice " + tax.taxRef(),
                    "Errore");
                return null;
            }

            List<InfoContributi> result = new List<InfoContributi>();
            object idaccmotiveTouse;
            object idregauto = _rConfig["idregauto"];
            if (motiveRow["idaccmotive_debit"] != DBNull.Value) {
                idaccmotiveTouse = motiveRow["idaccmotive_debit"];
                DataRow[] contiContribFinanz = EP.GetAccMotiveDetails(idaccmotiveTouse);
                if (contiContribFinanz.Length == 0) {
                    ShowMessage(
                        "Non è stata ben configurata la causale del debito del contributo di codice " + tax.taxRef(),
                        "Errore");
                    return null;
                }

                result.Add(new InfoContributi(contiContribFinanz[0]["idacc"], importo, idregauto,
                    idrelated + "§" + idregauto, idaccmotiveTouse.ToString(), getIdEpExpByIdRelated(idrelated, 2)));
            }
            else {
                idaccmotiveTouse = motiveRow["idaccmotive_pay"];
                DataRow[] contiContribFinanz = EP.GetAccMotiveDetails(idaccmotiveTouse);
                if (contiContribFinanz.Length == 0) {
                    ShowMessage(
                        "Non è stata ben configurata la causale del debito del contributo di codice " + tax.taxRef(),
                        "Errore");
                    return null;
                }

                DataTable regs = _teh.GetIdRegFor(taxcode, DBNull.Value, DBNull.Value);
                if (regs == null || regs.Rows.Count == 0) {
                    ShowMessage(
                        "Anagrafica per il versamento non trovata per la ritenuta di codice " + tax.taxRef(), "Errore");
                    return null;
                }

                foreach (DataRow registry in regs.Rows) {
                    decimal amountToConsider = CfgFn.RoundValuta(importo * CfgFn.GetNoNullDecimal(registry["quota"]));
                    int idreg = CfgFn.GetNoNullInt32(registry["idreg"]);
                    string idrel = idrelated + "§" + idreg;
                    result.Add(new InfoContributi(contiContribFinanz[0]["idacc"], amountToConsider,
                        idreg, idrel, idaccmotiveTouse.ToString(), getIdEpExpByIdRelated(idrel, 2)));
                }
            }


            //if (UsaImpegniDiBudget && esercizio > 2015) {
            //    foreach (InfoContributi  i in result) {
            //        if (i.idepexp == null || i.idepexp == DBNull.Value) {
            //            ShowMessage("Non è stato trovato alcun impegno di budget per il contributo " + tax.taxRef(), "Errore");
            //            return null;
            //        }
            //    }
            //}
            return result;
        }

        object getIdaccmotiveCostForTax(object idser, object taxcode) {
            TaxInfo rInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(taxcode));
            if (rInfo == null) return DBNull.Value;
            DataRow rr = rInfo.getInfo(CfgFn.GetNoNullInt32(idser));
            if (rr == null) return DBNull.Value;
            return rr["idaccmotive_cost"];

        }

        object generaScritturaContributo(object idepexp, decimal importo, object taxcode, object idupb, object start,
            object stop,
            object idaccMotMain,
            DataRow ritRow, object idser, DataRow rowForIdSor = null, string description = "", object idcostpartition = null) {
            if (_teh == null) {
                _teh = new TaxEntryHelper(Conn);
            }

            string idrelatedContrib = BudgetFunction.GetIdForDocument(ritRow);
            List<InfoContributi> lista = getInfoForContributo(idser, taxcode, importo, idrelatedContrib);
            if (lista == null) return null;


            object idaccmotiveCost = idaccMotMain;
            TaxInfo myTaxInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(taxcode));
            //DataRow taxMotive = myTaxInfo.getInfo(CfgFn.GetNoNullInt32(idser));

            //if (tipoRit["idaccmotive_cost"] != DBNull.Value)
            //    idaccmotiveCost = tipoRit["idaccmotive_cost"];
            object newIdaccmotiveCost = getIdaccmotiveCostForTax(idser, taxcode);
            if (newIdaccmotiveCost != DBNull.Value) {
                idaccmotiveCost = newIdaccmotiveCost;
            }

            DataRow[] contiContribCosto = EP.GetAccMotiveDetails(idaccmotiveCost.ToString());
            if (contiContribCosto.Length == 0) {
                ShowMessage("Non è stata configurata la causale del costo  per il contributo " + myTaxInfo.taxRef(),
                    "Errore");
                return null;
            }

            foreach (InfoContributi i in lista) {
                //Scrittura parte debito
                object idepexp_touse = i.idepexp;
                if (i.idepexp == DBNull.Value) {
                    idepexp_touse = idepexp;
                }
                else {
                    idepexp_touse = i.idepexp;
                }

                string descr = description;
                //if (descr != "") descr += "-";

                // conto di debito
                EP.EffettuaScritturaImpegnoBudget("PRESTAZ", i.importo, i.idacc, i.idreg, idupb,
                        DBNull.Value, DBNull.Value,
                        rowForIdSor, idaccmotiveCost, idepexp_touse, null, i.idrelated, 
                        descr); //+ myTaxInfo.taxRef());

                if (idcostpartition == null) {
                    EP.EffettuaScritturaImpegnoBudget("PRESTAZ", i.importo,
                        contiContribCosto[0]["idacc"],
                        i.idreg, idupb, start, stop,
                        rowForIdSor, idaccmotiveCost, idepexp_touse, null, idrelatedContrib,
                        //rowForIdSor, idaccMotMain, i.idepexp, null, i.idrelated, 
                        descr + "Contributo " + myTaxInfo.taxRef());
                }
                else {
                    //EP.EffettuaScritturaSuddivisaImpegnoBudget("PRESTAZ", i.importo, i.idacc,
                    //    i.idreg, idupb, DBNull.Value, DBNull.Value,
                    //    rowForIdSor, idaccmotiveCost, idcostpartition, idepexp_touse, null, i.idrelated, descr);

                    EP.EffettuaScritturaSuddivisaImpegnoBudget("PRESTAZ", i.importo, contiContribCosto[0]["idacc"],
                        i.idreg, idupb, start, stop,
                        rowForIdSor, idaccmotiveCost, idcostpartition, idepexp_touse, null, idrelatedContrib, descr + "Contributo " + myTaxInfo.taxRef());
				}
            }

            return idaccmotiveCost;
        }

        bool generaScrittureProfessionali(DataRow curr, BudgetFunction bf) {
            // Solo per gli eventuali contributi.            
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object doc = "Prestazione Professionale " +
                         curr["ycon"].ToString().Substring(2, 2) + "/" +
                         curr["ncon"].ToString().PadLeft(6, '0');

            string filterContract = QHS.CmpKey(curr);
            DataRow mainEntry = EP.SetEntry(curr["description"], curr["stop"],
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(mainEntry);
            object idaccmotMain = curr["idaccmotive"];
            if (idaccmotMain == DBNull.Value) {
                ShowMessage("Non è stata impostata la causale per la prestazione.");
                return false;
            }

            string nomeDebito = nomeParcella(curr);

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione, la parcella non ha l'indicazione dell'UPB");
                return false;
            }

            string idrelated = BudgetFunction.GetIdForDocument(curr);
            object idepexp = getIdEpExpByIdRelated(idrelated, 2);
            //if ((idepexp == null || idepexp == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
            //    ShowMessage("Non è stato trovato alcun impegno di budget per il contratto", "Errore");
            //    return false;
            //}

            DataTable profservicetax = Conn.RUN_SELECT("profservicetax", "*", null, filterContract, null, false);

            foreach (DataRow rit in profservicetax.Select()) {
                decimal amount = CfgFn.GetNoNullDecimal(rit["admintax"]);
                if (amount == 0) continue;

                //Se la causale di costo non è configurata, prende la causale principale
                object idaccmotiveCost = generaScritturaContributo(idepexp, amount, rit["taxcode"],
                    curr["idupb"], curr["start"], curr["stop"], idaccmotMain, rit, curr["idser"], curr,
                    nomeDebito //doc.ToString()
                );
                if (idaccmotiveCost == null) return false;
            }

            //Effettua la scritt. residua sulla causale principale del costo + contributi senza causale specifica. 
            //Il costo è stato rimosso, la scrittura avviene solo sui contributiNonConfigurati
            DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotMain);
            if (contiPrinc.Length == 0) {
                ShowMessage("Non è stata configurata la causale principale di costo. La scrittura non pareggerà.",
                    "Errore");
                return false;
            }


            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }


        /// <summary>
        /// Copy security fields from source to dest
        /// </summary>
        /// <param name="source"></param>
        /// <param name="dest"></param>
        void CopySecurity(DataRow source, DataRow dest) {
            dest["idsor01"] = source["idsor01"];
            dest["idsor02"] = source["idsor02"];
            dest["idsor03"] = source["idsor03"];
            dest["idsor04"] = source["idsor04"];
            dest["idsor05"] = source["idsor05"];
        }

        bool generaScrittureOccasionale(DataRow curr, BudgetFunction bf) {
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            //DataRow EntrySetup= DS.entrysetup.Rows[0];

            object doc = "Prestazione Occasionale " +
                         curr["ycon"].ToString().Substring(2, 2) + "/" +
                         curr["ncon"].ToString().PadLeft(6, '0');

            string filterContract = QHS.CmpKey(curr);
            DataTable tContractYear = Conn.RUN_SELECT("casualcontractyear", "*", null,
                QHS.AppAnd(filterContract, QHS.CmpEq("ayear", esercizio)), null, false);
            DataTable spese = Conn.RUN_SELECT("casualcontractrefund", "*", null, filterContract, null, false);
            DataTable tipiSpesa = Conn.RUN_SELECT("casualrefund", "*", null, null, null, false);
            if (tContractYear.Rows.Count == 0) {
                ShowMessage($"Attenzione, il contratto {doc} non esiste nell'anno corrente");
                return false;
            }

            DataRow currYear = tContractYear.Rows[0];


            calcolooccasionale.calcOccasionale mycalc = new calcolooccasionale.calcOccasionale(Conn, curr, currYear,
                spese, tipiSpesa);
            mycalc.GetInfoContratto();

            string nomeDebito = nomeOccasionale(curr);

            if (EP.MainEntryExists()) {
                string msg = "ATTENZIONE! Se si prosegue, le scritture dovranno essere riviste a mano, poiché " +
                             "non rispecchieranno l'attuale applicazione della quota esente, essendo " +
                             "la prestazione già stata pagata in precedenza nell'anno. Si desidera rigenerarle comunque? (è SCONSIGLIATO)";
                if (mycalc.CompensoLordoPagato > 0) {
                    if (this.silent) return false;
                    var shower = MetaFactory.factory.getSingleton<IMessageShower>();
                    //txtCostoAnniPrec.Text != txtCostoPagato.Text
                    if (shower.Show(null, msg, "AVVISO IMPORTANTE", MessageBoxButtons.YesNo) != DialogResult.Yes)
                        return false;
                    //ShowMessage(msg, "AVVISO IMPORTANTE", false);
                }
            }


            DataRow mainEntry = EP.SetEntry(curr["description"], curr["datecompleted"], //era curr["adate"], task 8398
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);
            object idaccmotMain = curr["idaccmotive"];
            if (idaccmotMain == DBNull.Value) {
                ShowMessage("Non è stata impostata la causale per la prestazione.");
                return false;
            }

            string idepcontext = "PRESTAZ";
            object idaccRegistry = EP.GetSupplierAccountForRegistry(curr["idaccmotivedebit"], curr["idreg"]);
            object idaccmotMainDebit = curr["idaccmotivedebit"];
            if (idaccmotMainDebit == DBNull.Value) {
                idaccmotMainDebit = idaccmotMain;
            }

            if (idaccRegistry == null || idaccRegistry == DBNull.Value) {
                ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Attenzione, il contratto non ha l'indicazione dell'UPB");
                return false;
            }



            string idrelated = BudgetFunction.GetIdForDocument(curr);
            object idepexp = getIdEpExpByIdRelated(idrelated, 2);
            //if ((idepexp == null || idepexp == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
            //    ShowMessage("Non è stato trovato alcun impegno di budget per il contratto", "Errore");
            //    return false;
            //}

            DataTable tRiten = mycalc.calcolaRitenute(CfgFn.GetNoNullDecimal(curr["feegross"]));

            //Scrittura  : NETTO   -> Debito vs. fornitore
            //			   SPESE   ->	
            decimal sommaspese = 0;
            //Effettua una serie di scritture per ogni tipo spesa per cui sia stata configurata una causale
            foreach (DataRow rSpesa in spese.Rows) {
                var causaleSpesa =
                    tipiSpesa.Select(QHC.CmpEq("idlinkedrefund", rSpesa["idlinkedrefund"]))[0][
                        "idaccmotive"];
                var descrSpesa = tipiSpesa.Select(QHC.CmpEq("idlinkedrefund", rSpesa["idlinkedrefund"]))[0][
                    "description"];

                if (causaleSpesa == DBNull.Value) continue;
                string idrelatedRef = BudgetFunction.GetIdForDocument(rSpesa);
                object idepexpRef = getIdEpExpByIdRelated(idrelatedRef, 2);
                //if ((idepexpRef == null || idepexpRef == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                //    ShowMessage("Non è stato trovato alcun impegno di budget per la spesa n." + rSpesa["nrefund"],"Errore");
                //    return false;
                //}
                DataRow[] contiSpesa = EP.GetAccMotiveDetails(causaleSpesa);
                if (contiSpesa.Length == 0) continue;
                object idAccSpesa = contiSpesa[0]["idacc"];
                decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                sommaspese += importospesa;

                //EP.EffettuaScritturaImpegnoBudget(idepcontext, importospesa,
                //    idAccSpesa,
                //    curr["idreg"], curr["idupb"],
                //    curr["start"], curr["stop"],
                //    curr, causaleSpesa, idepexpRef, null, idrelatedRef, descrSpesa);

                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importospesa, 
                    idAccSpesa, 
                    curr["idreg"], curr["idupb"],
                    curr["start"], curr["stop"],
                    curr, causaleSpesa, curr["idcostpartition"], idepexpRef, null, idrelatedRef, descrSpesa);

				EP.EffettuaScritturaImpegnoBudget(idepcontext, importospesa,
					idaccRegistry,
					curr["idreg"], curr["idupb"],
					curr["start"], curr["stop"],
					// curr, idaccmotMainDebit, idepexpRef, null, idrelatedRef);
					curr, causaleSpesa, idepexpRef, null, idrelatedRef, nomeDebito);

				//<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale
			}

            decimal totale = CfgFn.GetNoNullDecimal(curr["feegross"]);
            decimal netto = totale - sommaspese;
            //if (usavariazioniperrit) netto -= totaleritenute;


            if (tRiten != null) {
                foreach (DataRow rit in tRiten.Select()) {
                    decimal amount = CfgFn.GetNoNullDecimal(rit["admintax"]);
                    //if (usavariazioniperrit) amount += CfgFn.GetNoNullDecimal(Rit["employtax"]);
                    if (amount == 0) continue;

                    object idaccmotiveCost = generaScritturaContributo(idepexp, amount, rit["taxcode"],
                        curr["idupb"], curr["start"], curr["stop"], idaccmotMain, rit, curr["idser"], curr,
                        doc.ToString(), curr["idcostpartition"]);
                    if (idaccmotiveCost == null) return false;

                }
            }

            //Effettua la scritt. residua sulla causale principale del costo + contributi senza causale specifica
            DataRow[] contiPrinc = EP.GetAccMotiveDetails(idaccmotMain);
            if (contiPrinc.Length == 0) {
                ShowMessage("Non è stata configurata la causale principale di costo. La scrittura non pareggerà.",
                    "Errore");
                return false;
            }

			//EP.EffettuaScritturaImpegnoBudget(idepcontext, netto,
			//	contiPrinc[0]["idacc"],
			//	curr["idreg"], curr["idupb"],
			//	curr["start"], curr["stop"],
			//	curr, idaccmotMain, idepexp, null, idrelated, curr["description"]);

			EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, netto,
                contiPrinc[0]["idacc"],
                curr["idreg"], curr["idupb"],
                curr["start"], curr["stop"],
                curr, idaccmotMain, curr["idcostpartition"], idepexp, null, idrelated, curr["description"]);

            //Effettua la scrittura sul conto di debito vs fornitore
            EP.EffettuaScritturaImpegnoBudget(idepcontext, netto,
                idaccRegistry,
                curr["idreg"], curr["idupb"],
                curr["start"], curr["stop"],
                //curr, idaccmotMainDebit, idepexp, null, idrelated);
                curr, idaccmotMain, idepexp, null, idrelated, nomeDebito);
            //<--Causale del conto di debito, se non è stata impostata sarà usata la causale principale



            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;

        }


        bool generaScrittureFondoEconomale(DataRow curr, BudgetFunction bf) {
            object idupb = curr["idupb"];
            if ((idupb == DBNull.Value) && (curr["idexp"] != DBNull.Value)) {
                idupb = Conn.DO_READ_VALUE("expenseyear",
                    QHS.AppAnd(QHS.CmpEq("idexp", curr["idexp"]), QHS.CmpEq("ayear", esercizio)), "idupb");
            }

            object idpettycash = curr["idpettycash"];
            string filterpcash = QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idpettycash", idpettycash));
            DataTable pCaschSetup = Conn.RUN_SELECT("pettycashsetup", "*", null, filterpcash, null, false);
            if (pCaschSetup.Rows.Count == 0) {
                ShowMessage("Non è stata inserita la configuraz. del fondo economale per quest'anno", "Errore");
                return false;
            }

            DataRow pCash = pCaschSetup.Rows[0];
            object idaccPettycash = pCash["idacc"];
            if (idaccPettycash == DBNull.Value) {
                ShowMessage(
                    "Non è stato inserito il conto collegato al fondo economale nella configurazione del fondo economale.",
                    "Errore");
            }

            object idreg = curr["idreg"];
            object idpettycashreg = pCash["registrymanager"];
            if (idreg == DBNull.Value) {
                if (idpettycashreg != DBNull.Value) {
                    idreg = idpettycashreg;
                }
            }

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }
            //DataRow EntrySetup= DS.entrysetup.Rows[0];

            object doc = "Op. Fondo Econ. " +
                         curr["idpettycash"] + "/" +
                         curr["yoperation"].ToString().Substring(2, 2) + "/" +
                         curr["noperation"].ToString().PadLeft(6, '0');


            DataRow mainEntry = EP.SetUniqueEntry(curr["description"], curr["adate"],
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);
            object idaccmotCost = curr["idaccmotive_cost"];
            object idaccmotDebit = curr["idaccmotive_debit"];
            object idaccRegistry = EP.GetSupplierAccountForRegistry(idaccmotDebit, idreg);


            Tipocont currCont = getContabilizzazioneFondo(curr);
            if (idaccmotCost != DBNull.Value && currCont != Tipocont.ContNone) {
                ShowMessage(
                    "La causale di costo selezionata sarà ignorata poichè la spesa contabilizza un documento",
                    "Avviso", false);
                idaccmotCost = DBNull.Value;
            }

            if (idaccmotDebit != DBNull.Value && currCont == Tipocont.ContNone) {
                ShowMessage(
                    "La causale di debito selezionata sarà ignorata poichè la spesa non contabilizza un documento",
                    "Avviso", false);
                idaccmotDebit = DBNull.Value;
            }

            if (idaccmotDebit == DBNull.Value &&
                currCont != Tipocont.ContNone) {
                ShowMessage(
                    "Non è stata impostata la causale di debito. Sarà usata una causale di debito standard.", "Avviso",
                    false);
            }


            if (idaccmotCost == DBNull.Value &&
                currCont == Tipocont.ContNone) {
                ShowMessage("Non è stata impostata la causale di costo. Impossibile effettuare le scritture",
                    "Errore");
                return false;
            }

            string idepcontextCosto = "PSPESEC";
            string idepcontextDebito = "PSPESED";
            decimal importo = CfgFn.GetNoNullDecimal(curr["amount"]);
            string idrelated = BudgetFunction.GetIdForDocument(curr);

            DataRow RAccount = null;
            bool isDebito = true;
            object idacc = null;

            // A volte usano il groupbox della causale costo mettendo una causale di debito
            // invece di utilizzare il groupbox della causale di debito, perchè diventa disabilitato
            if (idaccmotCost != DBNull.Value) {
                idacc = getIdAccFromMotive(idaccmotCost);
                isDebito = !EP.isCosto(idacc);
            }
            else
            // hanno valorizzato una causale di debito 
            if (idaccmotDebit != DBNull.Value) {
                idacc = getIdAccFromMotive(idaccmotDebit);
                    isDebito = EP.isDebit(idacc);
                }

            //RAccount = EP.getRowIdAcc(idacc);

            //int flagAccountUsage = CfgFn.GetNoNullInt32(RAccount["flagaccountusage"]);
            //// con 65536 check flag 'Altre voci del passivo', 16 flag 'Conto di Debito'
            //isDebito = (flagAccountUsage & 65536) != 0 || (flagAccountUsage & 16) != 0;

            if (idaccmotCost != DBNull.Value && !isDebito) {

                object idepexp = getIdEpExpByIdRelated(idrelated, 2);

                //if ((idepexp == null || idepexp == DBNull.Value) && UsaImpegniDiBudget && esercizio > 2015) {
                //    ShowMessage("Non è stato trovato alcun impegno di budget per il compenso", "Errore");
                //    return false;
                //}


                //Scrittura : COSTO		A	DEBITO		contesto PSPESEC (P.SPESE COSTO)
                //			  DEBITO	A	F.ECONOMALE	contesto PSPESED (P.SPESE DEBITO)
                //che si semplifica in:
                //			  COSTO (PSPESEC)	A F.ECONOMALE (PSPESED)
                object idaccmotive = idaccmotCost;
                DataRow[] contiCosto = EP.GetAccMotiveDetails(idaccmotive.ToString());
                if (contiCosto.Length > 0) {
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextCosto, importo,
                        contiCosto[0]["idacc"],
                        idreg, idupb, curr["start"], curr["stop"], curr, idaccmotive, curr["idcostpartition"], idepexp, null, idrelated,
                        curr["description"]);
                    EP.EffettuaScritturaImpegnoBudget(idepcontextDebito, importo,
                        idaccPettycash,
                        idpettycashreg, idupb, curr["start"], curr["stop"], curr, idaccmotive, idepexp, null,
                        $"foeco§{curr["idpettycash"]}", //14947
                        curr["description"]);
                }
                else {
                    ShowMessage("La causale di costo non è ben configurata.", "Errore");
                    return false;
                }

            }
            else {
                //Scrittura :  DEBITO	A	F.ECONOMALE	contesto PSPESED (P.SPESE DEBITO)			
                var debitiImpegni = getImportiImpegni(curr, currCont);
                var debitoResiduo = importo;

                foreach (var idepexp in debitiImpegni.Keys) {
                    //if (debitoResiduo == 0) break;
                    var debitoCorrente = debitiImpegni[idepexp];
                    if (debitoCorrente.amount > debitoResiduo) {
                        debitoCorrente.amount = debitoResiduo;
                    }

                    debitoResiduo -= debitoCorrente.amount;
                    var myIdUpb = idupb;
                    if (myIdUpb == DBNull.Value) {
                        myIdUpb = Conn.DO_READ_VALUE("epexpyear",
                            QHS.AppAnd(QHS.CmpEq("idepexp", idepexp), QHS.CmpEq("ayear", esercizio)), "idupb");
                    }

                    var myIdReg = idreg;
                    if (myIdReg == DBNull.Value) {
                        myIdReg = Conn.DO_READ_VALUE("epexp",
                            QHS.CmpEq("idepexp", idepexp), "idreg");
                    }

                    EP.EffettuaScritturaImpegnoBudget(idepcontextDebito, debitoCorrente.amount,
                        idaccRegistry,
                        myIdReg, myIdUpb, curr["start"], curr["stop"], curr, debitoCorrente.idaccmotive, idepexp, null,
                        idrelated);
                    EP.EffettuaScritturaImpegnoBudget(idepcontextDebito, debitoCorrente.amount,
                        idaccPettycash,
                        //idpettycashreg, myIdUpb, curr["start"], curr["stop"], curr, idaccmotDebit,idepexp,null, idrelated);
                        idpettycashreg, myIdUpb, curr["start"], curr["stop"], curr, debitoCorrente.idaccmotive, idepexp,
                        null, $"foeco§{curr["idpettycash"]}"); //14947
                }

                if (debitoResiduo != 0) {
                    EP.EffettuaScritturaImpegnoBudget(idepcontextDebito, debitoResiduo,
                        //idaccRegistry,idreg, idupb, curr["start"], curr["stop"], curr, idaccmotDebit,null,null,idrelated);
                        idaccRegistry, idreg, idupb, curr["start"], curr["stop"], curr, idaccmotCost, null, null,
                        idrelated);
                    EP.EffettuaScritturaImpegnoBudget(idepcontextDebito, debitoResiduo,
                        //idaccPettycash,idpettycashreg, idupb, curr["start"], curr["stop"], curr, idaccmotDebit, null, null, idrelated);
                        idaccPettycash, idpettycashreg, idupb, curr["start"], curr["stop"], curr, idaccmotCost, null,
                        null, $"foeco§{curr["idpettycash"]}"); //14947
                }


            }


            EP.RemoveEmptyDetails();
            return true;

        }

        private bool generaScrittureLiquidazioneRitenute(DataRow curr, BudgetFunction bf) {

            if (!usaContiPresentazioneDocumenti)
                return false; // Le Scritture verranno effettuate in fase di trasmissione

            // Effettua scritture del Tipo Debito a CONTO PRESENTAZIONE DOCUMENTI IN BANCA
            object idaccPayment = _rConfig["idacc_bankpaydoc"];

            object codiceriten = curr["taxcode"];


            //Prende la causale di pagamento associato alla liqudazione (pay) della ritenuta 
            TaxInfo tInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(codiceriten));
            object taxref = tInfo.taxRef();

            if (tInfo == null) {
                ShowMessage("La ritenuta di codice " + taxref + " non è stata configurata per l'E/P");
                return false;
            }
            //Per ogni conto associato alla causale genera una scrittura 


            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }



            string filterExp = QHS.AppAnd(QHS.CmpEq("ytaxpay", curr["ytaxpay"]),
                QHS.CmpEq("ntaxpay", curr["ntaxpay"]),
                QHS.CmpEq("ayear", esercizio), QHS.CmpEq("autokind", 2),
                QHS.CmpEq("nphase", Conn.GetSys("maxexpensephase")));

            //Movimenti delle liquidazioni ritenute
            var tSpesaLiquidazioneRitenuta = Conn.RUN_SELECT("taxpayexpenseview",
                "idexp,idser,curramount,idreg,idupb,description", null,
                filterExp,
                null, true);
            if (tSpesaLiquidazioneRitenuta.Rows.Count == 0) {
                ShowMessage(
                    "Alla liquidazione non è associato alcun movimento di spesa con anagrafica. Impossibile generare scritture.",
                    "Avviso");
                return false;
            }

            DataRow mainEntry = EP.SetEntry(curr["description"], curr["adate"],
                DBNull.Value, DBNull.Value, EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(mainEntry);
            //ci possono essere più righe in tSpesa, le prendiamo tutte
            foreach (DataRow rSpesa in tSpesaLiquidazioneRitenuta.Rows) {
                EP.EffettuaScritturaIdRelated("LIQRIT", CfgFn.GetNoNullDecimal(rSpesa["curramount"]), idaccPayment,
                    rSpesa["idreg"], rSpesa["idupb"], null, null, "expense§" + rSpesa["idexp"].ToString(),
                    rSpesa["description"]); //idaccmotiveRiten
            }

            DataRow rLiquidazione = tSpesaLiquidazioneRitenuta.Rows[0];
            DataTable expenseTax = Conn.RUN_SELECT("expensetax", "*", null,
                QHS.AppAnd(QHS.CmpEq("ytaxpay", curr["ytaxpay"]),
                    QHS.CmpEq("ntaxpay", curr["ntaxpay"])), null, false);

            //decimal totRitenute = MetaData.SumColumn(expenseTax, "employtax");

            //L'importo serve sempre 
            //decimal importo = MetaData.SumColumn(tSpesa, "curramount");

            object idupbMain = rLiquidazione["idupb"];
            foreach (DataRow rDettaglioRitenuta in expenseTax.Rows) {
                var rExpView = Conn.readObject("expenseview", QHS.CmpEq("idexp", rDettaglioRitenuta["idexp"]),
                    "idser,idupb,description");
                //Conn.DO_READ_VALUE("expenselast", QHS.CmpEq("idexp", rDettaglioRitenuta["idexp"]),"idser");
                DataRow rMotive = tInfo.getInfo(CfgFn.GetNoNullInt32(rExpView["idser"]));

                if (rMotive == null) {
                    ShowMessage("La ritenuta di codice " + taxref + " non è stata configurata per l'E/P");
                    return false;
                }

                object idaccmotiveDebit = rMotive["idaccmotive_debit"];
                object idaccmotiveRiten = rMotive["idaccmotive_pay"];

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveRiten);
                if (rEntries.Length == 0) {
                    ShowMessage("La ritenuta di codice " + taxref + " non ben configurata per l'E/P");
                    return false;
                }

                object idAccRiten = rEntries[0]["idacc"];
                var admintax = CfgFn.GetNoNullDecimal(rDettaglioRitenuta["admintax"]);

                DataTable regs = _teh.GetIdRegFor(rDettaglioRitenuta["taxcode"], rDettaglioRitenuta["idcity"],
                    rDettaglioRitenuta["idfiscaltaxregion"]);

                var idexp = CfgFn.GetNoNullInt32(rDettaglioRitenuta["idexp"]);
                string idrelatedDebitoContoErario =
                    "ritenuta§" + idexp.ToString() + "§" + rDettaglioRitenuta["taxcode"].ToString();

                //la scrittura sui contributi varia a seconda di idaccmotiveDebit
                if (admintax != 0) {
                    if (idaccmotiveDebit == DBNull.Value) {
                        //solo ove non è configurato il debito conto ente ossia c'è la liquidazione DIRETTA
                        // Ciclo sui Contributi C/Ente                 

                        //Liquidazione ritenute: effettua una scrittura dal conto di pagamento delle ritenute
                        // al conto PRESENTAZIONE DOCUMENTI IN BANCA o BANCA
                        var list = getIdImpegnoBudget(idexp, rDettaglioRitenuta["taxcode"], DBNull.Value, admintax);
                        if (list.Count > 0) {
                            foreach (var deb in list) {
                                EP.EffettuaScritturaImpegnoBudget("LIQRIT", deb.amount, idAccRiten,
                                    deb.idreg, rExpView["idupb"], null, deb.idaccmotive, deb.idepexp, null,
                                    deb.idrelated, rExpView["description"]); //idaccmotiveRiten
                                //EP.EffettuaScritturaIdRelated("LIQRIT", deb.amount, idaccPayment,
                                //    deb.idreg, idupbMain, null, deb.idaccmotive,null,null); //idaccmotiveRiten
                            }
                        }
                        else {
                            //non dovrebbe mai passare di qua, l'impegno deve trovarlo per i contributi
                            foreach (DataRow currReg in regs.Rows) {
                                decimal amountToConsider = admintax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                                EP.EffettuaScritturaImpegnoBudget("LIQRIT", amountToConsider, idAccRiten,
                                    currReg["idreg"], rExpView["idupb"], null, idaccmotiveRiten, null, null, null,
                                    rExpView["description"]); // rExpView["idreg"]
                                //EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idaccPayment,
                                //    currReg["idreg"], idupbMain, null, idaccmotiveRiten,null,null); //idaccmotiveRiten
                            }
                        }

                    }
                    else {
                        //Liquidazione normale, con uscita-entrata- uscita per versamento ritenute
                        foreach (DataRow currReg in regs.Rows) {
                            decimal amountToConsider = admintax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                            EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idAccRiten,
                                currReg["idreg"], idupbMain, null, idaccmotiveRiten, idrelatedDebitoContoErario,
                                rExpView["description"]); //rLiquidazione["idreg"]
                            //EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idaccPayment,
                            //    currReg["idreg"], idupbMain, null, idaccmotiveRiten,null,null));
                        }

                    }

                    //chiusura contributi, parte comune  LA INGLOBO NEI CICLI PRECEDENTI
                    //EP.EffettuaScrittura("LIQRIT", admintax, idaccPayment, rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotiveRiten);                    
                }

                //la scrittura sulle ritenute è sempre la stessa
                var employtax = CfgFn.GetNoNullDecimal(rDettaglioRitenuta["employtax"]);
                if (employtax != 0) {
                    //totale ritenute
                    foreach (DataRow currReg in regs.Rows) {
                        decimal amountToConsider = employtax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                        EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idAccRiten, currReg["idreg"], "0001",
                            null,
                            idaccmotiveRiten, idrelatedDebitoContoErario, rExpView["description"].ToString());
                        //EP.EffettuaScrittura("LIQRIT", amountToConsider, idaccPayment, currReg["idreg"], "0001", null,idaccmotiveRiten);
                    }
                }
            }



            //////////  CORREZIONE RITENUTE  ////////////
            DataTable expenseTaxCorrige = Conn.RUN_SELECT("expensetaxcorrige", "*", null,
                QHS.AppAnd(QHS.CmpEq("ytaxpay", curr["ytaxpay"]),
                    QHS.CmpEq("ntaxpay", curr["ntaxpay"])), null, false);

            //decimal totRitenute = MetaData.SumColumn(expenseTax, "employtax");

            //L'importo serve sempre 
            //decimal importo = MetaData.SumColumn(tSpesa, "curramount");

            foreach (DataRow rDettaglioCorrige in expenseTaxCorrige.Rows) {
                var rExpView = Conn.readObject("expenseview", QHS.CmpEq("idexp", rDettaglioCorrige["idexp"]),
                    "idser,idupb,description");
                string idrelatedDebitoContoErario = "ritenuta§" + rDettaglioCorrige["idexp"].ToString() + "§" +
                                                    rDettaglioCorrige["taxcode"].ToString();

                //Conn.DO_READ_VALUE("expenselast", QHS.CmpEq("idexp", rDettaglioRitenuta["idexp"]),"idser");
                DataRow rMotive = tInfo.getInfo(CfgFn.GetNoNullInt32(rExpView["idser"]));

                if (rMotive == null) {
                    ShowMessage("La ritenuta di codice " + taxref + " non è stata configurata per l'E/P");
                    return false;
                }

                object idaccmotiveDebit = rMotive["idaccmotive_debit"];
                object idaccmotiveRiten = rMotive["idaccmotive_pay"];

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveRiten);
                if (rEntries.Length == 0) {
                    ShowMessage("La ritenuta di codice " + taxref + " non ben configurata per l'E/P");
                    return false;
                }

                object idAccRiten = rEntries[0]["idacc"];
                var admintax = CfgFn.GetNoNullDecimal(rDettaglioCorrige["adminamount"]);

                DataTable regs = _teh.GetIdRegFor(rDettaglioCorrige["taxcode"], rDettaglioCorrige["idcity"],
                    rDettaglioCorrige["idfiscaltaxregion"]);

                //la scrittura sui contributi varia a seconda di idaccmotiveDebit
                if (admintax != 0) {
                    if (idaccmotiveDebit == DBNull.Value) {
                        //solo ove non è configurato il debito conto ente
                        // Ciclo sui Contributi C/Ente                 
                        var idexp = CfgFn.GetNoNullInt32(
                            rDettaglioCorrige[
                                "idexp"]); //Movimento di spesa collegato alle ritenute, non della liquidazione

                        //Liquidazione ritenute: effettua una scrittura dal conto di pagamento delle ritenute
                        // al conto PRESENTAZIONE DOCUMENTI IN BANCA o BANCA

                        var list = getIdImpegnoBudget(idexp, codiceriten, DBNull.Value, admintax);
                        if (list.Count > 0) {
                            foreach (var deb in list) {
                                EP.EffettuaScritturaImpegnoBudget("LIQRIT", deb.amount, idAccRiten,
                                    deb.idreg, rExpView["idupb"], null,
                                    idaccmotiveRiten, deb.idepexp, null, //era deb.idrelated
                                    idrelatedDebitoContoErario, rExpView["description"]);
                                //EP.EffettuaScrittura("LIQRIT", deb.amount, idaccPayment,
                                //    deb.idreg, idupbMain, null, idaccmotiveRiten);
                            }
                        }
                        else {
                            foreach (DataRow currReg in regs.Rows) {
                                decimal amountToConsider = admintax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                                EP.EffettuaScritturaImpegnoBudget("LIQRIT", amountToConsider, idAccRiten,
                                    currReg["idreg"], rExpView["idupb"], null,
                                    idaccmotiveRiten, null, null, null,
                                    rExpView["description"]); // rExpView["idreg"]
                                //EP.EffettuaScrittura("LIQRIT", amountToConsider, idaccPayment,
                                //    currReg["idreg"], idupbMain, null, idaccmotiveRiten);
                            }
                        }

                    }
                    else {
                        //contributi seconda versione

                        foreach (DataRow currReg in regs.Rows) {
                            decimal amountToConsider = admintax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                            EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idAccRiten,
                                currReg["idreg"], idupbMain, null,
                                idaccmotiveRiten, idrelatedDebitoContoErario,
                                rExpView["description"]); //rLiquidazione["idreg"]
                            //EP.EffettuaScrittura("LIQRIT", amountToConsider, idaccPayment,
                            //    currReg["idreg"], idupbMain, null, idaccmotiveRiten);
                        }

                    }

                    //chiusura contributi, parte comune  LA INGLOBO NEI CICLI PRECEDENTI
                    //EP.EffettuaScrittura("LIQRIT", admintax, idaccPayment, rLiquidazione["idreg"], rLiquidazione["idupb"], null, idaccmotiveRiten);                    
                }

                //la scrittura sulle ritenute è sempre la stessa
                var employtax = CfgFn.GetNoNullDecimal(rDettaglioCorrige["employamount"]);
                if (employtax != 0) {
                    //totale ritenute
                    foreach (DataRow currReg in regs.Rows) {
                        decimal amountToConsider = employtax * CfgFn.GetNoNullDecimal(currReg["quota"]);
                        EP.EffettuaScritturaIdRelated("LIQRIT", amountToConsider, idAccRiten,
                            currReg["idreg"], "0001", null,
                            idaccmotiveRiten, idrelatedDebitoContoErario, rExpView["description"]);
                        //EP.EffettuaScrittura("LIQRIT", amountToConsider, idaccPayment, currReg["idreg"], "0001", null,
                        //    idaccmotiveRiten);
                    }
                }
            }






            ///////////////////////////////               

            EP.RemoveEmptyDetails();

            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;

        }

        struct totaliLiquidazioneKind {
            public decimal debito;
            public decimal credito;
            public decimal iva;
            public decimal taxable;

            public decimal delPeriodo;
        };

        private totaliLiquidazioneKind _totaliLiq;
        private totaliLiquidazioneKind _totaliLiq12;
        private totaliLiquidazioneKind _totaliLiqSplit;

        private object _ivaProrataPerc;
        private object _ivaMixedPerc;

        decimal getProrata(DataRow rLiq) {
            DateTime dataFine = (DateTime) rLiq["stop"];
            if (_ivaProrataPerc == null) {
                _ivaProrataPerc = Conn.DO_READ_VALUE("iva_prorata", QHS.CmpEq("ayear", dataFine.Year), "prorata");
            }

            return CfgFn.GetNoNullDecimal(_ivaProrataPerc);
        }


        decimal getPromiscuo(DataRow rLiq) {
            DateTime dataFine = (DateTime) rLiq["stop"];
            if (_ivaMixedPerc == null) {
                _ivaMixedPerc = Conn.DO_READ_VALUE("iva_mixed", QHS.CmpEq("ayear", dataFine.Year), "mixed");
            }

            return CfgFn.GetNoNullDecimal(_ivaMixedPerc);

        }

        void calcolaTotaliIva(DataTable tableIva, DataRow curr) {
            decimal percPromiscuo = getPromiscuo(curr);
            decimal percProrata = getProrata(curr);

            _totaliLiq.credito = 0; //somma definitiva del  prorata riga per riga oppure sul totale
            //in base alla configuraazione            
            decimal venditeImmediata = 0;
            decimal venditeDeferred = 0;

            decimal debitoImmediato12 = 0;
            decimal debitoDifferito12 = 0;

            decimal debitoImmediatosplit = 0;
            decimal debitoDifferitosplit = 0;

            decimal creditoImmediato12 = 0;
            decimal creditoDifferito12 = 0;

            decimal impdebitoImmediato12 = 0;
            decimal impdebitoDifferito12 = 0;
            decimal impdebitoImmediatosplit = 0;
            decimal impdebitoDifferitosplit = 0;
            decimal impcreditoImmediato12 = 0;
            decimal impcreditoDifferito12 = 0;

            decimal acqcommImmediata = 0;
            decimal acqcommImmediataIndetr = 0;
            decimal acqcommDeferred = 0;
            decimal acqcommDeferredIndetr = 0;

            decimal acqpromImmediata = 0;
            decimal acqpromImmediataIndetr = 0;
            decimal acqpromDeferred = 0;
            decimal acqpromDeferredIndetr = 0;



            tableIva.Columns.Add("singola", typeof(Decimal));
            tableIva.Columns.Add("ivaindetraibile_vendite", typeof(Decimal));
            //tableIva.Columns.Add("mixed", typeof(Decimal));
            foreach (DataRow r in tableIva.Rows) {
                r["ivaindetraibile_vendite"] = 0;

                var istituzionale = (CfgFn.GetNoNullInt32(r["flagactivity"]) == 1);
                var commerciale = (CfgFn.GetNoNullInt32(r["flagactivity"]) == 2);
                var promiscuo = (CfgFn.GetNoNullInt32(r["flagactivity"]) == 3);
                var flagintracom = r["flagintracom"].ToString().ToUpper() != "N";

                var immediata = r["flagdeferred"].ToString().ToUpper() == "N";
                //è il registro che determina la natura dell'operazione 
                var acquisto = r["registerclass"].ToString().ToUpper() == "A";

                var fatturaDiAcquisto = r["kind"].ToString().ToUpper() == "A";
                var fatturaDiVendita = !fatturaDiAcquisto;

                var flagsplit = r["flagsplit"].ToString().ToUpper() == "S";

                if (istituzionale && !flagintracom && !flagsplit) {
                    continue;
                }

                if (!istituzionale && flagsplit && fatturaDiVendita) {
                    continue;
                }

                var taxable = CfgFn.GetNoNullDecimal(r["taxable"]);
                var imposta = CfgFn.GetNoNullDecimal(r["currivagrosspayed"]);
                var indetraibile = CfgFn.GetNoNullDecimal(r["currivaunabatable"]);
                if (istituzionale) indetraibile = imposta;



                if (acquisto) {
                    decimal prorataEvalued = 0;
                    decimal indetraibileSingolo = 0;

                    //calcola R["singola"],indetraibile_singolo
                    if (promiscuo) {
                        prorataEvalued = CfgFn.Round((imposta - indetraibile) * percPromiscuo * percProrata, 2);
                        if (modoCalcoloRigaPerRiga) {
                            //if (modoCalcoloRigaPerRiga)
                            r["singola"] = prorataEvalued;
                            indetraibileSingolo = imposta - prorataEvalued;
                        }
                        else {
                            r["singola"] = prorataEvalued;
                            indetraibileSingolo = indetraibile; // imposta - promiscuo_evalued;
                        }
                    }

                    if (commerciale) {
                        prorataEvalued = CfgFn.Round((imposta - indetraibile) * percProrata, 2);
                        if (modoCalcoloRigaPerRiga) {
                            r["singola"] = prorataEvalued;
                            indetraibileSingolo = imposta - prorataEvalued;
                        }
                        else {
                            r["singola"] = prorataEvalued; // imposta - indetraibile;
                            indetraibileSingolo = indetraibile;
                        }
                    }

                    if (istituzionale) {
                        r["singola"] = imposta; // imposta - indetraibile;
                        indetraibileSingolo = imposta;
                    }



                    if (immediata) {
                        if (promiscuo) {
                            acqpromImmediata += imposta;
                            acqpromImmediataIndetr += indetraibileSingolo;
                        }

                        if (commerciale) {
                            acqcommImmediata += imposta;
                            acqcommImmediataIndetr += indetraibileSingolo;
                        }

                        if (istituzionale) {
                            if (flagintracom) {
                                debitoImmediato12 += imposta;
                                impdebitoImmediato12 += taxable;
                            }

                            if (flagsplit) {
                                debitoImmediatosplit += imposta;
                                impdebitoImmediatosplit += taxable;
                            }
                        }
                    }
                    else {
                        if (promiscuo) {
                            acqpromDeferred += imposta;
                            acqpromDeferredIndetr += indetraibileSingolo;
                        }

                        if (commerciale) {
                            acqcommDeferred += imposta;
                            acqcommDeferredIndetr += indetraibileSingolo;
                        }

                        if (istituzionale) {
                            if (flagintracom) {
                                debitoDifferito12 += imposta;
                                impdebitoDifferito12 += taxable;
                            }

                            if (flagsplit) {
                                debitoDifferitosplit += imposta;
                                impdebitoDifferitosplit += taxable;
                            }
                        }
                    }

                    if (!istituzionale) {
                        _totaliLiq.credito += prorataEvalued;
                    }
                }
                else {
                    //vendita
                    if (istituzionale) {
                        //le vendite istituzionali incrementano il credito (anche se non dovrebbero esisterne
                        if (immediata) {
                            if (flagintracom) {
                                creditoImmediato12 += imposta;
                                impcreditoImmediato12 += taxable;
                            }
                        }
                        else {
                            if (flagintracom) {
                                creditoDifferito12 += imposta;
                                impcreditoDifferito12 += taxable;
                            }
                        }
                    }

                    if (!istituzionale) {

                        if (immediata) {
                            venditeImmediata += imposta;
                        }
                        else {
                            venditeDeferred += imposta;
                        }
                    }

                    r["singola"] = imposta;

                    if (promiscuo) {
                        decimal detraibile_vendite =
                            CfgFn.Round((imposta - indetraibile) * percPromiscuo * percProrata, 2);
                        decimal ivaindetraibile_vendite = imposta - detraibile_vendite;
                        r["ivaindetraibile_vendite"] = ivaindetraibile_vendite;
                    }

                    if (commerciale) {
                        decimal detraibile_vendite = CfgFn.Round((imposta - indetraibile) * percProrata, 2);
                        decimal ivaindetraibile_vendite = imposta - detraibile_vendite;
                        r["ivaindetraibile_vendite"] = ivaindetraibile_vendite;
                    }

                }

            } //foreach

            var detraibileImmediataComm = acqcommImmediata - acqcommImmediataIndetr;
            var detraibileDifferitaComm = acqcommDeferred - acqcommDeferredIndetr;
            var detraibileCommerciale = detraibileImmediataComm + detraibileDifferitaComm;
            var detraibileImmediataProm = acqpromImmediata - acqpromImmediataIndetr;
            var detraibileDifferitaProm = acqpromDeferred - acqpromDeferredIndetr;
            var detraibilePromiscui = detraibileImmediataProm + detraibileDifferitaProm;

            var detraibilePromiscuiPost = detraibilePromiscui;
            if (!modoCalcoloRigaPerRiga) {
                //promiscuo_evalued = CfgFn.Round((imposta - indetraibile) * perc_promiscuo, 2);
                detraibilePromiscuiPost = CfgFn.Round(
                    detraibilePromiscui * percPromiscuo, 2);
            }



            _totaliLiq.debito = venditeImmediata + venditeDeferred;

            var ivacredito = detraibileCommerciale + detraibilePromiscuiPost;

            if (!modoCalcoloRigaPerRiga) {
                //decimal ivacredito = detraibile_commerciale + detraibile_promiscui;
                _totaliLiq.credito = CfgFn.Round(ivacredito * percProrata, 2);
            }

            _totaliLiq.delPeriodo = _totaliLiq.debito - _totaliLiq.credito;

            var nettoIvadebImm = debitoImmediato12 - creditoImmediato12;
            var nettoImpdebImm = impdebitoImmediato12 - impcreditoImmediato12;

            var nettoIvadebDef = debitoDifferito12 - creditoDifferito12;
            var nettoImpdebDef = impdebitoDifferito12 - impcreditoDifferito12;

            _totaliLiq12.taxable = nettoImpdebImm + nettoImpdebDef;
            _totaliLiq12.iva = nettoIvadebImm + nettoIvadebDef;

            _totaliLiq12.debito = debitoImmediato12 + debitoDifferito12;
            _totaliLiq12.credito = creditoImmediato12 + creditoDifferito12;

            _totaliLiq12.delPeriodo = _totaliLiq12.iva;

            _totaliLiqSplit.taxable = impdebitoImmediatosplit + impdebitoDifferitosplit;
            _totaliLiqSplit.iva = debitoImmediatosplit + debitoDifferitosplit;

            _totaliLiqSplit.debito = debitoImmediatosplit + debitoDifferitosplit;

            _totaliLiqSplit.delPeriodo = _totaliLiqSplit.iva;


        }

        DataTable getTableIva(DataRow curr) {
            var param = new[] {curr["yivapay"], curr["nivapay"]};
            var dsIva = Conn.CallSP("get_ivapay", param, true);
            if (dsIva == null || dsIva.Tables.Count == 0) return null;
            return dsIva.Tables[0];
        }

        bool generaScrittureLiquidazioneIva(DataRow curr, BudgetFunction bf) {

            //if (tableIva.Rows.Count == 0) return; //non ci sono fatture in liquidazione
            DataTable tableIva = getTableIva(curr);
            if (tableIva == null || tableIva.Rows.Count == 0) {
                ShowMessage("Non ci sono righe da rigenerare oppure la liquidazione è stata salvata" +
                            "\n con una versione incompatibile alla rigenerazione", "Avviso");
                return false;
            }

            calcolaTotaliIva(tableIva, curr);

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            object idregVersamento = _rConfig["paymentagency"];
            object idregRimborso = _rConfig["refundagency"];

            object idregVersamento12 = _rConfig["paymentagency12"];
            object idregRimborso12 = _rConfig["refundagency12"];

            object idregVersamentoSplit = _rConfig["paymentagencysplit"];

            object idupb = "0001";
            object idaccunabatable = _rConfig["idacc_unabatable"];
            object idaccunabatableSplit = _rConfig["idacc_unabatable_split"];
            object idaccunabatableEstera = _rConfig["idacc_unabatable_estera"];
            object idaccunabatableRefund = _rConfig["idacc_unabatable_refund"];

            //object idaccPayment = _rConfig["idacc_bankpaydoc"];
            //object idaccProceeds = _rConfig["idacc_bankprodoc"];
            //TODO: eventualmente nelle fatture valorizzare idaccPayment in modo specifico in base al tesoriere associato alla fattura
            //   ammesso di trovare un modo di determinarlo

            //object doc = "Liquidazione IVA " + curr["ypay"] + "/" + curr["npay"];
            object doc = "Liquidazione IVA " + curr["yivapay"] + "/" + curr["nivapay"];

            //			if (EP.MainEntryExists()){
            //				if(ShowMessage("Attenzione, le scritture in E/P risultano già generate."+
            //					" Si desidera sovrascriverle per aggiornarle?","Avviso",
            //					MessageBoxButtons.OKCancel)==DialogResult.Cancel) return;
            //			}

            //object accountForIvaRefund = EP.GetAccountForIvaRefund();
            object erarioContoIvaDebito = EP.GetAccountForIvaPayment();

            //if (accountForIvaRefund == DBNull.Value && _totaliLiq.credito > 0) {
            //    string msg = "Non è stato configurato alcun conto per il rimborso dell'IVA"
            //                 +
            //                 "\nAndare dal menu CONFIGURAZIONE - ECONOMICO PATRIMONIALE - CONFIGURAZIONE ed impostare il conto Crediti v/Clienti o il conto Rimborso IVA"
            //                 + "\nLe scritture non verranno generate";
            //    ShowMessage(msg, "Errore");
            //    return false;
            //}

            if (erarioContoIvaDebito == DBNull.Value && _totaliLiq.debito > 0) {
                string msg = "Non è stato configurato alcun conto per il pagamento dell'IVA"
                             +
                             "\n Andare dal menu CONFIGURAZIONE - ECONOMICO PATRIMONIALE - CONFIGURAZIONE ed impostare il conto Debiti v/Fornitori o il conto Versamento IVA";
                ShowMessage(msg, "Errore");
                return false;
            }

            //object idaccRefund12 = EP.GetAccountForIvaRefund12();
            //if (idaccRefund12 == DBNull.Value && _totaliLiq12.credito > 0) {
            //    string msg = "Non è stato configurato alcun conto per il rimborso dell'IVA INTRA o Extra UE"
            //                 +
            //                 "\nAndare dal menu CONFIGURAZIONE - ECONOMICO PATRIMONIALE - CONFIGURAZIONE ed impostare il conto Crediti v/Clienti o il conto Rimborso IVA Intra ed Extra UE"
            //                 + "\nLe scritture non verranno generate";
            //    ShowMessage(msg, "Errore");
            //    return false;
            //}

            object erarioContoIvaDebito12 = EP.GetAccountForIvaPayment12();
            if (erarioContoIvaDebito12 == DBNull.Value && _totaliLiq12.debito > 0) {
                string msg = "Non è stato configurato alcun conto per il Versamento dell'IVA INTRA o Extra UE"
                             +
                             "\nAndare dal menu CONFIGURAZIONE - ECONOMICO PATRIMONIALE - CONFIGURAZIONE ed impostare il conto Debiti v/Clienti o il conto Versamento IVA Intra ed Extra UE"
                             + "\nLe scritture non verranno generate";
                ShowMessage(msg, "Errore");
                return false;
            }

            object erarioContoIvaDebitoSplit = EP.GetAccountForIvaPaymentSplit();
            if (erarioContoIvaDebitoSplit == DBNull.Value && _totaliLiqSplit.debito > 0) {
                string msg = "Non è stato configurato alcun conto per il Versamento dell'IVA Split Payment"
                             +
                             "\nAndare dal menu CONFIGURAZIONE - ECONOMICO PATRIMONIALE - CONFIGURAZIONE ed impostare il conto Debiti v/Clienti o il conto Versamento IVA Split Payment"
                             + "\nLe scritture non verranno generate";
                ShowMessage(msg, "Errore");
                return false;
            }

            object dataLiquidazione = curr["dateivapay"]; // meta.GetSys("datacontabile");
            DataRow mainEntry = EP.SetEntry(doc, dataLiquidazione, doc, dataLiquidazione,
                EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(mainEntry);
            decimal ivaCredito = 0;
            decimal ivaDebito = 0;
            decimal ivaCredito12 = 0;
            decimal ivaDebito12 = 0;
            decimal ivaDebitoSplit = 0;

            DataTable invoiceKindYear = Conn.RUN_SELECT("invoicekindyear", "*", null, QHS.CmpEq("ayear", esercizio),
                null, false);

            //Hashtable hashImpBudget = new Hashtable();
            tableIva.TableName = "invoicedetail";
            foreach (DataRow rFattura in tableIva.Rows) {
                string idrelatedDoc = BudgetFunction.GetIdForDocument(rFattura);

                object idupb_iva = rFattura["idupb"];
                bool istituzionale = CfgFn.GetNoNullInt32(rFattura["flagactivity"]) == 1;
                bool flagintracom = rFattura["flagintracom"].ToString().ToUpper() != "N";
                bool flagsplit = rFattura["flagsplit"].ToString().ToUpper() != "N";
                bool tipoFatturaacquisto = rFattura["kind"].ToString().ToUpper() == "A";


                bool tipoFatturavendita = !tipoFatturaacquisto;

                if (istituzionale && !flagintracom && !flagsplit) continue;

                if (!istituzionale && flagsplit && tipoFatturavendita) {
                    continue;
                }

                decimal ivaDetraibile =
                    CfgFn.GetNoNullDecimal(rFattura["singola"]); //campo riempito in fase di calc.totali

                decimal ivaindetraibile_vendite = CfgFn.GetNoNullDecimal(rFattura["ivaindetraibile_vendite"]);
                if (ivaDetraibile == 0) continue;
                decimal ivaIndetraibile = CfgFn.GetNoNullDecimal(rFattura["currivagrosspayed"]) - ivaDetraibile;

                string flagVa = rFattura["registerclass"].ToString().ToUpper();
                bool registroAcquisto = (rFattura["registerclass"].ToString().ToUpper() == "A");
                string flagVAfattura = rFattura["kind"].ToString().ToUpper();

                object tipoDoc = rFattura["idinvkind"];
                string descrTipoDoc =
                    Conn.readValue("invoicekind", q.eq("idinvkind", tipoDoc), "description").ToString();
                if (invoiceKindYear.Select(QHC.CmpEq("idinvkind", tipoDoc)).Length == 0) {
                    var msg = "Attenzione il tipo documento " + descrTipoDoc +
                              "  è configurato per l'anno corrente.";
                    ShowMessage(msg, "Errore");
                    return false;
                }

                DataRow tipoDocYear = invoiceKindYear.Select(QHC.CmpEq("idinvkind", tipoDoc))[0];

                object contoIvaCreditoDebito = DBNull.Value;

                bool isDeferred = (rFattura["flagdeferred"].ToString().ToUpper() == "S");
                bool isIntraCom = (rFattura["flagintracom"].ToString().ToUpper() != "N");
                bool isFlagReverseCharge = (rFattura["flag_reverse_charge"].ToString().ToUpper() != "N");
                bool isSplit = (rFattura["flagsplit"].ToString().ToUpper() == "S");
                object idepexp = DBNull.Value;
                object idepacc = DBNull.Value;
                if ((isIntraCom | isFlagReverseCharge) && (flagVa != flagVAfattura)) {
                    if (isDeferred) {
                        contoIvaCreditoDebito = (tipoDocYear["idacc_deferred_intra"] != DBNull.Value)
                            ? tipoDocYear["idacc_deferred_intra"]
                            : tipoDocYear["idacc_intra"];
                    }
                    else {
                        contoIvaCreditoDebito = tipoDocYear["idacc_intra"];
                    }

                    idepexp = rFattura["idepexp"];
                    idepacc = rFattura["idepacc"];
                }

                if (istituzionale && isSplit && registroAcquisto) {
                    contoIvaCreditoDebito = idaccunabatableSplit;
                }

                if (isSplit && (flagVa != flagVAfattura)) {
                    if (isDeferred) {
                        contoIvaCreditoDebito = (tipoDocYear["idacc_deferred_split"] != DBNull.Value)
                            ? tipoDocYear["idacc_deferred_split"]
                            : tipoDocYear["idacc_split"];
                    }
                    else {
                        contoIvaCreditoDebito = tipoDocYear["idacc_split"];
                    }

                    idepexp = rFattura["idepexp"];
                    idepacc = rFattura["idepacc"];
                }


                if ((!(isIntraCom | isFlagReverseCharge) && !isSplit) || (contoIvaCreditoDebito == DBNull.Value)) {
                    if (isDeferred) {
                        contoIvaCreditoDebito = (tipoDocYear["idacc_deferred"] != DBNull.Value)
                            ? tipoDocYear["idacc_deferred"]
                            : tipoDocYear["idacc"];
                    }
                    else {
                        contoIvaCreditoDebito = tipoDocYear["idacc"];
                    }
                }

                if (contoIvaCreditoDebito == DBNull.Value && !istituzionale) {

                    var msg = "Attenzione il tipo documento " + descrTipoDoc +
                              " non ha un conto per l'IVA configurato" +
                              "\nAndare dal menu CONFIGURAZIONE - IVA - TIPO DOCUMENTO e configurare il conto";
                    ShowMessage(msg, "Errore");
                    return false;
                }

                string idepcontext;

                int flagbit = CfgFn.GetNoNullInt32(rFattura["flagbit"]);
                bool RecuperoIVAEstera = ((flagbit & 64) != 0);

                if ((contoIvaCreditoDebito == DBNull.Value) && RecuperoIVAEstera) {
                    if (idaccunabatableEstera == DBNull.Value) {
                        var msg = "Attenzione. Conto di Debito per IVA estera istituzionale non trovato."+
                                  "\nAndare dal menu CONFIGURAZIONE - CONFIGURAZIONE(EP - IVA INTRA e Extra-UE) e configurare il conto";
                        ShowMessage(msg, "Errore");
                        return false;
                    }
                    contoIvaCreditoDebito = idaccunabatableEstera;
                }

                //Salta le scritture per la fatture ist. senza conto iva (è presente già in fattura)
                if (contoIvaCreditoDebito == DBNull.Value) continue;

                if (flagVa == "V") {
                    idepcontext = "LIQIVADEB";
                    if (istituzionale) {
                        //NON ESISTONO VENDITE ISTITUZIONALI, sarebbe l'autofattura intra che ora non si usa più
                        if (isIntraCom) {
                            ivaCredito12 += ivaDetraibile;
                        }
                    }
                    else {
                        ivaDebito += ivaDetraibile;
                    }
                }
                else {
                    //ACQUISTO
                    idepcontext = "LIQIVACRED";
                    if (istituzionale) {
                        if (isIntraCom) {
                            // Se il dett.fattura è associato ad un impegno di budget aggiunge l'idepexp ad una lista, e non incrementa ivaDebito12.
                            //if (rFattura["idepexp"] != DBNull.Value) {
                            //    hashImpBudget[rFattura["idepexp"]] = ivaDetraibile;
                            //}
                            //else {                                
                            ivaDebito12 += ivaDetraibile;
                            //}
                        }

                        if (isSplit) {
                            ivaDebitoSplit += ivaDetraibile;
                        }
                    }
                    else {
                        ivaCredito += ivaDetraibile;
                    }
                }

                object idreg = rFattura["idreg"];
                if (istituzionale) {
                    if (flagVa == "V") {
                        if (isIntraCom) {
                            idreg = idregRimborso12; //ormai in disuso, non passerà mai di qua
                        }
                    }
                    else {
                        if ((isIntraCom)&& !RecuperoIVAEstera) {
                            idreg = idregVersamento12;
                        }

                        //if (isSplit) {
                        //    idreg = idregVersamentoSplit;
                        //}
                    }
                }

                if (ivaindetraibile_vendite != 0 && idepexp != DBNull.Value) {
                    object idupbIndetr = rFattura["idupb_epexp"];
                    object idrelated = rFattura["idrelated_epexp"];
                    ;

                    EP.EffettuaScritturaImpegnoBudget(idepcontext, ivaindetraibile_vendite, contoIvaCreditoDebito,
                        idreg, idupbIndetr, null, null, idepexp, null, idrelated, "Iva indetraibile");
                    EP.EffettuaScritturaIdRelated(idepcontext, ivaDetraibile - ivaindetraibile_vendite,
                        contoIvaCreditoDebito.ToString(), idreg, idupb_iva, null,
                        null, idrelatedDoc, null);
                    //EP.EffettuaScritturaIdRelated(idepcontext, ivaDetraibile - ivaindetraibile_vendite, contoIvaCreditoDebito.ToString(),
                    //	idreg, idupb_iva, null,
                    //	null, idrelated.ToString(), null);
                }
                else {
                    if (ivaindetraibile_vendite != 0 && idepacc != DBNull.Value) {
                        object idupbIndetr = rFattura["idupb_epacc"];
                        object idrelated = rFattura["idrelated_epacc"];
                        EP.EffettuaScritturaImpegnoBudget(idepcontext, ivaindetraibile_vendite, contoIvaCreditoDebito,
                            idreg, idupbIndetr, null, null, null, idepacc, idrelated, "Iva indetraibile");
                        EP.EffettuaScritturaIdRelated(idepcontext, ivaDetraibile - ivaindetraibile_vendite,
                            contoIvaCreditoDebito.ToString(), idreg, idupb_iva, null,
                            null, idrelatedDoc, null);
                    }
                    else {
                            EP.EffettuaScritturaIdRelated(idepcontext, ivaDetraibile, contoIvaCreditoDebito.ToString(),
                                idreg, idupb_iva, null,
                                null, idrelatedDoc, null);
                    }
                }


                //task 9849 questa scrittura sarà fatta in elenco trasm.
                //if (esercizio < 2017) { //non si vuole la retrocompatibilità
                //    if (usaContiPresentazioneDocumenti && scrittureDaFareDebito) {
                //        EP.EffettuaScrittura("PAGAM", amount, idaccPayment.ToString(), idreg, idupb_iva, null);
                //        EP.EffettuaScrittura("PAGAM", amount, erarioContoIvaDebito, idreg, idupb, null);
                //    }
                //}


                //if (usaContiPresentazioneDocumenti && scrittureDaFareCredito) {
                //    EP.EffettuaScrittura("INCAS", amount, idaccProceeds.ToString(), idreg, idupb_iva, null);
                //    EP.EffettuaScrittura("INCAS", amount, accountForIvaRefund, idreg, idupb, null);
                //}
            }

            //14947  Debito IVA v/Erario---->Mettere idrelated simile a ivapay§2019§33
            string idrelatedIvaPay = BudgetFunction.GetIdForDocument(curr);

            //EP.EffettuaScrittura("LIQIVADEB", ivaDebito - ivaCredito, erarioContoIvaDebito, idregVersamento, idupb,	null);
            EP.EffettuaScritturaIdRelated("LIQIVADEB", ivaDebito - ivaCredito, erarioContoIvaDebito, idregVersamento,
                idupb, null, null, idrelatedIvaPay, null);

            //EP.EffettuaScrittura("LIQIVADEB", ivaDebito12 - ivaCredito12, erarioContoIvaDebito12, idregVersamento,	idupb, null);
            EP.EffettuaScritturaIdRelated("LIQIVADEB", ivaDebito12 - ivaCredito12, erarioContoIvaDebito12,
                idregVersamento, idupb, null, null, idrelatedIvaPay, null);

            //EP.EffettuaScrittura("LIQIVADEB", ivaDebitoSplit, erarioContoIvaDebitoSplit, idregVersamento, idupb, null);
            EP.EffettuaScritturaIdRelated("LIQIVADEB", ivaDebitoSplit, erarioContoIvaDebitoSplit, idregVersamento,
                idupb, null, null, idrelatedIvaPay, null);



            // Nel metodo CalcolaTabPageIva la valorizzazione di ["singola"] è puramente un'assegnazione senza considare se è INTRA
            // poi, quando si calcola le varie variabili fa i controlli e in caso di INTRA scambia i valori.
            // Quindi, adesso, in GeneraScritture() quando usiamo ["singola"] per valorizzare delle variabili ITRASTAT dobbiamo fare lo scambio.

            //decimal totaleIvaDebito12Ep = ivaDebito12;
            //decimal totaleIvaCredito12Ep = ivaCredito12;
            //// Questo valore non ha il contributo dell'iva indetraibile associata all'impegno di budget.

            //decimal totaleIvaDebitoSplitLiqIva = ivaDebitoSplit;


            //if (totaleIvaCredito12Ep != 0 && idaccRefund12 == DBNull.Value) {
            //    string msg = "Attenzione il conto generale per il rimborso iva intrastat " +
            //                 "non è stato configurato." +
            //                 "\nAndare dal menu CONFIGURAZIONE - Configurazione Annuale - EP - Iva e configurare il conto";
            //    ShowMessage(msg, "Errore");
            //    return false;
            //}
            //if (totaleIvaCredito12Ep != 0)
            //    EP.EffettuaScrittura("LIQIVACRED", totaleIvaCredito12Ep, idaccRefund12, idregRimborso12, idupb, null);


            //if ((totaleIvaDebito12Ep != 0 || hashImpBudget.Count > 0) && erarioContoIvaDebito12 == DBNull.Value) {
            //    const string msg = "Attenzione il conto generale per il pagamento iva intrastat " +
            //                       "non è stato configurato." +
            //                       "\nAndare dal menu CONFIGURAZIONE - Configurazione Annuale - EP - Iva e configurare il conto";
            //    ShowMessage(msg, "Errore");
            //    return false;
            //}



            /* Scrittura di chiusura del debito iva indetraibile.
             * Erario c/IVA   A     Banca              
             * SEZIONE DISMESSA A SEGUITO DEL TASK 9849 in cui stiamo spostando la scrittura in fase trasmissione del movimento di liq.iva
             * Solo per le fatture "Acquisti Istituzionali con IVA INTRA-12" verrà riportato il num. dell'impegno di budget del dettaglio fattura, sul dettaglio scrittura 
             * dell'iva indetraibile, ove l'impegno di budget fosse imputato ad un conto di debito.
             * Per la parte restante di iva indetraibuile, il comportamento resta uguale a quello attuale.
            */
            //foreach (DictionaryEntry rHash in hashImpBudget) {
            //    EP.EffettuaScritturaImpegnoBudget("LIQIVADEB", CfgFn.GetNoNullDecimal(rHash.Value), erarioContoIvaDebito12,
            //        idregVersamento12, idupb, null, null, rHash.Key, null, null);
            //}
            //if (totaleIvaDebito12Ep != 0) {
            //    // Questa scrittura viene fatta ugualmente, e si riferisce alla parte residua
            //    EP.EffettuaScrittura("LIQIVADEB", totaleIvaDebito12Ep, erarioContoIvaDebito12, idregVersamento12, idupb, null);
            //}

            //if (totaleIvaDebitoSplitLiqIva != 0 && erarioContoIvaDebitosplit == DBNull.Value) {
            //    string msg = "Attenzione il conto generale per il pagamento iva Istituzionale Split Payment " +
            //                 "non è stato configurato." +
            //                 "\nAndare dal menu CONFIGURAZIONE - Configurazione Annuale - EP - Iva e configurare il conto";
            //    ShowMessage(msg, "Errore");
            //    return false;
            //}
            //if (totaleIvaDebitoSplitLiqIva != 0) {
            //    EP.EffettuaScrittura("LIQIVADEB", totaleIvaDebitoSplitLiqIva, erarioContoIvaDebitosplit, idregVersamentoSplit,
            //        idupb, null);
            //}

            //if (usaContiPresentazioneDocumenti) {
            //    foreach (DictionaryEntry rHash in hashImpBudget) {
            //        EP.EffettuaScritturaImpegnoBudget("PAGAM", CfgFn.GetNoNullDecimal(rHash.Value), idaccPayment,
            //            idregVersamento12, idupb, null, null, rHash.Key, null, null);
            //        EP.EffettuaScritturaImpegnoBudget("PAGAM", CfgFn.GetNoNullDecimal(rHash.Value), erarioContoIvaDebito12,
            //           idregVersamento12, idupb, null, null, rHash.Key, null, null);
            //    }
            //    if (totaleIvaDebito12Ep != 0) {
            //        // Questa scrittura viene fatta ugualmente, e si riferisce alla parte residua
            //        EP.EffettuaScrittura("PAGAM", totaleIvaDebito12Ep, erarioContoIvaDebito12, idregVersamento12, idupb, null);
            //        EP.EffettuaScrittura("PAGAM", totaleIvaDebito12Ep, idaccPayment, idregVersamento12, idupb, null);
            //    }

            //}

            #region gestione "SIENA" iva sul totale 

            //ivaCredito: somma delle iva detraibili riga per riga (se modo non è "riga per riga" non applica il prorata)
            //_totaliLiq.credito: importo che tiene conto del tipo calcolo (di solito è quindi minore di  ivaCredito)
            decimal costodetr = ivaCredito - _totaliLiq.credito;


            if (costodetr > 0 && idaccunabatable == DBNull.Value) {
                string msg = "Attenzione il conto generale per l'imputazione dell'iva indetrabile (passività)" +
                             "non è stato configurato." +
                             "\nAndare dal menu CONFIGURAZIONE - Configurazione Annuale - EP - Iva e configurare il conto";
                ShowMessage(msg, "Errore");
                return false;
            }

            if (costodetr < 0 && idaccunabatableRefund == DBNull.Value) {
                string msg = "Attenzione il conto generale per l'imputazione dell'iva indetrabile (attività)" +
                             "non è stato configurato." +
                             "\nAndare dal menu CONFIGURAZIONE - Configurazione Annuale - EP - Iva e configurare il conto";
                ShowMessage(msg, "Errore");
                return false;
            }

            //Era: EP.EffettuaScrittura("LIQIVACRED", _totaliLiq.credito, accountForIvaRefund, idregRimborso, idupb, null); 9849
            EP.EffettuaScrittura("LIQIVACRED", costodetr, erarioContoIvaDebito, idregVersamento, idupb, null);
            if (costodetr > 0) EP.EffettuaScrittura("LIQIVADEB", costodetr, idaccunabatable, null, idupb, null);
            if (costodetr < 0) EP.EffettuaScrittura("LIQIVACRED", -costodetr, idaccunabatableRefund, null, idupb, null);

            #endregion

            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        bool nuovaGestioneCsa(DataRow rowCsa) {
            int countRiep = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("csa_importriep_partition",
                QHS.CmpEq("idcsa_import", rowCsa["idcsa_import"]),
                "count(*)"));
            if (countRiep > 0) return true;
            int countVer = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("csa_importver_partition",
                QHS.CmpEq("idcsa_import", rowCsa["idcsa_import"]),
                "count(*)"));
            if (countVer > 0) return true;

            return false;
        }

        private bool verificaEffettuataCsa = false;
        private bool esitoVerificaCsa = false;

        private bool VerificaProblemiCsa(DataRow rowCsa) {
            //if (verificaEffettuataCsa) return esitoVerificaCsa;
            //verificaEffettuataCsa = true;
            esitoVerificaCsa = false;
            bool usa_partizioni = nuovaGestioneCsa(rowCsa);
            string sp_name = "check_csa_individuazione";
            if (usa_partizioni) sp_name = "check_csa_individuazione_partition";

            string errMess;
            DataSet ds = Conn.CallSP(sp_name,
                new object[] {rowCsa["idcsa_import"], this.esercizio}, 600, out errMess);
            if (errMess != null) {

                return false;
            }

            DataTable tResult = ds.Tables[0];

            sp_name = "check_csa_individuazione_ep";
            if (usa_partizioni) sp_name = "check_csa_individuazione_partition_ep";

            ds = Conn.CallSP(sp_name,
                new object[] {rowCsa["idcsa_import"], esercizio}, 600, out errMess);
            if (errMess != null) {
                return false;
            }

            tResult = ds.Tables[0];
            if (tResult.Rows.Count != 0) {
                if (tResult.Select(QHC.CmpEq("blockingerror", "S")).Length > 0)
                    return false;

            }

            esitoVerificaCsa = true;
            return true;
        }


        private bool calcolaRighe(DataRow importCsa) {
            int countRiep = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("csa_importriep",
                QHS.CmpEq("idcsa_import", importCsa["idcsa_import"]),
                "count(*)"));
            if (countRiep > 0) return true;
            int countVer = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("csa_importver",
                QHS.CmpEq("idcsa_import", importCsa["idcsa_import"]),
                "count(*)"));
            if (countVer > 0) return true;

            return false;
        }

        decimal importoScritturaInDare(decimal amount, object idacc, string epcontext) {
            decimal segnoNormale = EP.signForAccount(idacc, epcontext);
            if (segnoNormale < 0)
                return
                    amount; //l'importo sarà già di base cambiato di segno , resta il fatto che se amount<0 tutto cambia
            return -amount;
        }

        decimal importoScritturaInAvere(decimal amount, object idacc, string epcontext) {
            return -importoScritturaInDare(amount, idacc, epcontext);
        }
        //object getImpegnoBudgetConDefault(object idepexp, DataRow r) {
        //    if (idepexp != DBNull.Value) {
        //        if (CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", idepexp), "nphase")) == 2)
        //            return idepexp;
        //    }
        //    string idrelatedRef = BudgetFunction.GetIdForDocument(r);
        //    if (idrelatedRef == null) return DBNull.Value;
        //    return getIdEpExpByIdRelated(idrelatedRef,2);
        //}

        Dictionary<int, object> accMotiveSiope = new Dictionary<int, object>();
        Dictionary<string, object> accMotiveAccount = new Dictionary<string, object>();

        object getAccMotiveForAccount(object idacc) {
            if (idacc != null && idacc != DBNull.Value) {
                if (accMotiveAccount.ContainsKey(idacc.ToString())) return accMotiveAccount[idacc.ToString()];

                DataTable t = Conn.SQLRunner(
                    "select idaccmotive " +
                    " from  accmotivedetail " +
                    " where " + QHS.CmpEq("idacc", idacc), false);
                if (t.Rows.Count > 0) {
                    accMotiveAccount[idacc.ToString()] = t.Rows[0]["idaccmotive"];
                    return accMotiveAccount[idacc.ToString()];
                }
            }

            return DBNull.Value;
        }

        object getAccMotiveForSiope(object idSorSiope, object idacc) {
            if (idSorSiope == DBNull.Value || idSorSiope == null) return getAccMotiveForAccount(idacc);
            int idsor = CfgFn.GetNoNullInt32(idSorSiope);
            if (idsor == 0) return getAccMotiveForAccount(idacc);
            if (accMotiveSiope.ContainsKey(idsor)) {
                if (accMotiveSiope[idsor] != DBNull.Value) return accMotiveSiope[idsor];
                return getAccMotiveForAccount(idacc);
            }

            if (idacc != null && idacc != DBNull.Value) {
                if (accMotiveAccount.ContainsKey(idacc.ToString())) return accMotiveAccount[idacc.ToString()];
            }

            string filter = QHS.AppAnd(QHS.CmpEq("AE.idepoperation", "siopestipendi"),
                QHS.CmpEq("AD.ayear", esercizio),
                QHS.CmpEq("A1.idsor", idsor));
            DataTable t = Conn.SQLRunner(
                "select AD.idaccmotive " +
                " from accmotivesorting A1 " +
                " join accmotiveepoperation AE on AE.idaccmotive = A1.idaccmotive " +
                " join accmotivedetail AD on AD.idaccmotive = A1.idaccmotive " +
                " where " + filter, false);
            if (t.Rows.Count > 0) {
                accMotiveSiope[idsor] = t.Rows[0]["idaccmotive"];
                return accMotiveSiope[idsor];
            }

            filter = QHS.AppAnd(QHS.CmpEq("AD.ayear", esercizio),
                QHS.CmpEq("A1.idsor", idsor));
            t = Conn.SQLRunner(
                "select AD.idaccmotive " +
                " from accmotivesorting A1 " +
                " join accmotivedetail AD on AD.idaccmotive = A1.idaccmotive " +
                " where " + filter, false);
            if (t.Rows.Count > 0) {
                accMotiveSiope[idsor] = t.Rows[0]["idaccmotive"];
                return accMotiveSiope[idsor];
            }

            object res = getAccMotiveForAccount(idacc);
            if (res != DBNull.Value) return res;

            accMotiveSiope[idsor] = DBNull.Value;
            return accMotiveSiope[idsor];
        }

        bool vecchiaGestione(object idcsa_import) {
            if (Conn.count("csa_importriep_partition", q.eq("idcsa_import", idcsa_import)) > 0) return false;
            if (Conn.count("csa_importver_partition", q.eq("idcsa_import", idcsa_import)) > 0) return false;
            return true;
        }

        private bool generaScrittureImportazioneCsa(DataRow curr, BudgetFunction bf) {
            if (!calcolaRighe(curr)) {
                return false;
            }
 

            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            object idsiopeincomeCsa = _rConfig["idsiopeincome_csa"]; //ricavo lordi


            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object idcsa_import = curr["idcsa_import"];
            bool vecchiaGest = vecchiaGestione(idcsa_import);
            bool nuovaGestione = !vecchiaGest;
            object doc = "Import. CSA. " +
                         curr["yimport"].ToString().Substring(2, 2) + "/" +
                         curr["nimport"].ToString().PadLeft(6, '0');

            DataRow mainEntry = EP.SetEntry(curr["description"], curr["adate"], doc, curr["adate"],
                EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(mainEntry);

            // Fase del pagamento prestazione (LORDI POSITIVI)   autokind 21 o 30
            // Scritture per righe a importo positivo
            // 1)lordo: 		costo   A 	debito vs percipiente
            // scansione della tabella csa_importriep

            #region LORDI POSITIVI

            string filter;


            //FASE Ia) , FASE Ic)  FASE Ie)
            string sqlCmd;
            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importriep.idcsa_import", curr["idcsa_import"]),
                    QHS.IsNotNull("idacc"));
                sqlCmd = " SELECT 'LORDI POSITIVI' as tiposcrittura, " +
                         " csa_importriep.idcsa_import," +
                         " csa_importriep.capitolocsa, " +
                         " csa_importriep.ruolocsa, " +
                         " csa_importriep.matricola, " +
                         " csa_importriep.idriep, " +
                         " idepexp, " +
                         " E.idexp, idsor_siope, " +
                         " isnull(csa_importriep_expense.amount,csa_importriep.importo) as importo, " +
                         " idacc,  " +
                         " COALESCE(EY.idupb,EY1.idupb,csa_importriep.idupb) as idupb,  " +
                         " csa_importriep.idcsa_contract,  " +
                         " csa_importriep.idcsa_contractkind, " +
                         " csa_importriep_expense.ndetail" +
                         " FROM csa_importriep " +
                         " LEFT OUTER JOIN expense E  ON csa_importriep.idexp = E.idexp " +
                         " LEFT OUTER JOIN expenseyear EY " +
                         "       ON EY.idexp = csa_importriep.idexp " +
                         "       AND EY.ayear = csa_importriep.ayear" +
                         " LEFT OUTER JOIN csa_importriep_expense " +
                         "       ON csa_importriep.idcsa_import=csa_importriep_expense.idcsa_import " +
                         "       AND csa_importriep.idriep=csa_importriep_expense.idriep " +
                         "       AND csa_importriep.idexp is null " +
                         " LEFT OUTER JOIN expense E1    ON csa_importriep_expense.idexp = E1.idexp " +
                         " LEFT OUTER JOIN expenseyear EY1 " +
                         "       ON EY1.idexp = E1.idexp " +
                         "       AND EY1.ayear = csa_importriep.ayear" +
                         " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("importo", 0));
            }
            else {
                filter = QHS.CmpEq("csa_importriep.idcsa_import", curr["idcsa_import"]);
                //QHS.AppAnd(QHS.CmpEq("csa_importriep.idcsa_import", curr["idcsa_import"]),QHS.IsNotNull("csa_importriep_partition.idacc"));
                sqlCmd = " SELECT 'LORDI POSITIVI' as tiposcrittura, " +
                         " csa_importriep_partition.idcsa_import,csa_importriep.capitolocsa, csa_importriep.ruolocsa, csa_importriep.matricola, " +
                         " csa_importriep.idriep, " +
                         " csa_importriep_partition.ndetail, csa_importriep.idreg,registry.idaccmotivedebit, " +
                         " csa_importriep_partition.idepexp, " +
                         " csa_importriep_partition.idexp, csa_importriep.idsor_siope, " +
                         " csa_importriep_partition.amount as importo, " +
                         " csa_importriep_partition.idacc,  " +
                         " csa_importriep_partition.idupb as idupb,  " +
                         " csa_importriep.idcsa_contract,  " +
                         " csa_importriep.idcsa_contractkind " +
                         " FROM csa_importriep " +
                         " LEFT OUTER JOIN registry on registry.idreg= csa_importriep.idreg " +
                         " JOIN csa_importriep_partition " +
                         "       ON csa_importriep_partition.idcsa_import=csa_importriep.idcsa_import " +
                         "       AND csa_importriep_partition.idriep=csa_importriep.idriep " +
                         " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("csa_importriep_partition.amount", 0));
            }

            DataTable T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                object idreg = idregCsa;

                T.TableName = vecchiaGest ? "csa_importriep" : "csa_importriep_partition";

                foreach (DataRow rRiep in T.Rows) {
                    object idregToUse = idreg;
                    if (nuovaGestione && rRiep["idreg"] != DBNull.Value) {
                        idregToUse = rRiep["idreg"];
                        EP.idaccmotivedebitForIdReg[idregToUse] = rRiep["idaccmotivedebit"];
                    }

                    object idaccRegistry = EP.GetSupplierAccountForRegistry(null, idregToUse);
                    if (idaccRegistry == null || idaccRegistry.ToString() == "") {
                        ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                        return false;
                    }

                    List<InfoImpegno> impegniBudget = getAmountsForScrittureRiep(rRiep, rRiep["idupb"], nuovaGestione);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(rRiep["idacc"])) {
                            ShowMessage(
                                "Non è stato trovato un impegno di budget per la riga di riepilogo n." +
                                rRiep["idriep"],
                                "Errore");
                            return false;
                        }

                        object currUPB = vecchiaGest
                            ? getUpbForEpExp(i.parIdExp, rRiep["idupb"], bf?.D.Tables["epexpyear"])
                            : rRiep["idupb"];
                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ",
                            importoScritturaInDare(i.amount, rRiep["idacc"], "PRESTAZ"), rRiep["idacc"],
                            idregToUse, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rRiep["idsor_siope"], rRiep["idacc"]), i.parIdExp, null,
                            i.idrelated,
                            "Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " + rRiep["capitolocsa"] + "- Ruolo: " +
                            rRiep["ruolocsa"] + "- Matricola: " + rRiep["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ", i.amount, idaccRegistry,
                            idregToUse, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rRiep["idsor_siope"], rRiep["idacc"]), i.parIdExp, null,
                            i.idrelated,
                            "Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " + rRiep["capitolocsa"] + "- Ruolo: " +
                            rRiep["ruolocsa"] + "- Matricola: " + rRiep["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Riepilogo " +
                                        rRiep["idriep"] + " (lordi positivi)");
                            return false;
                        }
                    }
                }
            }

            #endregion


            // LORDI NEGATIVI   autokind 21 o 30
            // 2)lordo: credito vs percipiente A ricavo  su anagrafica "diversi"

            #region LORDI NEGATIVI

            if (vecchiaGest) {
                sqlCmd = " SELECT 'LORDI NEGATIVI' as tiposcrittura, " +
                         " idriep, capitolocsa, ruolocsa, matricola, importo, " +
                         " '0001' as idupb,  " +
                         " idcsa_contract,idepexp, idcsa_import,idriep, " +
                         //" idexp,  " +
                         " idcsa_contractkind " +
                         " FROM csa_importriep " +
                         " WHERE  " + QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                             QHS.CmpLt("importo", 0));
            }
            else {
                //  FASE Ib) FASE Id) FASE If)
                sqlCmd = " SELECT 'LORDI NEGATIVI' as tiposcrittura, " +
                         " csa_importriep.idriep, capitolocsa, ruolocsa, matricola, csa_importriep_partition.amount, csa_importriep_partition.ndetail," +
                         " csa_importriep_partition.idupb, csa_importriep.idreg, registry.idaccmotivecredit, " +
                         " csa_importriep.idcsa_contract,csa_importriep_partition.idepexp, csa_importriep_partition.idcsa_import,csa_importriep_partition.idriep, " +
                         //" idexp,  " +
                         " csa_importriep.idcsa_contractkind " +
                         " FROM csa_importriep " +
                         " JOIN csa_importriep_partition " +
                         "       ON csa_importriep_partition.idcsa_import   =  csa_importriep.idcsa_import " +
                         "       AND csa_importriep_partition.idriep        =  csa_importriep.idriep " +
                         " LEFT OUTER JOIN registry on registry.idreg= csa_importriep.idreg" +
                         " WHERE  " + QHS.AppAnd(
                             QHS.CmpEq("csa_importriep_partition.idcsa_import", curr["idcsa_import"]),
                             QHS.CmpLt("csa_importriep_partition.amount", 0));
            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importriep" : "csa_importriep_partition";
                object idaccRicavo = _rConfig["idacc_revenue_gross_csa"];
                //il conto di ricavo è preso dalla configurazione
                foreach (DataRow rRiep in T.Rows) {
                    object idreg = idregCsa;
                    if (nuovaGestione && rRiep["idreg"] != DBNull.Value) {
                        idreg = rRiep["idreg"];
                        EP.idaccmotivecreditForIdReg[idreg] = rRiep["idaccmotivecredit"];
                    }

                    object idaccRegistry = EP.GetCustomerAccountForRegistry(null, idreg);
                    if (idaccRegistry == null || idaccRegistry.ToString() == "") {
                        ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                        return false;
                    }

                    object idupb = rRiep["idupb"];
                    List<InfoImpegno> impegniBudget = getAmountsForScrittureRiepRicavo(rRiep, nuovaGestione);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRicavo)) {
                            ShowMessage(
                                "Non è stato trovato un accertamento di budget per la riga di riepilogo n." +
                                rRiep["idriep"],
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, rRiep["idupb"]);
                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ",
                            importoScritturaInAvere(i.amount, idaccRicavo, "PRESTAZ"),
                            idaccRicavo,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp, i.idrelated,
                            "Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " + rRiep["capitolocsa"] + "- Ruolo: " +
                            rRiep["ruolocsa"] + "- Matricola: " + rRiep["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ",
                            -i.amount,
                            idaccRegistry,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp, i.idrelated,
                            "Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " + rRiep["capitolocsa"] + "- Ruolo: " +
                            rRiep["ruolocsa"] + "- Matricola: " + rRiep["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Riepilogo " +
                                        rRiep["idriep"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                                        rRiep["matricola"] + " (lordi negativi)");
                            return false;
                        }
                    }
                }
            }

            #endregion


            // Invece in fase di LORDI, per i soli CONTRIBUTI con importo POSITIVO:  autokind 20 o 31
            // una scrittura costo a debito ove:
            // COSTO = idacc_cost
            // DEBITO = ISNULL(_debit , _expense ) (ossia se c'è quello "conto" erario è preso quello, altrimenti quello "verso" erario)

            #region CONTRIBUTI POSITIVI


            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver.idcsa_import", curr["idcsa_import"]),
                    QHS.IsNotNull("idacc_cost"), QHS.NullOrEq("flagclawback", "N"),
                    QHS.DoPar(QHS.AppOr(QHS.IsNotNull("idacc_debit"), QHS.IsNotNull("idacc_expense"))),
                    QHS.CmpGt("importo", 0));
                sqlCmd = " SELECT 'CONTRIBUTI POSITIVI' as tiposcrittura, " +
                         " csa_importver.idcsa_import, capitolocsa, ruolocsa, matricola, " +
                         " csa_importver.idcsa_contract, " +
                         " csa_importver.idcsa_contracttax, " +
                         " isnull(csa_importver_expense.amount,csa_importver.importo) as importo, " +
                         " csa_importver.idver, " +
                         " idepexp, " +
                         " idreg_agency, " +
                         " vocecsa, " +
                         " idacc_cost,  " +
                         " idacc_debit, " +
                         " idacc_expense," +
                         " COALESCE(EY1.idupb,EY.idupb,csa_importver.idupb) as idupb,  " +
                         " idsor_siope_cost," +
                         " csa_importver_expense.ndetail " +
                         " FROM csa_importver " +
                         " LEFT OUTER JOIN expense E        ON csa_importver.idexp_cost = E.idexp " +
                         " LEFT OUTER JOIN expenseyear EY   ON EY.idexp = csa_importver.idexp_cost " +
                         "                                       AND EY.ayear = " + QHS.quote(esercizio) +
                         " LEFT OUTER JOIN csa_importver_expense " +
                         "          ON csa_importver.idcsa_import=csa_importver_expense.idcsa_import " +
                         "          and csa_importver.idver = csa_importver_expense.idver " +
                         "         AND csa_importver.idexp_cost is null " +
                         " LEFT OUTER JOIN expense E1       ON csa_importver_expense.idexp = E1.idexp " +
                         " LEFT OUTER JOIN expenseyear EY1  ON EY1.idexp = E1.idexp " +
                         " AND EY1.ayear = " + QHS.quote(esercizio) +
                         " WHERE  " + filter;
                //" GROUP BY vocecsa, idreg_agency, idacc_cost, idacc_debit,idacc_expense, idupb";

            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver.idcsa_import", curr["idcsa_import"]),
                    QHS.IsNotNull("csa_importver_partition.idacc"), QHS.NullOrEq("flagclawback", "N"),
                    QHS.CmpGt("csa_importver_partition.amount", 0));

                sqlCmd = " SELECT 'CONTRIBUTI POSITIVI' as tiposcrittura, " +
                         " csa_importver.idcsa_import, capitolocsa, ruolocsa, matricola, " +
                         " csa_importver.idcsa_contract, " +
                         " csa_importver.idcsa_contracttax, " +
                         " csa_importver_partition.amount as importo, " +
                         " csa_importver.idver, " +
                         " csa_importver_partition.idepexp, " +
                         " idreg_agency, " +
                         " vocecsa, " +
                         " csa_importver_partition.idacc ,  " +
                         " idacc_debit, " +
                         " idacc_expense," +
                         " csa_importver_partition.idupb,  " +
                         " csa_importver.idsor_siope_cost," +
                         " csa_importver_partition.ndetail " +
                         " FROM csa_importver " +
                         " JOIN csa_importver_partition " +
                         "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                         "       AND csa_importver_partition.idver         =  csa_importver.idver " +
                         " WHERE  " + filter;

            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                foreach (DataRow rVer in T.Rows) {
                    object idaccCost = nuovaGestione ? rVer["idacc"] : rVer["idacc_cost"];
                    //object idaccDebit = nuovaGestione? DBNull.Value: rVer["idacc_debit"];
                    //object idaccExpense =  nuovaGestione? DBNull.Value:rVer["idacc_expense"];
                    object idaccDebit = rVer["idacc_debit"];
                    object idaccExpense = rVer["idacc_expense"];
                    object idreg = rVer["idreg_agency"];
                    object idregAgency = rVer["idreg_agency"]; //ANAGRAFICA ENTE CSA                      
                    object idaccCredit =
                        EP.GetCustomerAccountForRegistry(null, idregAuto); //credito vs percipiente            

                    string idrelatedMain = BudgetFunction.GetIdForDocument(rVer);

                    // LIQUIDAZIONE DIRETTA SENZA TRANSITO DA PARTITA DI GIRO
                    object idacc = idaccExpense; //debito verso erario


                    T.TableName = nuovaGestione ? "csa_importver_partition" : "csa_importver";
                    List<InfoImpegno> impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], nuovaGestione);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di versamento n. {rVer["idver"]} per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], bf?.D.Tables["epexpyear"]);
                        if (vecchiaGest && idaccDebit != DBNull.Value) {
                            // LIQUIDAZIONE CON TRANSITO DA PARTITA DI GIRO
                            idreg = idregAuto;
                            idacc = idaccDebit; // debito conto erario
                        }

                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ",
                            importoScritturaInDare(i.amount, idaccCost, "PRESTAZ"), idaccCost,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost), i.parIdExp, null,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] +
                            "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        // il credito di solito va in AVERE in questi casi (PRESTAZ)
                        // essendo l'importo POSITIVO qui andrà in AVERE
                        //  COSTO        A        DEBITO VS ERARIO
                        EP.EffettuaScritturaImpegnoBudget("PRESTAZ", i.amount, idacc, /*manca causale*/
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            //null, null, i.parIdExp, null, i.idrelated,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost), i.parIdExp, null,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] +
                            "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + " (contributi positivi) ");
                            return false;
                        }


                        //TODO: aggiungere altre scritture ove ci sia una configurazione di partite di giro (task 10726)
                        if (vecchiaGest && idaccDebit != DBNull.Value) {
                            string idepcontext = "PRESTAZ";
                            // credito vs percipiente A DEBITO vs/conto erario, ma cambio il segno del primo dettaglio
                            // il credito di solito va in AVERE in questi casi, cosi come il debito
                            // essendo l'importo positivo vogliamo che il credito vada in DARE e quindi lo cambiamo di segno
                            EP.EffettuaScritturaIdRelated(idepcontext, -i.amount, idaccCredit, idregAuto, currUPB,
                                null, null,
                                idrelatedMain,
                                "Reversale su p.di giro su riga versamento " + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);
                            EP.EffettuaScritturaIdRelated(idepcontext, i.amount, idaccExpense, idregAgency, currUPB,
                                null, null,
                                idrelatedMain,
                                "Reversale su p.di giro su riga versamento " + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);
                        }

                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + " (reversali su p. di giro) ");
                            return false;
                        }

                    }

                }
            }


            #endregion


            // RITENUTE POSITIVE
            // credito vs percipiente       A debito vs erario  ("ente csa")      (diversi     A idacc_agency_debit  )

            #region RITENUTE POSITIVE

            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]), QHS.NullOrEq("flagclawback", "N"));
                sqlCmd =
                    " SELECT 'RITENUTE POSITIVE' as tiposcrittura, " +
                    " idver, importo,  capitolocsa, ruolocsa, matricola, idreg_agency,  vocecsa, idacc_expense, " +
                    " '0001' as idupb " +
                    " FROM csa_importver " +
                    " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("importo", 0),
                        QHS.IsNull("idfin_cost"),
                        QHS.IsNull("idexp_cost"),
                        " NOT EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                        "AND CI.idver=csa_importver.idver)",
                        QHS.IsNotNull("idfin_income"));
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver.idcsa_import", curr["idcsa_import"]),
                    QHS.NullOrEq("flagclawback", "N"));
                sqlCmd =
                    " SELECT 'RITENUTE POSITIVE' as tiposcrittura, " +
                    " csa_importver.idcsa_import,csa_importver_partition.idver, csa_importver_partition.amount as importo,  capitolocsa, ruolocsa, matricola, " +
                    " idreg_agency,  vocecsa, idacc_expense,csa_importver_partition.ndetail, " +
                    " '0001' as idupb,csa_importver.idreg, registry.idaccmotivecredit " +
                    " FROM csa_importver " +
                    " LEFT OUTER JOIN registry on registry.idreg= csa_importver.idreg " +
                    " JOIN csa_importver_partition " +
                    "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                    "       AND csa_importver_partition.idver        =  csa_importver.idver " +
                    " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("csa_importver.importo", 0),
                        //QHS.IsNull("idfin_cost"),
                        QHS.IsNull("csa_importver_partition.idacc"),
                        QHS.IsNotNull("idfin_income"));
            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importver" : "csa_importver_partition";

                foreach (DataRow rVer in T.Rows) {
                    object idregAgency = rVer["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                    object idreg = idregCsa;
                    if (nuovaGestione && rVer["idreg"] != DBNull.Value) {
                        idreg = rVer["idreg"];
                        EP.idaccmotivecreditForIdReg[idreg] = rVer["idaccmotivecredit"];
                    }

                    object idaccCredit = EP.GetCustomerAccountForRegistry(null, idreg); //credito vs percipiente

                    object idaccExpense = rVer["idacc_expense"];
                    object idacc = idaccExpense; //debito verso erario                    
                    object idupb = rVer["idupb"];
                    decimal importo = CfgFn.GetNoNullDecimal(rVer["importo"]); //l'importo è positivo
                    string idepcontext = "PRESTAZ";
                    string idrelated =
                        vecchiaGest ? null : BudgetFunction.GetIdForDocument(rVer); //+ "§" + rVer["ndetail"];
                    // credito vs percipiente A DEBITO vs/conto erario, ma cambio il segno del primo dettaglio
                    // il credito di solito va in AVERE in questi casi, cosi come il debito
                    // essendo l'importo positivo vogliamo che il credito vada in DARE e quindi lo cambiamo di segno

                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccCredit, idreg, idupb, null, null,
                        idrelated,
                        "Ritenuta positiva su riga versamento " + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idacc, idregAgency, idupb, null, null,
                        idrelated,
                        "Ritenuta positiva su riga versamento " + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                    //else {
                    //    object idaccPayment = _rConfig["idacc_bankpaydoc"];
                    //    //  doc.pagamento  A   debito vs erario (ente csa)  (ente csa)
                    //    // essendo l'importo positivo vogliamo che doc.pagamento vada in AVERE e lo cambiamo di segno
                    //    EP.EffettuaScritturaIdRelated(idepcontext, importo, idacc, idregAgency, idupb, null,null, null,
                    //        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                    //    EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccPayment, idregAgency, idupb, null, null, null,
                    //        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                    //}

                    if (EP.saldo != 0) {
                        ShowMessage("Si è verificata una squadratura sulla riga di Versamento " + rVer["idver"] +
                                    " (ritenute positive)");
                        return false;
                    }
                }
            }

            #endregion


            // RITENUTE NEGATIVE
            // credito vs erario ("ente csa") A debito vs percipiente ("diversi")  (idacc_agency_credit  A   diversi)

            #region RITENUTE NEGATIVE

            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]), QHS.NullOrEq("flagclawback", "N"),
                    QHS.IsNotNull("idacc_agency_credit"));
                sqlCmd =
                    " SELECT 'RITENUTE NEGATIVE' as tiposcrittura, " +
                    " idver,importo, capitolocsa, ruolocsa, matricola, idreg_agency,  vocecsa,  idacc_agency_credit, " +
                    " '0001' as idupb " +
                    " FROM csa_importver " +
                    " WHERE  " + QHS.AppAnd(filter, QHS.CmpLt("importo", 0),
                        QHS.IsNull("idfin_cost"),
                        QHS.IsNull("idexp_cost"),
                        " NOT EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                        " AND CI.idver=csa_importver.idver)",
                        QHS.IsNotNull("idfin_income"));
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver_partition.idcsa_import", curr["idcsa_import"]),
                    QHS.NullOrEq("flagclawback", "N"),
                    QHS.IsNotNull("idacc_agency_credit"));
                sqlCmd =
                    " SELECT 'RITENUTE NEGATIVE' as tiposcrittura, " +
                    " csa_importver.idcsa_import,csa_importver_partition.idver,csa_importver_partition.amount as importo, capitolocsa, ruolocsa, matricola, idreg_agency,  vocecsa,  idacc_agency_credit, " +
                    " '0001' as idupb ,csa_importver_partition.ndetail, csa_importver.idreg,registry.idaccmotivedebit " +
                    " FROM csa_importver " +
                    " LEFT OUTER JOIN registry on registry.idreg= csa_importver.idreg " +
                    " JOIN csa_importver_partition " +
                    "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                    "       AND csa_importver_partition.idver        =  csa_importver.idver " +
                    " WHERE  " + QHS.AppAnd(filter, QHS.CmpLt("csa_importver_partition.amount", 0),
                        QHS.IsNull("csa_importver_partition.idacc"),
                        QHS.IsNotNull("idfin_income"));

            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importver" : "csa_importver_partition";


                foreach (DataRow r in T.Rows) {
                    object idregAgency = r["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                    string idrelated = vecchiaGest ? null : BudgetFunction.GetIdForDocument(r);

                    object idreg = idregCsa;
                    if (nuovaGestione && r["idreg"] != DBNull.Value) {
                        idreg = r["idreg"];
                        EP.idaccmotivedebitForIdReg[idreg] = r["idaccmotivedebit"];
                    }

                    object idaccDebit = EP.GetSupplierAccountForRegistry(null, idreg);
                    object idaccCredit = r["idacc_agency_credit"];
                    if (idaccCredit == DBNull.Value) {
                        ShowMessage(
                            "E' necessario configurare il conto 'Credito verso Ente per contributi e ritenute negativi'" +
                            " per la voceCSA " + r["vocecsa"]);
                        return false;
                    }

                    object idupb = r["idupb"];
                    decimal importo = CfgFn.GetNoNullDecimal(r["importo"]);
                    string idepcontext = "PRESTAZ";
                    // credito A DEBITO, ma cambio il segno del secondo dettaglio, 
                    // credito vs erario A DEBITO vs percipiente
                    // il credito di solito va in AVERE in questi casi, cosi come il debito
                    // essendo l'importo NEGATIVO qui andranno tutti e due in DARE
                    // poiché vogliamo il debito in AVERE, lo cambiamo di segno

                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccCredit, idregAgency, idupb, null, null,
                        idrelated,
                        "Ritenuta negativa su riga versamento " + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccDebit, idreg, idupb, null, null,
                        idrelated,
                        "Ritenuta negativa su riga versamento " + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    if (EP.saldo != 0) {
                        ShowMessage("Si è verificata una squadratura sulla riga di Versamento " + r["idver"] +
                                    " (ritenute negative)");
                        return false;
                    }
                }
            }

            #endregion


            //Contributi negativi 
            //credito vs erario A  RICAVO 

            #region   Contributi negativi

            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    QHS.IsNotNull("idacc_agency_credit"),
                    QHS.IsNotNull("idacc_revenue"),
                    QHS.NullOrEq("flagclawback", "N"),
                    QHS.DoPar(QHS.AppOr(QHS.IsNotNull("idfin_cost"), QHS.IsNotNull("idexp_cost"),
                        " EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                        " AND CI.idver=csa_importver.idver)"

                    )),
                    QHS.CmpLt("importo", 0));

                sqlCmd = " SELECT 'CONTRIBUTI NEGATIVI' as tiposcrittura, " +
                         " idver, importo,idcsa_import,idver, " +
                         " idreg_agency, " +
                         " vocecsa,capitolocsa, ruolocsa, matricola, " +
                         " idsor_siope_income, " +
                         " idacc_agency_credit, " +
                         " idacc_revenue, " +
                         " '0001' as idupb " +
                         " FROM csa_importver " +
                         " WHERE  " + filter;
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver.idcsa_import", curr["idcsa_import"]),
                    QHS.IsNotNull("csa_importver_partition.idacc"), QHS.NullOrEq("flagclawback", "N"),
                    QHS.CmpLt("csa_importver_partition.amount", 0));

                sqlCmd = " SELECT 'CONTRIBUTI NEGATIVI' as tiposcrittura, " +
                         " csa_importver.idcsa_import, capitolocsa, ruolocsa, matricola, " +
                         " csa_importver.idcsa_contract, csa_importver.idsor_siope_income, " +
                         " csa_importver.idcsa_contracttax, " +
                         " csa_importver_partition.amount as importo, " +
                         " csa_importver.idver, csa_importver.idacc_revenue, " +
                         " csa_importver_partition.idepexp, " +
                         " csa_importver.idacc_agency_credit, " +
                         " idreg_agency, " +
                         " vocecsa, " +
                         " csa_importver_partition.idacc ,  " +
                         " idacc_debit, " +
                         " idacc_expense," +
                         " csa_importver_partition.idupb,  " +
                         " csa_importver.idsor_siope_cost," +
                         " csa_importver_partition.ndetail " +
                         " FROM csa_importver " +
                         " JOIN csa_importver_partition " +
                         "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                         "       AND csa_importver_partition.idver         =  csa_importver.idver " +
                         " WHERE  " + filter;

            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importver" : "csa_importver_partition";
                foreach (DataRow rVer in T.Rows) {
                    object idreg = rVer["idreg_agency"]; //ANAGRAFICA ENTE     
                    object idaccCredit = rVer["idacc_agency_credit"];
                    if (idaccCredit == DBNull.Value) {
                        ShowMessage(
                            "E' necessario configurare il conto 'Credito verso Ente per contributi e ritenute negativi'" +
                            " per la voceCSA " + rVer["vocecsa"]);
                        return false;
                    }

                    object idaccRevenue = rVer["idacc_revenue"];
                    object idupb = rVer["idupb"];

                    string idepcontext_ricavo = "FATVEN";

                    List<InfoImpegno> accertamentiBudget = getAmountsForScrittureVerRicavo(rVer);
                    foreach (InfoImpegno i in accertamentiBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRevenue)) {
                            ShowMessage(
                                "Non è stato trovato un accertamento di budget per la riga di versamento n." +
                                rVer["idver"],
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, rVer["idupb"]);
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            importoScritturaInAvere(i.amount, idaccRevenue, idepcontext_ricavo), idaccRevenue,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] +
                            "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        // il credito di solito va in DARE in questi casi (FATVEN)
                        // essendo l'importo NEGATIVO qui andrà in AVERE
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccCredit,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo; " + rVer["capitolocsa"] +
                            "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                        rVer["matricola"] + " (contributi negativi) ");
                            return false;
                        }

                    }

                }
            }


            #endregion


            //RECUPERI POSITIVI
            //credito vs percipiente A  RICAVO 

            #region RECUPERI POSITIVI

            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    //QHS.IsNotNull("idacc_revenue"),
                    QHS.CmpEq("flagclawback", "S"),
                    QHS.CmpGt("importo", 0));
                sqlCmd = " SELECT 'RECUPERI POSITIVI' as tiposcrittura, " +
                         " importo,idcsa_import,idver, " +
                         " vocecsa,capitolocsa, ruolocsa, matricola, " +
                         " idreg_agency, " +
                         " idacc_revenue, " +
                         " idupb, " +
                         " idsor_siope_income," +
                         " null as idreg " +
                         " FROM csa_importver " +
                         " WHERE  " + filter;
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver_partition.idcsa_import", curr["idcsa_import"]),
                    //QHS.IsNotNull("idacc_revenue"),
                    QHS.CmpEq("flagclawback", "S"),
                    QHS.CmpGt("csa_importver_partition.amount", 0));
                sqlCmd = " SELECT 'RECUPERI POSITIVI' as tiposcrittura, " +
                         " csa_importver_partition.amount,csa_importver_partition.idcsa_import,csa_importver_partition.idver, " +
                         " vocecsa,capitolocsa, ruolocsa, matricola, " +
                         " idreg_agency,csa_importver_partition.ndetail, " +
                         " idacc_revenue, " +
                         " csa_importver_partition.idupb, csa_importver.idreg,registry.idaccmotivecredit, " +
                         " idsor_siope_income" +
                         " FROM csa_importver " +
                         " LEFT OUTER JOIN registry on registry.idreg= csa_importver.idreg " +
                         " JOIN csa_importver_partition " +
                         "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                         "       AND csa_importver_partition.idver        =  csa_importver.idver " +
                         " WHERE  " + filter;

            }

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importver" : "csa_importver_partition";


                foreach (DataRow r in T.Rows) {
                    object idregAgency = r["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                    object idreg = idregCsa;
                    if (nuovaGestione && r["idreg"] != DBNull.Value) {
                        idreg = r["idreg"];
                        EP.idaccmotivecreditForIdReg[idreg] = r["idaccmotivecredit"];
                    }

                    var idaccCredit = EP.GetCustomerAccountForRegistry(null, idreg);
                    var idaccRevenue = r["idacc_revenue"];
                    if (idaccRevenue == DBNull.Value) {
                        ShowMessage("E' necessario configurare il conto di ricavo per contr. negativi e recuperi" +
                                    " per la voceCSA " + r["vocecsa"]);
                        return false;
                    }

                    var idupb = r["idupb"];
                    var idepcontext_ricavo = "FATVEN";
                    //ShowMessage(T.TableName);
                    List<InfoImpegno> accertamentiBudget = getAmountsForScrittureVerRicavo(r);
                    foreach (InfoImpegno i in accertamentiBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRevenue)) {
                            ShowMessage(
                                "Non è stato trovato un accertamento di budget per la riga di versamento n." +
                                r["idver"], "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, r["idupb"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            importoScritturaInAvere(i.amount, idaccRevenue, idepcontext_ricavo), idaccRevenue,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(r["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);

                        // il credito di solito va in DARE in questi casi (FATVEN)
                        // essendo l'importo POSITIVO qui andrà in DARE
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccCredit,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(r["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    }


                    if (EP.saldo != 0) {
                        ShowMessage("Si è verificata una squadratura sulla riga di Versamento " + r["idver"] +
                                    " (recuperi positivi) ");
                        return false;
                    }

                }
            }

            #endregion

            //Versamento recuperi
            //COSTO   A  debito vs percipiente

            #region RECUPERI NEGATIVI

            if (vecchiaGest) {
                filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    //QHS.IsNotNull("idacc_cost"),
                    QHS.CmpEq("flagclawback", "S"),
                    QHS.CmpLt("importo", 0));
                sqlCmd = " SELECT  'RECUPERI NEGATIVI' as tiposcrittura, * " +
                         " FROM csa_importver " +
                         " WHERE  " + filter;
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("csa_importver_partition.idcsa_import", curr["idcsa_import"]),
                    //QHS.IsNotNull("csa_importver_partition.idacc"),
                    QHS.CmpEq("flagclawback", "S"),
                    QHS.CmpLt("csa_importver_partition.amount", 0));

                sqlCmd = " SELECT 'RECUPERI NEGATIVI' as tiposcrittura,  csa_importver_partition.*," +
                         " csa_importver.vocecsa,csa_importver.capitolocsa, csa_importver.ruolocsa, csa_importver.matricola,csa_importver.idreg, " +
                         " csa_importver.idsor_siope_cost,registry.idaccmotivecredit " +
                         " FROM csa_importver " +
                         " LEFT OUTER JOIN registry on registry.idreg= csa_importver.idreg " +
                         " JOIN csa_importver_partition " +
                         "       ON csa_importver_partition.idcsa_import   =  csa_importver.idcsa_import " +
                         "       AND csa_importver_partition.idver        =  csa_importver.idver " +
                         " WHERE  " + filter;

            }

            T = Conn.SQLRunner(sqlCmd);

            if (T != null) {
                T.TableName = vecchiaGest ? "csa_importver" : "csa_importver_partition";


                foreach (DataRow rVer in T.Rows) {
                    object idreg = idregCsa;
                    if (nuovaGestione && rVer["idreg"] != DBNull.Value) {
                        idreg = rVer["idreg"];
                        EP.idaccmotivecreditForIdReg[idreg] = rVer["idaccmotivecredit"];
                    }

                    var idaccDebit = EP.GetSupplierAccountForRegistry(null, idreg);
                    object idaccCost = vecchiaGest ? rVer["idacc_cost"] : rVer["idacc"];
                    if (idaccCost == DBNull.Value) {
                        ShowMessage("E' necessario configurare il conto di costo per recuperi negativi" +
                                    " per la voceCSA " + rVer["vocecsa"]);
                        return false;
                    }

                    var idupb = rVer["idupb"];
                    var idepcontext_costo = "FATACQ";


                    List<InfoImpegno> impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], nuovaGestione);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di versamento n. {rVer["idver"]} per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], bf?.D.Tables["epexpyear"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_costo,
                            importoScritturaInDare(i.amount, idaccCost, "PRESTAZ"), idaccCost,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null,
                            getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost), i.parIdExp, null, i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        // il debito di solito va in DARE in questi casi (FATACQ)
                        // essendo l'importo NEGATIVO qui andrà in AVERE

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_costo, i.amount, idaccDebit, /*manca causale*/
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost), i.parIdExp, null,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                        rVer["matricola"] + " (recuperi negativi) ");
                            return false;
                        }

                    }

                }
            }

            #endregion

            EP.RemoveEmptyDetails();

            return true;
        }

        private bool generaScritturePagamentoVerPartition(EP_functions EP, object idexp, object idregMovSpesa, object idaccPayment,
            bool Annullo) {
            string idrelatedTransitorio = "expense§" + idexp.ToString();
            if (idaccPayment == DBNull.Value) {
                return false;
            }
            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            decimal sign = Annullo ? -1 : 1;

            //VERSAMENTO RITENUTE POSITIVE E CONTRIBUTI POSITIVI, RECUPERI NEGATIVI
            var t = Conn.SQLRunner("select CP.*,CE.amount as quota,CE.movkind " +
                                   " from csa_importver_partitionview CP " +
                                   " join csa_importver_partition_expense CE " +
                                   " on CE.idcsa_import=CP.idcsa_import " +
                                   "   and CE.idver=CP.idver " +
                                   "   and CE.ndetail=CP.ndetail " +
                                   " WHERE " +
                                   QHS.CmpEq("CE.idexp", idexp), true);
            if (t == null) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", idexp), "nmov"));
                ShowMessage($"Ripartizione unica del versamento non trovata per il pagamento n. {nPag} ");
                return false;
            }

            t.TableName = "csa_importver_partition";
            if (t.Rows.Count == 0) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", idexp), "nmov"));
                ShowMessage($"Ripartizione unica del versamento non trovata per il pagamento n. {nPag} ");
                return false;
            }

            foreach (DataRow rVer in t.Rows) {
                object idaccCost = lookup(rVer["idacc_cost"]);
                object idregAgency = rVer["idreg_agency"];
                //object idregPercipiente = rVer["idreg"];
                //if (idregPercipiente == DBNull.Value) idregPercipiente = idregCsa; //diversi
                object idaccExpense = lookup(rVer["idacc_expense"]); //debito vs erario
                object idaccDebitPercipiente = EP.GetSupplierAccountForRegistry(null, idregMovSpesa);
 

                object doc = "Import. CSA. " +
                            rVer["yimport"].ToString().Substring(2, 2) + "/" +
                            rVer["nimport"].ToString().PadLeft(6, '0') +
                            "Versamento, riga " +
                            rVer["idver"] + "/" + rVer["ndetail"];


                decimal quota = CfgFn.GetNoNullDecimal(rVer["quota"]);
                decimal originalAmount = CfgFn.GetNoNullDecimal(rVer["amount"]);


                string idrelatedMain = BudgetFunction.GetIdForDocument(rVer);
                object idepexp = getIdEpExpByIdRelated(idrelatedMain, 2);

                //contributi positivi   debito vs Erario     A    doc.pagamento 
                if (rVer["flagclawback"].ToString().ToUpper() != "S" && idaccCost != DBNull.Value &&
                    originalAmount > 0) {
                    List<InfoImpegno>
                        impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], true); //idrelated di rVer
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di Versamento (Contributi positivi) per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], null);

                        EP.EffettuaScritturaImpegnoBudget("PAGAM", i.amount * sign, idaccExpense, /*manca causale*/
                            idregAgency, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], rVer["idacc_cost"]), i.parIdExp, null,
                            i.idrelated,
                            "Contributi positivi, Versamento, riga " + rVer["idver"] + "- Capitolo: " +
                            rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        EP.EffettuaScritturaIdRelated("PAGAM", i.amount * sign, idaccPayment, /*manca causale*/
                            idregAgency, currUPB, null,
                            getAccMotiveForSiope(rVer["idsor_siope_cost"], rVer["idacc_cost"]),
                            idrelatedTransitorio,
                            "Contributi positivi, Versamento, riga " + rVer["idver"] + "- Capitolo: " +
                            rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        if (EP.saldo != 0) {
                            ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (contributi positivi) per \"{doc}\"");
                            return false;
                        }
                    }

                    continue;
                }


                //VERSAMENTO ritenute  positive    (all'erario)
                //  debito vs Erario     A    doc.pagamento 
                if (rVer["flagclawback"].ToString().ToUpper() != "S" && idaccCost == DBNull.Value &&
                    originalAmount > 0) {
                    List<InfoImpegno> impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], true);

                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di Versamento (ritenute positive) per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], null);
                        if (currUPB == DBNull.Value) currUPB = "0001";

                        //   debito vs erario (ente csa)  A doc.pagamento      (ente csa)
                        // essendo l'importo positivo vogliamo che doc.pagamento vada in AVERE e lo cambiamo di segno
                        EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccExpense, idregAgency, currUPB, null,
                            null,
                            i.idrelated, //14908 Stiamo stabilendo di chiudere qui questo conto, e aprirlo in fase di elenco trasm. incasso
                            $"Ritenuta positiva su riga versamento n.{rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                        EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccPayment, idregAgency, currUPB, null,
                            null, idrelatedTransitorio,
                            $"Ritenuta positiva su riga versamento n.{rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");



                        if (EP.saldo != 0) {
                            ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (ritenute positive) per \"{doc}\"");
                            return false;
                        }
                    }

                    continue;
                }

                //PAGAMENTO   ritenute  negative    (al percipiente)
                //  debito vs percipiente     A    doc.pagamento 
                if (rVer["flagclawback"].ToString().ToUpper() != "S" && idaccCost == DBNull.Value &&
                    originalAmount < 0) {
                    //questa roba non è un costo quindi va su partite di giro quindi gira su upb "ATENEO"
                    List<InfoImpegno> impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], true);

                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di versamento (ritenute  negative) per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], null);
                        if (currUPB == DBNull.Value) currUPB = "0001";

                        //   debito vs percipiente (idreg)  A doc.pagamento      (idreg)
                        // essendo l'importo positivo vogliamo che doc.pagamento vada in AVERE e lo cambiamo di segno
                        EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccDebitPercipiente,
                            idregMovSpesa, // era idregPercipiente,
                            currUPB, null, null, i.idrelated, //
                            $"Ritenuta negativa su riga versamento n.{rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                        EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccPayment,
                            idregMovSpesa /* era  rVer["idreg_agency"] */, currUPB, null, null, idrelatedTransitorio,
                            $"Ritenuta negativa su riga versamento n.{rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                        if (EP.saldo != 0) {
                            ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (ritenute  negative) per {doc}");
                            return false;
                        }
                    }

                    continue;
                }

                /* PAGAMENTO RECUPERI NEGATIVI */
                // doc.pagamento  (idregPercipiente)        A    debito vs percipiente (idregPercipiente)
                // NO: deve essere invertito (task 14832)
                if (rVer["flagclawback"].ToString().ToUpper() == "S" && originalAmount < 0) {
                    object idaccCreditPercipiente = EP.GetCustomerAccountForRegistry(null, idregMovSpesa);
                    object currUPB = rVer["idupb"];
                    EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccDebitPercipiente, idregMovSpesa,
                        currUPB, null, null, idrelatedMain,
                        $"Recupero negativo su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                    EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccPayment, idregMovSpesa, currUPB, null,
                        null, idrelatedTransitorio,
                        $"Recupero negativo su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                    if (EP.saldo != 0) {
                        ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (recuperi negativi) per {doc}");
                        return false;
                    }

                    continue;
                }

                ShowMessage(
                    $"Ripartizione non trovata sulla riga di versamento (pagamento versamenti) per \"{doc}\"");
                return false;
            }

            return true;
        }


        Dictionary<string, object> lookupConti = new Dictionary<string, object>();

        object lookup(object contoAnnoGenerico) {
            if (contoAnnoGenerico == DBNull.Value || contoAnnoGenerico == null) return DBNull.Value;
            string conto = contoAnnoGenerico.ToString();
            if (lookupConti.ContainsKey(conto)) return lookupConti[conto];
            if (conto.Substring(0, 2) == (esercizio % 100).ToString().PadLeft(2, '0')) return conto;
            object nuovoConto = Conn.readValue("accountlookup", q.eq("oldidacc", contoAnnoGenerico), "newidacc");
            if (nuovoConto != null) lookupConti[conto] = nuovoConto;
            return lookup(nuovoConto);
        }

        //INCASSI VERSAMENTI 
        private bool generaScrittureIncassoVerPartition(EP_functions EP, object idinc, object idregIncasso, object idaccProceeds,
            bool Annullo) {
            string idrelatedTransitorio = "income§" + idinc.ToString();
      
            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            decimal sign = Annullo ? -1 : 1;
            object idaccRicavo = _rConfig["idacc_revenue_gross_csa"];
            object idsiopeincomeCsa = _rConfig["idsiopeincome_csa"]; //ricavo lordi


            //VERSAMENTO RITENUTE NEGATIVE E CONTRIBUTI NEGATIVI, INCASSO RITENUTE POSITIVE, RECUPERI POSITIVI
            var t = Conn.SQLRunner("select CP.*, CE.amount as quota, CE.movkind " +
                                   " from csa_importver_partitionview CP " +
                                   " join csa_importver_partition_income CE " +
                                   " on CE.idcsa_import=CP.idcsa_import " +
                                   "   and CE.idver=CP.idver " +
                                   "   and CE.ndetail=CP.ndetail " +
                                   " WHERE " +
                                   QHS.CmpEq("CE.idinc", idinc), true);
            if (t == null) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("income", QHS.CmpEq("idinc", idinc), "nmov"));
                ShowMessage($"Ripartizione unica del versamento non trovata per l'incasso n. {nPag} ");
                return false;
            }

            if (t.Rows.Count == 0) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("income", QHS.CmpEq("idinc", idinc), "nmov"));
                ShowMessage($"Ripartizione unica del versamento non trovata per l'incasso n. {nPag} ");
                return false;
            }

            t.TableName = "csa_importver_partition";
            foreach (DataRow rVer in t.Rows) {
                object idaccCost = lookup(rVer["idacc_cost"]);
                object idregAgency = rVer["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                                                           //object idregPercipiente = rVer["idreg"];
          

                object doc = "Import. CSA. " +
                              rVer["yimport"].ToString().Substring(2, 2) + "/" +
                              rVer["nimport"].ToString().PadLeft(6, '0') +
                              "Versamento, riga " +
                              rVer["idver"] + "/" + rVer["ndetail"];

                decimal quota = CfgFn.GetNoNullDecimal(rVer["quota"]);
                decimal amount = CfgFn.GetNoNullDecimal(rVer["amount"]);
                string idrelatedMain = BudgetFunction.GetIdForDocument(rVer);

                object idupb = rVer["idupb"]; //dovrebbe essere "0001"  //non c'è in; 
                if (idupb == DBNull.Value) idupb = "0001";
                object idaccCreditCsa = lookup(rVer["idacc_agency_credit"]);

                //INCASSO RITENUTE POSITIVE       
                if (rVer["flagclawback"].ToString().ToUpper() != "S" && idaccCost == DBNull.Value && amount > 0) {
                    object idaccCreditPercipiente = EP.GetCustomerAccountForRegistry(null, idregIncasso);
                    // DOC. INCASSO          A  credito vs percipiente 
                    EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccProceeds, idregIncasso, idupb, null,
                        null, idrelatedTransitorio,
                        $"Ritenuta positiva su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                    EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccCreditPercipiente, idregIncasso,
                        idupb, null, null, idrelatedMain,
                        $"Ritenuta positiva su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");
                    if (EP.saldo != 0) {
                        ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (ritenute positive) per \"{doc}\"");
                        return false;
                    }

                    continue;
                }

                /* INCASSO CONTRIBUTI NEGATIVI e RITENUTE NEGATIVE   (DA ERARIO)                */
                // doc.incasso  (ente CSA)        A    credito vs erario ("ente csa")
                if (rVer["flagclawback"].ToString().ToUpper() != "S" && amount < 0) {
                    if (idaccCreditCsa == DBNull.Value) {
                        ShowMessage(
                            $"E\' necessario configurare il conto \'Credito verso Ente per contributi e ritenute negativi\' per la voceCSA {rVer["vocecsa"]}");
                        return false;
                    }

                    object idepacc = DBNull.Value;
                    object idrelated = null;
                    //if (idaccCost != DBNull.Value) {
                    idrelated = BudgetFunction.GetIdForDocument(rVer);
                    idepacc = getIdEpAccByIdRelated(idrelated.ToString(), 2);
                    //}

                    string oggetto = idaccCost == DBNull.Value ? "Ritenuta negativa" : "Contributo negativo";
                    EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccProceeds, idregAgency, idupb, null, null,
                        idrelatedTransitorio,
                        $"{oggetto} su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                    //EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccCreditCsa, idregAgency, idupb, null, null,
                    //    null,
                    //    $"{oggetto} su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                    EP.EffettuaScritturaImpegnoBudget("INCAS", quota * sign, idaccCreditCsa, idregAgency, idupb,
                        DBNull.Value, DBNull.Value,
                        null, null, null, idepacc, idrelated,
                        $"{oggetto} su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");


                    if (EP.saldo != 0) {
                        ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (ritenute e contributi negativi) per \"{doc}\"");
                        return false;
                    }

                    continue;
                }

                /* INCASSO RECUPERI POSITIVI */
                // doc.incasso  (idregPercipiente)        A    credito vs percipiente (idregPercipiente)
                if (rVer["flagclawback"].ToString().ToUpper() == "S" && amount > 0) {

                    object idrelated = BudgetFunction.GetIdForDocument(rVer);
                    object idepacc = getIdEpAccByIdRelated(idrelated.ToString(), 2);

                    object idaccCreditPercipiente = EP.GetCustomerAccountForRegistry(null, idregIncasso);

                    EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccProceeds, idregIncasso, idupb, null,
                        null, idrelatedTransitorio,
                        $"Recupero positivo su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                    //EP.EffettuaScritturaIdRelated("INCAS", quota * sign, idaccCreditPercipiente, idregIncasso,
                    //    idupb, null, null, null,
                    //    $"Recupero positivo su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                    EP.EffettuaScritturaImpegnoBudget("INCAS", quota * sign, idaccCreditPercipiente, idregIncasso,
                        idupb, DBNull.Value, DBNull.Value,
                        null, null, null, idepacc, idrelated,
                        $"Recupero positivo su riga versamento {rVer["idver"]}- Capitolo: {rVer["capitolocsa"]}- Ruolo: {rVer["ruolocsa"]}- Matricola: {rVer["matricola"]}");

                    if (EP.saldo != 0) {
                        ShowMessage($"Si è verificata una squadratura sulla riga di Versamento (recuperi positivi) per \"{doc}\"");
                        return false;
                    }

                    continue;
                }

                ShowMessage(
                    $"Ripartizione non trovata sulla riga di versamento \"{doc}\" (incasso versamenti)");
                return false;
            }

 
            return true;
        }

        //pagamento riepiloghi positivi
        private bool generaScritturePagamentoRiepPartition(EP_functions EP, object idexp, object idregSpesa, object idaccPayment,
            bool Annullo) {
            string idrelatedTransitorio = "expense§" + idexp.ToString();
            if (idaccPayment == DBNull.Value) {
                return false;
            }
            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            decimal sign = Annullo ? -1 : 1;

            //Riepiloghi positivi
            var t = Conn.SQLRunner("select CP.*,CE.amount as quota,CE.movkind,R.idsor_siope  " +
                                   " from csa_importriep_partitionview CP " +
                                   " join csa_importriep_partition_expense CE " +
                                   " on CE.idcsa_import=CP.idcsa_import " +
                                   "   and CE.idriep=CP.idriep " +
                                   "   and CE.ndetail=CP.ndetail " +
                                   " join csa_importriep R " +
                                   " on R.idcsa_import=CP.idcsa_import " +
                                   "   and R.idriep=CP.idriep " +
                                   " WHERE " +
                                   QHS.CmpEq("CE.idexp", idexp), true);
            if (t == null) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", idexp), "nmov"));
                ShowMessage($"Ripartizione unica (riepiloghi positivi) non trovata per il pagamento n. {nPag} ");
                return false;
            }

            t.TableName = "csa_importriep_partition";

            if (t.Rows.Count == 0) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("expense", QHS.CmpEq("idexp", idexp), "nmov"));
                ShowMessage($"Ripartizione unica (riepiloghi positivi) non trovata per il pagamento n. {nPag} ");
                return false;
            }

            foreach (DataRow curr in t.Rows) {
                object idregToUse = idregCsa;
                if (curr["idreg"] != DBNull.Value) idregToUse = curr["idreg"];
                idregToUse = idregSpesa;

                object idaccRegistry = EP.GetSupplierAccountForRegistry(null, idregToUse);

                object doc = "Import. CSA. " +
                             curr["yimport"].ToString().Substring(2, 2) + "/" +
                             curr["nimport"].ToString().PadLeft(6, '0') +
                             "Riepilogo " +
                             curr["idriep"] + "/" + curr["ndetail"];
                decimal quota = CfgFn.GetNoNullDecimal(curr["quota"]);
                decimal originalAmount = CfgFn.GetNoNullDecimal(curr["amount"]);

                string idrelatedMain = BudgetFunction.GetIdForDocument(curr);
                object idepexp = getIdEpExpByIdRelated(idrelatedMain, 2);
                //RIEPILOGHI POSITIVI
                if (curr["idacc"] != DBNull.Value && originalAmount > 0) {
                    EP.EffettuaScritturaImpegnoBudget("PAGAM", quota * sign, idaccRegistry,
                        idregToUse, curr["idupb"], DBNull.Value, DBNull.Value,
                        null, getAccMotiveForSiope(curr["idsor_siope"], curr["idacc"]), idepexp, null, idrelatedMain,
                        "Riepilogo, riga " + curr["idriep"] +
                        "- Capitolo: " + curr["capitolocsa"] + "- Ruolo: " + curr["ruolocsa"] + "- Matricola: " +
                        curr["matricola"]);

                    EP.EffettuaScritturaIdRelated("PAGAM", quota * sign, idaccPayment,
                        idregCsa, curr["idupb"], null,
                        getAccMotiveForSiope(curr["idsor_siope"], curr["idacc"]),
                        idrelatedTransitorio,
                        "Riepiloghi positivi, Riepilogo, riga " + curr["idriep"] +
                        "- Capitolo: " + curr["capitolocsa"] + "- Ruolo: " + curr["ruolocsa"] + "- Matricola: " +
                        curr["matricola"]);

                    if (EP.saldo != 0) {
                        ShowMessage($"Si è verificata una squadratura sulla riga di Riepilogo positivo (Pagamento riepiloghi) per \"{doc}\"");
                        return false;
                    }

                    continue;
                }

                ShowMessage(
                    $"Ripartizione non trovata sulla riga di Riepilogo positivo (Pagamento riepiloghi) per \"{doc}\"");
                return false;
            }

            return true;
        }

        //incasso riepiloghi negativi
        private bool generaScrittureIncassoRiepPartition(EP_functions EP, object idinc, object idregIncasso,object idaccProceeds,
            bool Annullo) {
            string idrelatedTransitorio = "income§" + idinc.ToString();
            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            object idaccRicavo = _rConfig["idacc_revenue_gross_csa"];
            object idsiopeincomeCsa = _rConfig["idsiopeincome_csa"]; //ricavo lordi
            decimal sign = Annullo ? -1 : 1;

            //RIEPILOGHI NEGATIVI
            var t = Conn.SQLRunner("select CP.*,CE.amount as quota,CE.movkind,R.idsor_siope  " +
                                   " from csa_importriep_partitionview CP " +
                                   " join csa_importriep_partition_income CE " +
                                   " on CE.idcsa_import=CP.idcsa_import " +
                                   "   and CE.idriep=CP.idriep " +
                                   "   and CE.ndetail=CP.ndetail " +
                                   " join csa_importriep R " +
                                   " on R.idcsa_import=CP.idcsa_import " +
                                   "   and R.idriep=CP.idriep " +
                                   " WHERE " +
                                   QHS.CmpEq("CE.idinc", idinc), true);
            if (t == null) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("income", QHS.CmpEq("idinc", idinc), "nmov"));
                ShowMessage($"Ripartizione unica del riepilogo negativo non trovata per l'incasso n. {nPag} ");
                return false;
            }

            t.TableName = "csa_importriep_partition";

            if (t.Rows.Count == 0) {
                int nPag = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("income", QHS.CmpEq("idinc", idinc), "nmov"));
                ShowMessage($"Ripartizione unica del riepilogo negativo non trovata per l'incasso n. {nPag} ");
                return false;
            }

            foreach (DataRow curr in t.Rows) {
                object idregToUse = idregCsa;
                decimal originalAmount = CfgFn.GetNoNullDecimal(curr["amount"]);

                if (curr["idreg"] != DBNull.Value) idregToUse = curr["idreg"];
                idregToUse = idregIncasso;

                object idaccRegistry = EP.GetCustomerAccountForRegistry(null, idregToUse);

                object doc = "Import. CSA. " +
                             curr["yimport"].ToString().Substring(2, 2) + "/" +
                             curr["nimport"].ToString().PadLeft(6, '0') +
                             "Riepilogo " +
                             curr["idriep"] + "/" + curr["ndetail"];
                decimal quota = CfgFn.GetNoNullDecimal(curr["quota"]);

                string idrelatedMain = BudgetFunction.GetIdForDocument(curr);

                //LORDI NEGATIVI
                if (originalAmount < 0) {
                    List<InfoImpegno> impegniBudget = getAmountsForScrittureRiepRicavo(curr, true);
                    var idupb = curr["idupb"];
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRicavo)) {
                            ShowMessage(
                                $"Non è stato trovato un accertamento di budget per la riga di riepilogo negativo \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, idupb);
                        EP.EffettuaScritturaImpegnoBudget("PAGAM",
                            -i.amount * sign, idaccProceeds,
                            idregToUse, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
                            idrelatedTransitorio, //i.idrelated,
                            "Lordi negativi, Riepilogo, riga " + curr["idriep"] + "- Capitolo: " +
                            curr["capitolocsa"] + "- Ruolo: " + curr["ruolocsa"] + "- Matricola: " +
                            curr["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget("PAGAM",
                            -i.amount * sign, idaccRegistry,
                            idregToUse, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
                            i.idrelated,
                            "Lordi negativi, Riepilogo, riga " + curr["idriep"] + "- Capitolo: " +
                            curr["capitolocsa"] + "- Ruolo: " + curr["ruolocsa"] + "- Matricola: " +
                            curr["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage($"Si è verificata una squadratura sulla riga di Riepilogo negativo (lordi negativi) \"{doc}\"");
                            return false;
                        }
                    }

                    continue;
                }

                ShowMessage($"Ripartizione non trovata sulla riga di Riepilogo negativo (Incasso riepiloghi) per \"{doc}\"");
                return false;

            }

            return true;
        }



        private bool generaScrittureDebitoAContiBancaCsa(DataRow curr, BudgetFunction bf) {
            // Effettua scritture del Tipo Debito a CONTO PRESENTAZIONE DOCUMENTI IN BANCA
            //bool vecchiaGest = vecchiaGestione(curr["idcsa_import"]);
            //bool nuovaGestione = !vecchiaGest;
            object idaccPayment = _rConfig["idacc_bankpaydoc"];
            object idaccProceeds = _rConfig["idacc_bankprodoc"];
            object idsiopeincomeCsa = _rConfig["idsiopeincome_csa"]; //ricavo lordi
            if (!usaContiPresentazioneDocumenti) return false;

            if (!calcolaRighe(curr)) {
                return false;
            }

            object idregCsa = _rConfig["idreg_csa"];
            object idregAuto = _rConfig["idregauto"];
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            object doc = "CSA Chiusura C.ti Debito " +
                         curr["yimport"].ToString().Substring(2, 2) + "/" +
                         curr["nimport"].ToString().PadLeft(6, '0');

            DataRow mainEntry = EP.SetEntry(curr["description"], curr["adate"], doc, curr["adate"],
                EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(mainEntry);


            // Fase del pagamento prestazione (LORDI)
            // Scritture per righe a importo positivo
            // lordo :  costo                   A   debito vs percipiente
            // ORA:     Debito vs percipiente   A 	Conto presentazione Doc. in Banca
            // scansione della tabella csa_importriep

            var filter = QHS.AppAnd(QHS.CmpEq("csa_importriep.idcsa_import", curr["idcsa_import"]),
                QHS.IsNotNull("idacc"));

            string sqlCmd = " SELECT " +
                            " csa_importriep.idcsa_import," +
                            " capitolocsa, ruolocsa, matricola, " +
                            " csa_importriep.idriep, " +
                            " idepexp, " +
                            " E.idexp, idsor_siope, " +
                            " isnull(csa_importriep_expense.amount,csa_importriep.importo) as importo, " +
                            " idacc,  " +
                            " COALESCE(EY1.idupb,EY.idupb,csa_importriep.idupb) as idupb,  " +
                            " csa_importriep.idcsa_contract,  " +
                            " csa_importriep.idcsa_contractkind, " +
                            " csa_importriep_expense.ndetail" +
                            " FROM csa_importriep " +
                            " LEFT OUTER JOIN expense E  ON csa_importriep.idexp = E.idexp " +
                            " LEFT OUTER JOIN expenseyear EY  ON EY.idexp = csa_importriep.idexp " +
                            "       AND EY.ayear = csa_importriep.ayear" +
                            " LEFT OUTER JOIN csa_importriep_expense " +
                            "       ON csa_importriep.idcsa_import=csa_importriep_expense.idcsa_import " +
                            "       AND csa_importriep.idriep=csa_importriep_expense.idriep " +
                            "       AND csa_importriep.idexp IS NULL " +
                            " LEFT OUTER JOIN expense E1    ON csa_importriep_expense.idexp = E1.idexp " +
                            " LEFT OUTER JOIN expenseyear EY1 " +
                            "       ON EY1.idexp = E1.idexp " +
                            "       AND EY1.ayear = csa_importriep.ayear" +
                            " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("importo", 0));

            DataTable T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                var idreg = idregCsa;
                var idaccRegistry = EP.GetSupplierAccountForRegistry(null, idreg);
                if (idaccRegistry == null || idaccRegistry.ToString() == "") {
                    ShowMessage("Non è stato configurato il conto di debito opportuno");
                    return false;
                }

                T.TableName = "csa_importriep";

                foreach (DataRow rRiep in T.Rows) {
                    var impegniBudget = getAmountsForScrittureRiep(rRiep, rRiep["idupb"], false);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(rRiep["idacc"])) {
                            ShowMessage(
                                "Non è stato trovato un impegno di budget per la riga di riepilogo n." +
                                rRiep["idriep"], "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rRiep["idupb"], bf?.D.Tables["epexpyear"]);
                        EP.EffettuaScritturaImpegnoBudget("PAGAM", i.amount, idaccRegistry,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rRiep["idsor_siope"], rRiep["idacc"]), i.parIdExp, null,
                            i.idrelated,
                            "Lordi positivi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
                            rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                            rRiep["matricola"]);

                        EP.EffettuaScritturaIdRelated("PAGAM", i.amount, idaccPayment,
                            idregCsa, currUPB, null,
                            getAccMotiveForSiope(rRiep["idsor_siope"], rRiep["idacc"]),
                            null,
                            "Lordi positivi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
                            rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                            rRiep["matricola"]);
                    }
                }
            }

            if (true) {
                // LORDI NEGATIVI
                // 2)lordo: credito vs percipiente A ricavo  su anagrafica "diversi"
                // ORA:
                //  conto incassi       A           credito
                sqlCmd = " SELECT " +
                         " idriep, capitolocsa, ruolocsa, matricola, importo, " +
                         " '0001' as idupb,  " +
                         " idcsa_contract,idepexp, idcsa_import,idriep, " +
                         //" idexp,  " +
                         " idcsa_contractkind " +
                         " FROM csa_importriep " +
                         " WHERE  " + QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                             QHS.CmpLt("importo", 0));

                T = Conn.SQLRunner(sqlCmd);
                if (T != null) {
                    T.TableName = "csa_importriep";
                    object idaccRicavo = _rConfig["idacc_revenue_gross_csa"];
                    object idreg = idregCsa;
                    object idaccRegistry = EP.GetCustomerAccountForRegistry(null, idreg);
                    if (idaccRegistry == null || idaccRegistry.ToString() == "") {
                        ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
                        return false;
                    }

                    foreach (DataRow rRiep in T.Rows) {
                        List<InfoImpegno> impegniBudget = getAmountsForScrittureRiepRicavo(rRiep, false);
                        var idupb = rRiep["idupb"];
                        foreach (InfoImpegno i in impegniBudget) {
                            if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                                EP.isRicavo(idaccRicavo)) {
                                ShowMessage(
                                    "Non è stato trovato un accertamento di budget per la riga di riepilogo n." +
                                    rRiep["idriep"],
                                    "Errore");
                                return false;
                            }

                            object currUPB = getUpbForEpAcc(i.parIdExp, idupb);
                            EP.EffettuaScritturaImpegnoBudget("PAGAM",
                                -i.amount, idaccProceeds,
                                idreg, currUPB, DBNull.Value, DBNull.Value,
                                null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
                                i.idrelated,
                                "Lordi negativi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
                                rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                                rRiep["matricola"]);

                            EP.EffettuaScritturaImpegnoBudget("PAGAM",
                                -i.amount, idaccRegistry,
                                idreg, currUPB, DBNull.Value, DBNull.Value,
                                null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
                                i.idrelated,
                                "Lordi negativi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
                                rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                                rRiep["matricola"]);
                            if (EP.saldo != 0) {
                                ShowMessage("Si è verificata una squadratura sulla riga di Riepilogo " +
                                            rRiep["idriep"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
                                            rRiep["matricola"] + " (lordi negativi)");
                                return false;
                            }
                        }

                    }
                }
            }
            //if (nuovaGestione) {
            //    // LORDI NEGATIVI
            //    // 2)lordo: credito vs percipiente A ricavo  su anagrafica "diversi"
            //    // ORA:
            //    //  conto incassi       A           credito
            //    sqlCmd = " SELECT " +
            //             " idriep, capitolocsa, ruolocsa, matricola, importo, " +
            //             " '0001' as idupb,  " +
            //             " idcsa_contract,idepexp, idcsa_import,idriep, " +
            //             //" idexp,  " +
            //             " idcsa_contractkind " +
            //             " FROM csa_importriep " +
            //             " WHERE  " + QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
            //                 QHS.CmpLt("importo", 0));

            //    T = Conn.SQLRunner(sqlCmd);
            //    if (T != null) {
            //        T.TableName = "csa_importriep";
            //        object idaccRicavo = _rConfig["idacc_revenue_gross_csa"];
            //        object idreg = idregCsa;
            //        object idaccRegistry = EP.GetCustomerAccountForRegistry(null, idreg);
            //        if (idaccRegistry == null || idaccRegistry.ToString() == "") {
            //            ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
            //            return false;
            //        }

            //        foreach (DataRow rRiep in T.Rows) {
            //            List<InfoImpegno> impegniBudget = getAmountsForScrittureRiepRicavo(rRiep, nuovaGestione);
            //            var idupb = rRiep["idupb"];
            //            foreach (InfoImpegno i in impegniBudget) {
            //                if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
            //                    EP.isRicavo(idaccRicavo)) {
            //                    ShowMessage(
            //                        "Non è stato trovato un accertamento di budget per la riga di riepilogo n." +
            //                        rRiep["idriep"],
            //                        "Errore");
            //                    return false;
            //                }

            //                object currUPB = getUpbForEpAcc(i.parIdExp, idupb);
            //                EP.EffettuaScritturaImpegnoBudget("PAGAM",
            //                    -i.amount, idaccProceeds,
            //                    idreg, currUPB, DBNull.Value, DBNull.Value,
            //                    null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
            //                    i.idrelated,
            //                    "Lordi negativi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
            //                    rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
            //                    rRiep["matricola"]);

            //                EP.EffettuaScritturaImpegnoBudget("PAGAM",
            //                    -i.amount, idaccRegistry,
            //                    idreg, currUPB, DBNull.Value, DBNull.Value,
            //                    null, getAccMotiveForSiope(idsiopeincomeCsa, idaccRicavo), null, i.parIdExp,
            //                    i.idrelated,
            //                    "Lordi negativi, Riepilogo, riga " + rRiep["idriep"] + "- Capitolo: " +
            //                    rRiep["capitolocsa"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
            //                    rRiep["matricola"]);
            //                if (EP.saldo != 0) {
            //                    ShowMessage("Si è verificata una squadratura sulla riga di Riepilogo " +
            //                                    rRiep["idriep"] + "- Ruolo: " + rRiep["ruolocsa"] + "- Matricola: " +
            //                                    rRiep["matricola"] + " (lordi negativi)");
            //                    return false;
            //                }
            //            }

            //        }
            //    }
            //}

            // Invece in fase di LORDI, per i soli CONTRIBUTI con importo POSITIVO:
            // DEBITO = ISNULL(_debit , _expense ) (ossia se c'è quello "conto" erario è preso quello, altrimenti quello "verso" erario)
            filter = QHS.AppAnd(QHS.CmpEq("csa_importver.idcsa_import", curr["idcsa_import"]),
                QHS.IsNotNull("idacc_cost"), QHS.NullOrEq("flagclawback", "N"),
                QHS.DoPar(QHS.AppOr(QHS.IsNotNull("idacc_debit"), QHS.IsNotNull("idacc_expense"))),
                QHS.CmpGt("importo", 0));

            sqlCmd = " SELECT " +
                     " csa_importver.idcsa_import," +
                     " capitolocsa, ruolocsa, matricola," +
                     " csa_importver.idcsa_contract, " +
                     " csa_importver.idcsa_contracttax, " +
                     " isnull(csa_importver_expense.amount,csa_importver.importo) as importo, " +
                     " csa_importver.idver, " +
                     " idepexp, " +
                     " idreg_agency, " +
                     " vocecsa, " +
                     " idacc_cost,  " +
                     " idacc_debit, " +
                     " idacc_expense," +
                     " COALESCE(EY1.idupb,EY.idupb,csa_importver.idupb) as idupb,  " +
                     " idsor_siope_cost, " +
                     " csa_importver_expense.ndetail " +
                     " FROM csa_importver " +
                     " LEFT OUTER JOIN expense E        ON csa_importver.idexp_cost = E.idexp " +
                     " LEFT OUTER JOIN expenseyear EY   ON EY.idexp = csa_importver.idexp_cost " +
                     "                                       AND EY.ayear = csa_importver.ayear " +
                     " LEFT OUTER JOIN csa_importver_expense " +
                     "          ON csa_importver.idcsa_import=csa_importver_expense.idcsa_import " +
                     "         and csa_importver.idver = csa_importver_expense.idver " +
                     "         AND csa_importver.idexp_cost is null " +
                     " LEFT OUTER JOIN expense E1       ON csa_importver_expense.idexp = E1.idexp " +
                     " LEFT OUTER JOIN expenseyear EY1  ON EY1.idexp = E1.idexp " +
                     " AND EY1.ayear = csa_importver.ayear" +
                     " WHERE  " + filter;


            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = "csa_importver";
                foreach (DataRow rVer in T.Rows) {

                    var idaccDebit = rVer["idacc_debit"];
                    var idaccExpense = rVer["idacc_expense"];
                    // LIQUIDAZIONE DIRETTA SENZA TRANSITO DA PARTITA DI GIRO
                    var idacc = idaccExpense; //debito verso erario
                    var idreg = rVer["idreg_agency"];
                    object idaccCredit = EP.GetCustomerAccountForRegistry(null, idregAuto); //credito vs percipiente

                    var impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], false);
                    foreach (var i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(rVer["idacc_cost"])) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di versamento n. {rVer["idver"]} per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        if (idaccDebit != DBNull.Value) {
                            // LIQUIDAZIONE CON TRANSITO DA PARTITA DI GIRO
                            idreg = idregAuto;
                            idacc = idaccDebit; // debito conto erario
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], bf?.D.Tables["epexpyear"]);

                        EP.EffettuaScritturaImpegnoBudget("PAGAM", i.amount, idacc, /*manca causale*/
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], rVer["idacc_cost"]), i.parIdExp, null,
                            i.idrelated,
                            "Contributi positivi, Versamento, riga " + rVer["idver"] + "- Capitolo: " +
                            rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        EP.EffettuaScritturaIdRelated("PAGAM", i.amount, idaccPayment, /*manca causale*/
                            rVer["idreg_agency"], currUPB, null,
                            getAccMotiveForSiope(rVer["idsor_siope_cost"], rVer["idacc_cost"]),
                            null,
                            "Contributi positivi, Versamento, riga " + rVer["idver"] + "- Capitolo: " +
                            rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);


                        if (idaccDebit != DBNull.Value) {
                            string idepcontext = "PAGAM";
                            // credito vs percipiente A DEBITO vs/conto erario, ma cambio il segno del primo dettaglio
                            // il credito di solito va in AVERE in questi casi, cosi come il debito
                            // essendo l'importo positivo vogliamo che il credito vada in DARE e quindi lo cambiamo di segno
                            EP.EffettuaScritturaIdRelated(idepcontext, -i.amount, idaccProceeds, idreg, currUPB, null,
                                null, null,
                                "Reversale su p.di giro su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);

                            EP.EffettuaScritturaIdRelated(idepcontext, -i.amount, idaccCredit, idreg, currUPB, null,
                                null,
                                null,
                                "Reversale su p.di giro su riga versamento " + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);



                            EP.EffettuaScritturaIdRelated(idepcontext, i.amount, idaccPayment, idreg, currUPB, null,
                                null, null,
                                "Reversale su p.di giro su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);

                            EP.EffettuaScritturaIdRelated(idepcontext, i.amount, idaccExpense, rVer["idreg_agency"],
                                currUPB, null, null,
                                null,
                                "Reversale su p.di giro su riga versamento " + rVer["idver"] + "- Capitolo: " +
                                rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                rVer["matricola"]);

                        }

                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + " (reversali su p. di giro) ");
                            return false;
                        }
                    }
                }
            }

            // RITENUTE POSITIVE
            // fase lordi:
            // credito vs percipiente       A debito vs erario  ("ente csa")      (diversi     A idacc_agency_debit  )
            // ORA:
            // doc. incasso (percipiente)   A credito vs percipiente (percipiente)
            // debito vs erario (ente csa)  A  doc.pagamento (ente csa)
            filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]), QHS.NullOrEq("flagclawback", "N"));
            sqlCmd = " SELECT idver,importo, capitolocsa, ruolocsa, matricola, idreg_agency,  vocecsa,idacc_expense, " +
                     " '0001' as idupb " +
                     " FROM csa_importver " +
                     " WHERE  " + QHS.AppAnd(filter, QHS.CmpGt("importo", 0),
                         QHS.IsNull("idfin_cost"),
                         QHS.IsNull("idexp_cost"),
                         " NOT EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                         "AND CI.idver=csa_importver.idver)",
                         QHS.IsNotNull("idfin_income"));

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = "csa_importver";
                object idreg = idregCsa; //ANAGRAFICA DIVERSI     
                object idaccCredit = EP.GetCustomerAccountForRegistry(null, idreg); //credito vs percipiente


                foreach (DataRow rVer in T.Rows) {
                    object idregAgency = rVer["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                    object idaccExpense = rVer["idacc_expense"];
                    object idacc = idaccExpense; //debito verso erario                    

                    object idupb = rVer["idupb"];
                    decimal importo = CfgFn.GetNoNullDecimal(rVer["importo"]); //l'importo è positivo
                    string idepcontext = "PAGAM";
                    // il credito di solito va in DARE in questi casi (PAGAM, INCAS), cosi come il debito                    

                    // doc. incasso (percipiente)   A   credito vs percipiente (percipiente)
                    // essendo l'importo positivo vogliamo che il credito vada in AVERE e quindi lo cambiamo di segno
                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccProceeds, idreg, idupb, null, null, null,
                        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccCredit, idreg, idupb, null, null, null,
                        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                    // debito vs erario (ente csa)  A  doc.pagamento (ente csa)
                    // essendo l'importo positivo vogliamo che doc.pagamento vada in AVERE e lo cambiamo di segno
                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idacc, idregAgency, idupb, null, null, null,
                        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccPayment, idregAgency, idupb, null, null,
                        null,
                        "Ritenuta positiva su riga versamento n." + rVer["idver"] + "- Capitolo: " +
                        rVer["capitolocsa"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);


                    if (EP.saldo != 0) {
                        ShowMessage("Si è verificata una squadratura sulla riga di Versamento " + rVer["idver"] +
                                    "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"] +
                                    " (ritenute negative)");
                        return false;
                    }
                }
            }


            // RITENUTE NEGATIVE
            // IN FASE STIPENDI:
            // credito vs erario ("ente csa") A debito vs percipiente ("diversi")  (idacc_agency_credit  A   diversi)
            // ORA:
            // doc.incasso  (ente CSA)        A    credito vs erario ("ente csa")   >> questa non la sta facendo più
            // debito vs percipiente ("diversi")  A doc.pagamento ("diversi")
            filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                QHS.NullOrEq("flagclawback", "N"),
                QHS.IsNotNull("idacc_agency_credit"));
            sqlCmd = " SELECT " +
                     " idver,importo,capitolocsa, ruolocsa, matricola," +
                     " idreg_agency, " +
                     " vocecsa, " +
                     " idacc_agency_credit, " +
                     " '0001' as idupb " +
                     " FROM csa_importver " +
                     " WHERE  " + QHS.AppAnd(filter, QHS.CmpLt("importo", 0),
                         QHS.IsNull("idfin_cost"),
                         QHS.IsNull("idexp_cost"),
                         " NOT EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                         "AND CI.idver=csa_importver.idver)",
                         QHS.IsNotNull("idfin_income"));

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = "csa_importver";
                object idreg = idregCsa; //ANAGRAFICA DIVERSI     
                object idaccDebit = EP.GetSupplierAccountForRegistry(null, idreg);

                foreach (DataRow r in T.Rows) {
                    object idregAgency = r["idreg_agency"]; //ANAGRAFICA ENTE CSA  

                    object idaccCredit = r["idacc_agency_credit"];
                    if (idaccCredit == DBNull.Value) {
                        ShowMessage(
                            "E' necessario configurare il conto 'Credito verso Ente per contributi e ritenute negativi'" +
                            " per la voceCSA " + r["vocecsa"]);
                        return false;
                    }

                    object idupb = r["idupb"];
                    decimal importo = CfgFn.GetNoNullDecimal(r["importo"]);
                    string idepcontext = "PAGAM";
                    //EP.EffettuaScrittura(idepcontext, -importo, idaccDebit, idreg, idupb, null);
                    //EP.EffettuaScrittura("PAGAM", -importo, idaccPayment, idreg, idupb, null);
                    //Il credito vs erario si chiuderà con i movimenti di tipo versamento in fase di elenco trasmissione

                    //// INCASSO A CREDITO "ente csa" 
                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccCredit, idregAgency, idupb, null, null,
                        null,
                        "Ritenuta negativa su riga versamento n." + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccProceeds, idregAgency, idupb, null, null,
                        null,
                        "Ritenuta negativa su riga versamento n." + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    //// DEBITO A PAGAMENTO  "diversi
                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccDebit, idreg, idupb, null, null, null,
                        "Ritenuta negativa su riga versamento n." + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccPayment, idreg, idupb, null, null, null,
                        "Ritenuta negativa su riga versamento n." + r["idver"] + "- Capitolo: " + r["capitolocsa"] +
                        "- Ruolo: " + r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                }
            }



            //Contributi negativi 
            //credito vs erario A  RICAVO 
            filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                QHS.IsNotNull("idacc_agency_credit"),
                QHS.IsNotNull("idacc_revenue"),
                QHS.NullOrEq("flagclawback", "N"),
                QHS.DoPar(QHS.AppOr(QHS.IsNotNull("idfin_cost"), QHS.IsNotNull("idexp_cost"),
                    " EXISTS(select * from csa_importver_expense CI where CI.idcsa_import=csa_importver.idcsa_import " +
                    "AND CI.idver=csa_importver.idver)")),
                QHS.CmpLt("importo", 0));

            sqlCmd = " SELECT " +
                     " idver, importo,idcsa_import,idver, " +
                     " idreg_agency, " +
                     " vocecsa,capitolocsa, ruolocsa, matricola," +
                     " idsor_siope_income, " +
                     " idacc_agency_credit, " +
                     " idacc_revenue, " +
                     " '0001' as idupb " +
                     " FROM csa_importver " +
                     " WHERE  " + filter;

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = "csa_importver";
                foreach (DataRow rVer in T.Rows) {
                    object idreg = rVer["idreg_agency"]; //ANAGRAFICA ENTE     
                    object idaccCredit = rVer["idacc_agency_credit"];
                    if (idaccCredit == DBNull.Value) {
                        ShowMessage(
                            "E' necessario configurare il conto 'Credito verso Ente per contributi e ritenute negativi'" +
                            " per la voceCSA " + rVer["vocecsa"]);
                        return false;
                    }

                    object idaccRevenue = rVer["idacc_revenue"];
                    var idupb = rVer["idupb"];
                    var importo = CfgFn.GetNoNullDecimal(rVer["importo"]);
                    var idepcontext_ricavo = "INCAS";

                    List<InfoImpegno> accertamentiBudget = getAmountsForScrittureVerRicavo(rVer);
                    foreach (InfoImpegno i in accertamentiBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRevenue)) {
                            ShowMessage(
                                "Non è stato trovato un accertamento di budget per la riga di versamento n." +
                                rVer["idver"],
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, rVer["idupb"]);
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccProceeds,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccCredit,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                        rVer["matricola"] + " (contributi negativi) ");
                            return false;
                        }

                    }

                }
            }



            //RECUPERI POSITIVI
            //credito vs percipiente A  RICAVO 
            filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                QHS.IsNotNull("idacc_revenue"),
                QHS.CmpEq("flagclawback", "S"),
                QHS.CmpGt("importo", 0));
            sqlCmd = " SELECT " +
                     " importo,idcsa_import,idver, " +
                     " vocecsa,capitolocsa, ruolocsa, matricola, " +
                     " idreg_agency, " +
                     " idacc_revenue, idacc_internalcredit," +
                     " idupb, " +
                     " idsor_siope_income" +
                     " FROM csa_importver " +
                     " WHERE  " + filter;

            T = Conn.SQLRunner(sqlCmd);
            if (T != null) {
                T.TableName = "csa_importver";
                var idreg = idregCsa; //ANAGRAFICA DIVERSI     
                var idaccCredit = EP.GetCustomerAccountForRegistry(null, idreg);
                foreach (DataRow r in T.Rows) {
                    var idaccRevenue = r["idacc_revenue"];
                    if (idaccRevenue == DBNull.Value) {
                        ShowMessage("E' necessario configurare il conto di ricavo per contr. negativi e recuperi" +
                                    " per la voceCSA " + r["vocecsa"]);
                        return false;
                    }

                    var idupb = r["idupb"];
                    var importo = CfgFn.GetNoNullDecimal(r["importo"]);
                    var idepcontext_ricavo = "INCAS";
                    List<InfoImpegno> accertamentiBudget = getAmountsForScrittureVerRicavo(r);
                    foreach (InfoImpegno i in accertamentiBudget) {
                        if (i.parIdExp == DBNull.Value && UsaAccertamentiDiBudget && esercizio > 2015 &&
                            EP.isRicavo(idaccRevenue)) {
                            ShowMessage(
                                "Non è stato trovato un accertamento di budget per la riga di versamento n." +
                                r["idver"], "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpAcc(i.parIdExp, r["idupb"]);
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccProceeds,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(r["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccCredit,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(r["idsor_siope_income"], idaccRevenue), null, i.parIdExp,
                            i.idrelated,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                    }

                    /*
                     *  Credito interno  A  Conto transiotio reversali
                        Contro transitorio madati A Credito interno

                        mentre deve movimentare l'inverso dei conti transitori

                        Credito interno  A  Contro transitorio madati
                        Conto transiotio reversali A Credito interno
                     * */
                    if (r["idacc_internalcredit"] != DBNull.Value &&
                        idaccPayment.ToString() != idaccProceeds.ToString()) {
                        //// INCASSO A CREDITO "ente csa" 
                        string idepcontext = "PAGAM";
                        object idregAgency = r["idreg_agency"]; //ANAGRAFICA ENTE CSA  
                        object creditointerno = r["idacc_internalcredit"];

                        //INCASSO  a idacc_internalcredit
                        EP.EffettuaScritturaIdRelated(idepcontext, -importo, creditointerno, idregAgency, idupb, null,
                            null, null,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                        EP.EffettuaScritturaIdRelated(idepcontext, -importo, idaccProceeds, idregAgency, idupb, null,
                            null, null,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);


                        //idacc_internalcredit a PAGAMENTO
                        EP.EffettuaScritturaIdRelated(idepcontext, importo, creditointerno, idreg, idupb, null, null,
                            null,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);
                        EP.EffettuaScritturaIdRelated(idepcontext, importo, idaccPayment, idreg, idupb, null, null,
                            null,
                            "Versamento, riga " + r["idver"] + "- Capitolo: " + r["capitolocsa"] + "- Ruolo: " +
                            r["ruolocsa"] + "- Matricola: " + r["matricola"]);

                    }


                }
            }


            //RECUPERI NEGATIVI
            //in fase lordi è  COSTO   A  debito vs percipiente
            // ORA debito vs percipiente   A    banca
            filter = QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                QHS.IsNotNull("idacc_cost"),
                QHS.CmpEq("flagclawback", "S"),
                QHS.CmpLt("importo", 0));
            sqlCmd = " SELECT * " +
                     " FROM csa_importver " +
                     " WHERE  " + filter;

            T = Conn.SQLRunner(sqlCmd);

            if (T != null) {
                T.TableName = "csa_importver";
                var idreg = idregCsa; //ANAGRAFICA DIVERSI     
                var idaccDebit = EP.GetSupplierAccountForRegistry(null, idreg);
                foreach (DataRow rVer in T.Rows) {
                    object idaccCost = rVer["idacc_cost"];
                    if (idaccCost == DBNull.Value) {
                        ShowMessage("E' necessario configurare il conto di costo per recuperi negativi" +
                                    " per la voceCSA " + rVer["vocecsa"]);
                        return false;
                    }

                    var idupb = rVer["idupb"];
                    var idepcontext_ricavo = "INCAS";


                    List<InfoImpegno> impegniBudget = getAmountsForScrittureVer(rVer, rVer["idupb"], false);
                    foreach (InfoImpegno i in impegniBudget) {
                        if (i.parIdExp == DBNull.Value && UsaImpegniDiBudget && esercizio > 2015 &&
                            EP.isCosto(idaccCost)) {
                            ShowMessage(
                                $"Non è stato trovato un impegno di budget per la riga di versamento n. {rVer["idver"]} per \"{doc}\"",
                                "Errore");
                            return false;
                        }

                        object currUPB = getUpbForEpExp(i.parIdExp, rVer["idupb"], bf?.D.Tables["epexpyear"]);
                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo,
                            i.amount, idaccPayment,
                            idreg, currUPB, DBNull.Value, DBNull.Value,
                            null, getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost), i.parIdExp, null,
                            i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext_ricavo, i.amount, idaccDebit, /*manca causale*/
                            idreg, currUPB, DBNull.Value, DBNull.Value, null,
                            getAccMotiveForSiope(rVer["idsor_siope_cost"], idaccCost),
                            i.parIdExp, null, i.idrelated,
                            "Versamento, riga " + rVer["idver"] + "- Capitolo: " + rVer["capitolocsa"] + "- Ruolo: " +
                            rVer["ruolocsa"] + "- Matricola: " + rVer["matricola"]);
                        if (EP.saldo != 0) {
                            ShowMessage("Si è verificata una squadratura sulla riga di Versamento " +
                                        rVer["idver"] + "- Ruolo: " + rVer["ruolocsa"] + "- Matricola: " +
                                        rVer["matricola"] + " (recuperi negativi) ");
                            return false;
                        }

                    }

                }
            }



            EP.RemoveEmptyDetails();
            return true;
        }

        Dictionary<int, importo_causale> getImportiFattura(object idinvkind, object yinv, object ninv) {
            Dictionary<int, importo_causale> list = new Dictionary<int, importo_causale>();
            var idRelated = _composeObjects("inv", idinvkind, yinv, ninv);
            var tEntry = Conn.RUN_SELECT("entry", "*", null,
                QHS.CmpEq("idrelated", idRelated), null, false);
            if (tEntry.Rows.Count == 0) return list;
            DataRow rInv = tEntry.Rows[0];
            object idreg = Conn.DO_READ_VALUE("invoice", QHS.AppAnd(QHS.CmpEq("idinvkind", idinvkind),
                QHS.CmpEq("yinv", yinv), QHS.CmpEq("ninv", ninv)), "idreg", null);
            DataTable tDet = Conn.RUN_SELECT("entrydetail", "*", null,
                QHS.AppAnd(QHS.CmpEq("idreg", idreg), QHS.CmpKey(rInv)), null, false);
            foreach (DataRow r in tDet.Select()) {

                if (r["idepexp"] == DBNull.Value) continue;
                if (!EP.isDebit(r["idacc"])) continue;
                int idepexp = CfgFn.GetNoNullInt32(r["idepexp"]);
                decimal amount = Math.Abs(CfgFn.GetNoNullDecimal(r["amount"]));
                if (!list.ContainsKey(idepexp)) {
                    list.Add(idepexp, new importo_causale(amount, r["idaccmotive"], r["idrelated"].ToString()));
                }
                else {
                    var c = list[idepexp];
                    c.amount += amount;
                }
            }

            return list;
        }




        Dictionary<int, importo_causale> getImportiDaImpegni(string filter, object idreg, string amountField) {
            DataTable impegniBudget = Conn.RUN_SELECT("epexpview_pluriennale",
                "idepexp, idaccmotive,idrelated," + amountField,
                null,
                QHS.AppAnd(filter, QHS.CmpEq("nphase", 2), QHS.CmpEq("idreg", idreg)), //QHS.CmpEq("ayear", esercizio),
                null, false);
            if (impegniBudget.Rows.Count > 0) {
                return ottieniImportiImpegnoDaTabellaIdrelated(impegniBudget, "idepexp", amountField, false);
            }
            else {
                return new Dictionary<int, importo_causale>();
            }
        }

        Dictionary<int, importo_causale> getImportiImpegni(DataRow curr, Tipocont currCont) {

            if (currCont == Tipocont.ContIva) {
                var r = Conn.RUN_SELECT("pettycashoperationinvoice", "*", null, QHS.CmpKey(curr), null, false).Rows[0];
                //DataTable 
                //var idRelated = _composeObjects("inv", r["idinvkind"], r["yinv"], r["ninv"]);
                //var list = getImportiDaImpegni(BudgetFunction.getDocChildCondition(QHS, idRelated));
                //if (list.Count > 0) return list;
                return getImportiFattura(r["idinvkind"], r["yinv"], r["ninv"]);
            }

            if (currCont == Tipocont.ContOccasionale) {
                var r =
                    Conn.RUN_SELECT("pettycashoperationcasualcontract", "*", null, QHS.CmpKey(curr), null, false).Rows[0
                    ];
                var idRelated = _composeObjects("cascon", r["ycon"], r["ncon"]);
                var idreg = Conn.DO_READ_VALUE("casualcontract",
                    QHS.AppAnd(QHS.CmpEq("ycon", r["ycon"]), QHS.CmpEq("ncon", r["ncon"])), "idreg", null);
                return getImportiDaImpegni(BudgetFunction.getDocChildCondition(QHS, idRelated), idreg, "totcurramount");
            }

            if (currCont == Tipocont.ContProfessionale) {
                var r =
                    Conn.RUN_SELECT("pettycashoperationprofservice", "*", null, QHS.CmpKey(curr), null, false).Rows[0];
                var idRelated = _composeObjects("profservice", r["ycon"], r["ncon"]);
                var idreg = Conn.DO_READ_VALUE("profservice",
                    QHS.AppAnd(QHS.CmpEq("ycon", r["ycon"]), QHS.CmpEq("ncon", r["ncon"])), "idreg", null);
                return getImportiDaImpegni(BudgetFunction.getDocChildCondition(QHS, idRelated), idreg, "totaldebit");
            }

            if (currCont == Tipocont.ContMissione) {
                var r =
                    Conn.RUN_SELECT("pettycashoperationitineration", "*", null, QHS.CmpKey(curr), null, false).Rows[0];
                object idreg = Conn.DO_READ_VALUE("itineration",
                    QHS.CmpEq("iditineration", r["iditineration"]), "idreg", null);
                var tipomovimento = CfgFn.GetNoNullInt32(r["movkind"]);
                if (tipomovimento == 5) {
                    //se contabilizzazione anticipo su p. di giro, non fare nulla
                    return new Dictionary<int, importo_causale>();
                }

                var idRelated = _composeObjects("itineration", r["iditineration"]);
                return getImportiDaImpegni(BudgetFunction.getDocChildCondition(QHS, idRelated), idreg, "totaldebit");
            }

            var idrelated = BudgetFunction.GetIdForDocument(curr);
            var idepexp = getIdEpExpByIdRelated(idrelated, 2);
            var dict = new Dictionary<int, importo_causale>();
            if (idepexp != DBNull.Value) {
                dict.Add(CfgFn.GetNoNullInt32(idepexp),
                    new importo_causale(CfgFn.GetNoNullDecimal(curr["amount"]), curr["idaccmotive"], idrelated));
            }

            return dict;
        }

        /// <summary>
        /// Verifica se la generazione dei mov. di budget è abilitata per una riga
        /// </summary>
        /// <param name="r"></param>
        /// <param name="nPhase"></param>
        /// <returns></returns>
        bool impegniAccertamentiAbilitati(DataRow r, int nPhase) {
            if (!UsaImpegniDiBudget) return false;
            //if (cicloAttivo() && (UsaAccertamentiDiBudget == false)) return false;
            var idrelatedEp = BudgetFunction.GetIdForDocument(r);
            if (idrelatedEp == null) return false;
            var filter = BudgetFunction.getDocChildCondition(QHS, idrelatedEp);
            string table = cicloAttivo() ? "epacc" : "epexp";
            var nEpExp1 = Conn.RUN_SELECT_COUNT(table + "view", QHS.AppAnd(
                    filter, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                , true);
            var nEpExp2 = Conn.RUN_SELECT_COUNT(table + "view", QHS.AppAnd(
                    filter, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2))
                , true);
            if (r.Table.TableName == "csa_importriep" || r.Table.TableName == "csa_importver" ||
                r.Table.TableName == "assetunload" ||
                r.Table.TableName == "assetload" || r.Table.TableName == "provision" ||
                r.Table.TableName == "invoice" ||
                r.Table.TableName == "upbcommessa") {
                nEpExp1 += Conn.RUN_SELECT_COUNT("epacc" + "view", QHS.AppAnd(
                        filter, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                    , true);
                nEpExp2 += Conn.RUN_SELECT_COUNT("epacc" + "view", QHS.AppAnd(
                        filter, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 2))
                    , true);
            }

            if (nPhase == 0 && !preImpegniAbilitati(r) && nEpExp1 == 0) {
                nPhase = 2;
            }

            if (nPhase == 1 && !preImpegniAbilitati(r)) return false; //&& nEpExp1 == 0
            if (nPhase == 2 && !impegniAbilitati(r)) return false; //&& nEpExp2 == 0

            return true;
        }

        /// <summary>
        /// Deve valorizzare  EPRules 
        /// </summary>
        /// <param name="nPhase"></param>
        /// <param name="scrittureGenerate"></param>
        /// <param name="impegniGenerati"></param>
        /// <returns></returns>
        public bool generaImpegniAccertamenti(int nPhase, out bool scrittureGenerate, out bool impegniGenerati) {
            scrittureGenerate = false;
            impegniGenerati = false;
            //meta.GetFormData(true);
            DataRow curr = getCurrentRow();
            if (curr == null) return false;
            bool res = generaImpegniAccertamenti(curr, nPhase, out scrittureGenerate, out impegniGenerati);
            mostraEtichette();
            return res;
        }

        private string childExcluded = null;

        /// <summary>
        /// Deve valorizzare  EPRules 
        /// </summary>
        /// <param name="curr"></param>
        /// <param name="nPhase"></param>
        /// <param name="scrittureGenerate"></param>
        /// <param name="impegniGenerati"></param>
        /// <returns></returns>
        public bool generaImpegniAccertamenti(DataRow curr, int nPhase, out bool scrittureGenerate,
            out bool impegniGenerati) {
            scrittureGenerate = false;
            impegniGenerati = false;
            var bf = new BudgetFunction(meta.Dispatcher)
                {metaNameForPosting = metaTableForPosting, autoIgnore = autoIgnore, silent = silentPosting};
            if (!bf.attivo) return false;
            clearAllDictionary();
            childExcluded = null;
            var idrelatedEp = BudgetFunction.GetIdForDocument(curr);
            if (idrelatedEp == null) return false;
            var filterEp = BudgetFunction.getDocChildCondition(QHS, idrelatedEp);
            string table = cicloAttivo() ? "epacc" : "epexp";
            string secondatable = cicloAttivo() ? "epexp" : "epacc";
            var nEpExp1 = Conn.RUN_SELECT_COUNT(table + "view", QHS.AppAnd(
                    filterEp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                , true);
            //bool doppioCiclo = false;
            if (doppioMovimento(mainTable)) {
                nEpExp1 += Conn.RUN_SELECT_COUNT(secondatable + "view", QHS.AppAnd(
                        filterEp, QHS.CmpEq("ayear", esercizio), QHS.CmpEq("nphase", 1))
                    , true);
                //doppioCiclo = true;
            }


            if (!impegniAccertamentiAbilitati(curr, nPhase)) return false;

            bf.getEpMovForDocument(table, idrelatedEp, nPhase);
            foreach (DataRow r in bf.D.Tables["epexpyear"].Select()) {
                idupbForEpExp[(int) r["idepexp"]] = r["idupb"];
            }

            foreach (DataRow r in bf.D.Tables["epexp"].Select()) {
                nphaseForIdEpExp[(int) r["idepexp"]] = CfgFn.GetNoNullInt32(r["nphase"]);
            }


            //TODO: verificare che per csa_import sia anche necessario e giusto leggere questi movimenti, prima non lo faceva
            if (doppioMovimento(mainTable)) {
                bf.getEpMovForDocument(secondatable, idrelatedEp,
                    nPhase); //per assetload rilegge anche gli accertamenti
            }

            foreach (DataRow r in bf.D.Tables["epaccyear"].Select()) {
                idupbForEpAcc[(int) r["idepacc"]] = r["idupb"];
            }

            bf.clearAll();


            switch (mainTable) {
                case "mandate":
                case "upbcommessa":
                case "assetunload":
                case "assetload":
                case "grantload":
                case "estimate":
                case "invoice":
                case "itineration":
                case "casualcontract":
                case "wageaddition":
                case "pettycashoperation":
                case "parasubcontract":
                case "payroll":
                case "profservice":
                case "csa_import": //anche per debito
                case "csa_importriep":
                case "csa_importver":
                case "provision":
                    standardPreSave();
                    break;

            }

            foreach (DataRow r in bf.D.Tables["epexp"].Rows) {
                if (r["nphase"].ToString() == "1" && r["idrelated"] != DBNull.Value) {
                    _listaPreimpegniByIdRelated[r["idrelated"].ToString()] = r;
                }

                if (r["nphase"].ToString() == "2" && r["idrelated"] != DBNull.Value) {
                    _listaImpegniByIdRelated[r["idrelated"].ToString()] = r;
                }
            }

            foreach (DataRow r in bf.D.Tables["epacc"].Rows) {
                if (r["nphase"].ToString() == "1" && r["idrelated"] != DBNull.Value) {
                    _listaPreaccertamentiByIdRelated[r["idrelated"].ToString()] = r;
                }

                if (r["nphase"].ToString() == "2" && r["idrelated"] != DBNull.Value) {
                    _listaAccertamentiByIdRelated[r["idrelated"].ToString()] = r;
                }
            }

            bool res = false;
            if (nPhase == 0) {
                if (nEpExp1 > 0) { // || possibiliContributi
                    //genera una fase alla volta
                    res = generaImpegniAccertamentiUnaFase(bf, curr, 1);
                    if (res) res = generaImpegniAccertamentiUnaFase(bf, curr, 2);
                    if (res) bf.cancellaParentSenzaFigli();
                }
                else {
                    childExcluded = idrelatedEp;
                    //ShowMessage(childExcluded);
                    //genera solo la 2a fase e poi crea la prima a sua immagine e somiglianza  oppure collega movimenti esistenti
                    res = generaImpegniAccertamentiUnaFase(bf, curr, 2);
                    childExcluded = null;
                }
            }
            else {
                res = generaImpegniAccertamentiUnaFase(bf, curr, nPhase);
                if (nPhase == 1) {
                    bf.cancellaParentConFigliAssegnati();
                }
            }

            impegniGenerati = bf.MainEpExpExists();
            if (!res) return false;

            ///Questo già valorizza EPRules se bf null
            scrittureGenerate = generaScritture(curr, bf);

            bf.updateAmounts(cicloAttivo());

            //TODO:verificare che era necessario per csa_import, prima non lo faceva
            if (doppioMovimento(mainTable)) {
                bf.updateAmounts(!cicloAttivo());
            }

            res = bf.SaveAll(this.silent, this.chiediMovimentiParent, invokedByInnerPosting ? postingClass : null);
            EPRules = bf.EPRules;

            if (!res) {
                //Deve valorizzare  EPRules 
                scrittureGenerate = false;
                mostraEtichette();
                return false;
            }

            switch (mainTable) {
                case "profservice":
                    aggiornaIdEpExpDettagliFatturaParcella();
                    break;
                case "estimate":
                    aggiornaIdEpAccDettagliContrattoAttivo();
                    break;
                case "grantload":
                    aggiornaIdEpAccDettagliRisconti();
                    break;
                case "mandate":
                    aggiornaIdEpExpDettagliOrdine();
                    aggiornaIdEpAccDettagliOrdine();
                    break;
                case "invoice":
                    invoicePostSave();
                    break;
				case "provision":
					aggiornaIdEpExpAccantonamento();
					break;
			}

            mostraEtichette();
            clearHashImpegniByIdRelated();
            return true;
        }


        bool generaImpegniAccertamentiUnaFase(BudgetFunction bf, DataRow curr, int nPhase) {
            bool savedSilent = silent;
            switch (mainTable) {
                case "upbcommessa":
                    silent = true;
                    bool res_comm = generaAccertamentiUpbCommessaCompletata(bf, curr, nPhase);
                    silent = res_comm | silentBlocked;
                    res_comm |= generaImpegniUpbCommessaCompletata(bf, curr, nPhase);
                    silent = savedSilent;
                    return res_comm;
                case "mandate":
                    return generaImpegniContrattoPassivoUnaFase(bf, curr, nPhase);
                case "estimate":
                    return generaAccertamentiContrattoAttivoUnaFase(bf, curr, nPhase);
                case "grantload":
                    return generaAccertamentiRiscontiUnaFase(bf, curr, nPhase);
                case "assetload":
                    return generaImpegniBuonoCaricoUnaFase(bf, curr, nPhase);
                case "assetunload":
                    silent = true;
                    bool res_scar = generaAccertamentiBuonoScaricoUnaFase(bf, curr, nPhase);
                    silent = res_scar | silentBlocked;
                    res_scar |= generaImpegniBuonoScaricoUnaFase(bf, curr, nPhase);
                    silent = savedSilent;
                    return res_scar;
                case "invoice":
                    silent = true;
                    bool res = generaAccertamentiFatturaUnaFase(bf, curr, nPhase);
                    silent = res | silentBlocked;
                    res |= generaImpegniFatturaUnaFase(bf, curr, nPhase);
                    silent = savedSilent;
                    return res;
                case "itineration":
                    return generaImpegniMissioneUnaFase(bf, curr, nPhase);
                case "casualcontract":
                    return generaImpegniContrattoOccasionale(bf, curr, nPhase);
                case "wageaddition":
                    return generaImpegniContrattoDipendente(bf, curr, nPhase);
                case "pettycashoperation":
                    return generaImpegniFondoEconomale(bf, curr, nPhase);
                case "payroll":
                    return generaImpegniCedolino(bf, curr, nPhase);
                case "profservice":
                    return generaImpegniProfessionale(bf, curr, nPhase);
                case "csa_importriep_partitionview":
                    return generaImpegniRiepilogoNuovaGestione(bf, curr, nPhase);
                case "csa_importriep":
                    return generaImpegniRiepilogo(bf, curr, nPhase);
                case "csa_importver":
                    return generaImpegniVersamenti(bf, curr, nPhase);
                case "csa_import":
                    if (tipoScrittura == null) {
                        //ShowMessage("csaimport");
                        silent = true;
                        bool res2 = generaImpegniImportazioneCsa(bf, curr, nPhase);
                        silent = res2 | silentBlocked;
                        res2 |= generaAccertamentiImportazioneCsa(bf, curr, nPhase);
                        silent = savedSilent;
                        return res2;
                    }

                    break;
                case "provision":
                    silent = true;
                    bool res_Prov = generaAccertamentiProvisionUnaFase(bf, curr, nPhase);
                    silent = res_Prov | silentBlocked;
                    res_Prov |= generaImpegniProvisionUnaFase(bf, curr, nPhase);
                    silent = savedSilent;
                    return res_Prov;
            }

            return false;
        }

        string getDescrCespite(object idasset, object idpiece) {
            string fk = QHS.AppAnd(QHS.CmpEq("idasset", idasset), QHS.CmpEq("idpiece", idpiece));
            object nInventory = Conn.DO_READ_VALUE("assetview", fk, "ninventory");
            object Inventory = Conn.DO_READ_VALUE("assetview", fk, "inventory");
            return $"cespite n. {nInventory} dell'inventario {Inventory}";
        }

        bool generaAccertamentiRiscontiUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            string kind = curr["kind"].ToString().ToUpper(); //D / U
			//string tipo = kind == "D" ? "Costituzione risconto/Riserva su cespiti" : "Utilizzo Risconti/Riserve su cespiti finanziati";
			//object doc = $"{tipo}";
			DataTable assetgrantload = DS.Tables["assetgrantload"];
            if (CfgFn.GetNoNullInt32(curr["yload"]) != esercizio) {
                if (!silent)
                    ShowMessage("Accertamenti sul risconto/contributo non fanno parte di questo esercizio.",
                        "Errore");
                return false;
            }

            bool somethingFound = false;
            string filterMainCurrent = QHC.CmpKey(curr);
            string idrelated = BudgetFunction.GetIdForDocument(curr).ToLower();

            DataTable assetgrant = Conn.RUN_SELECT("assetgrant", "*", null, QHS.CmpKey(curr), null, false);
            DataTable assetgrantdetail = Conn.RUN_SELECT("assetgrantdetail", "*", null, QHS.CmpKey(curr), null, false);
            object dataAccertamenti = curr["adate"];

            foreach (DataRow rGrant in assetgrant.Rows) {
                object flag_financesource = rGrant["flag_financesource"];
                //Per la parte degli Utili non deve generare l'accertamento
                if (flag_financesource.ToString() == "U") continue;

                var idrel = BudgetFunction.GetIdForDocument(rGrant);
                object idupb = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrant, "idasset", "idpiece"), "idupb");
                if (idupb == null || idupb == DBNull.Value) {
                    ShowMessage(
                        $"Il {getDescrCespite(rGrant["idasset"], rGrant["idpiece"])} non ha una UPB associata",
                        "Errore");
                    return false;
                }

                string descrCespite = getDescrCespite(rGrant["idasset"], rGrant["idpiece"]);
                object idaccmotive = rGrant["idaccmotive"];
                if (idaccmotive == DBNull.Value) {
                    object descr = rGrant["description"];
                    ShowMessage(
                        $"La definizione del contributo {descr} del  {descrCespite} non ha una causale associata",
                        "Errore");
                    return false;
                }

                decimal amount = CfgFn.GetNoNullDecimal(rGrant["amount"]);

                var idacc = getIdAccFromMotive(idaccmotive, idupb);
                if (idacc == null || idacc == DBNull.Value) {
                    ShowMessage(
                        $"Causale non configurata bene per il contributo {rGrant["description"]} del  {descrCespite}",
                        "Errore");
                    return false;
                }

                if (!isBudgetEnabled(idacc)) continue;
                object idman = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrant, "idasset", "idpiece"), "idcurrman");

                var parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);
                var currEpAcc = bf.addEpAcc(DBNull.Value, idman, amount,
                    $"Contributo {rGrant["description"]} del {descrCespite}", dataAccertamenti, idacc, idupb, idrel,
                    rGrant["doc"], rGrant["docdate"],
                    DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, idaccmotive);
                if (currEpAcc == null) return false;
                currEpAcc["flagvariation"] = "S";
                addAccertamentoToDict(currEpAcc, idrel);

                somethingFound = true;
            }

            object idaccmotive_RiscRicavo = Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", Conn.GetEsercizio()),
                "idaccmotive_grantrevenue");

            foreach (DataRow rGrantDet in assetgrantdetail.Rows) {
                object flag_financesource = Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "flag_financesource");
                //Per la parte degli Utili non deve generare l'accertamento
                if (flag_financesource.ToString() == "U") continue;

                var idrel = BudgetFunction.GetIdForDocument(rGrantDet);
                object idupb = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrantDet, "idasset", "idpiece"), "idupb");
                if (idupb == null || idupb == DBNull.Value) {
                    ShowMessage(
                        $"Il {getDescrCespite(rGrantDet["idasset"], rGrantDet["idpiece"])} non ha una UPB associata",
                        "Errore");
                    return false;
                }

                string descrCespite = getDescrCespite(rGrantDet["idasset"], rGrantDet["idpiece"]);
                object descrGrant = Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "description");
                int ygrant = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "ygrant"));
                object idaccmotive = idaccmotive_RiscRicavo;
                if (idaccmotive == DBNull.Value || ygrant == Conn.GetEsercizio()) {
                    idaccmotive = Conn.DO_READ_VALUE("assetgrant", QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"),
                        "idaccmotive");
                }

                if (idaccmotive == null || idaccmotive == DBNull.Value) {
                    ShowMessage(
                        $"La definizione del contributo {descrGrant} del  {descrCespite} non ha una causale associata",
                        "Errore");
                    return false;
                }

                decimal amount = CfgFn.GetNoNullDecimal(rGrantDet["amount"]);
                var idacc = getIdAccFromMotive(idaccmotive, idupb);
                if (idacc == null || idacc == DBNull.Value) {

                    ShowMessage($"Causale non configurata bene per il contributo {descrGrant} del  {descrCespite}",
                        "Errore");
                    return false;
                }

                if (!isBudgetEnabled(idacc)) continue;
                object idman = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrantDet, "idasset", "idpiece"), "idcurrman");

                var parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);
                var currEpAcc = bf.addEpAcc(DBNull.Value, idman, amount,
                    $"Risconto del contributo {descrGrant} del {descrCespite}", dataAccertamenti, idacc, idupb, idrel,
                    DBNull.Value, DBNull.Value,
                    DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, idaccmotive);
                if (currEpAcc == null) return false;
                addAccertamentoToDict(currEpAcc, idrel);
                somethingFound = true;
            }

            if (!somethingFound) {
                var obj = (nphase == 1) ? "preaccertamento" : "accertamento";
                if (!silent) {
                    ShowMessage(
                        $"Nessun contributo o risconto ha la causale EP quindi nessun {obj} è stato generato.",
                        "Avviso", false);
                }

                return true;
            }

            return true;
        }

        Dictionary<string, bool> budgetEnabled = new Dictionary<string, bool>();

        bool isBudgetEnabled(object idacc) {
            if (idacc == DBNull.Value) return false;
            if (idacc == null) return false;
            if (budgetEnabled.ContainsKey(idacc.ToString())) return budgetEnabled[idacc.ToString()];
            object flag = Conn.DO_READ_VALUE("account", QHS.CmpEq("idacc", idacc), "flagenablebudgetprev");
            budgetEnabled[idacc.ToString()] = (flag != null && flag.ToString().ToUpper() == "S");
            return budgetEnabled[idacc.ToString()];
        }

        int annoOrigineDettaglioContratto(DataRow rDetail, DataRow main) {
            DataRow firstRow = getFirstRow(rDetail);
            DateTime dataOriginale = firstRow["start"] == DBNull.Value
                ? (DateTime) main["adate"]
                : (DateTime) firstRow["start"];
            return dataOriginale.Year;
        }

        bool rateo(DataRow rDetail) {
            object epkind = rDetail["epkind"];
            return epkind.ToString().ToUpper() == "R";
        }

        bool fatturaARicevereOEmettere(DataRow rDetail) {
            object epkind = rDetail["epkind"];
            return epkind.ToString().ToUpper() == "F";
        }


        bool rateoOFatturaARicevere(DataRow rDetail) {
            object epkind = rDetail["epkind"];
            return (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R");
        }

        bool dettaglioContrattoInseritoinFattura(DataRow rDetail) {
            string filter;
            if (rDetail.Table.TableName == "estimatedetail") {
                filter = QHS.AppAnd(QHS.CmpEq("idestimkind", rDetail["idestimkind"]),
                    QHS.CmpEq("yestim", rDetail["yestim"]), QHS.CmpEq("nestim", rDetail["nestim"]),
                    QHS.CmpEq("estimrownum", rDetail["rownum"]));
            }
            else {
                filter = QHS.AppAnd(QHS.CmpEq("idmankind", rDetail["idmankind"]), QHS.CmpEq("yman", rDetail["yman"]),
                    QHS.CmpEq("nman", rDetail["nman"]), QHS.CmpEq("manrownum", rDetail["rownum"]));
            }

            int N = Conn.RUN_SELECT_COUNT("invoicedetail", filter, false);
            if (N > 0) return true;
            return false;
        }

        /// <summary>
        /// Stabilisce se è da generare una variazione sul movimento esistente, nella data fine di questo dettaglio (trattasi di un dettaglio sostituito)
        /// c'è successivo (di anno fine ove presente diversa) e anno origine nell'esercizio e data fine nell'esercizio e non è collegabile a fattura
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool variazioneSuMovimento_4(DataRow rDetail, DataRow main) {
            //il dettaglio sostituito deve avere data inizio nell'anno, ossia questo deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //ci deve essere un elemento successivo
            var next = getNextRow(rDetail);
            if (next == null) return false;
            if (movimentoCreazioneDettaglioContrattoDaGenerare_2(next, main)) return false;

            //La variazione è fatta solo sull'ultimo elemento della catena annullato nello stesso anno
            if (next["stop"] != DBNull.Value) {
                DateTime nextStop = (DateTime) next["stop"];
                if (nextStop.Year == esercizio) return false; //è sul prossimo che creerà qualcosa
            }

            //i dettagli che generano variazioni di movimento di tipo variazione sono i contratti collegabili o i non collegabili nell'anno di origine
            //  i contratti NON collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli collegabili
            if (annoOrigineDettaglioContratto(rDetail, main) == esercizio) return true;

            bool scrittureAbilitate = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            bool collegabileAFattura = !scrittureAbilitate;
            if (!collegabileAFattura) return false; //variazione fatta con Cinzia 
            if (fatturaARicevereOEmettere(rDetail)) return false;

            //era:return (annoOrigineDettaglioContratto(rDetail, main) == esercizio || collegabileAFattura);
            return true;
        }





        /// Stabilisce se deve generare un movimento di tipo variazione: (trattasi di dettaglio sostituito)
        /// se data fine in esercizio corrente e ha successivo e anno origine di anni precedenti
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoDiTipoVariazione_1(DataRow rDetail, DataRow main) {
            //il dettaglio sostituito deve avere data inizio nell'anno, ossia questo deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //ci deve essere un elemento successivo
            var next = getNextRow(rDetail);
            if (next == null) return false;

            //l'anno di origine deve essere precedente 
            if (annoOrigineDettaglioContratto(rDetail, main) >= esercizio) return false;

            bool scrittureAbilitate = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            bool collegabileAFattura = !scrittureAbilitate;
            if (collegabileAFattura) {
                if (fatturaARicevereOEmettere(rDetail)) return true;
                return
                    false; ///& ! rateoOFatturaARicevere(rDetail) non può generare un nuovo accertamento sullo stesso dettaglio
            }

            //  i contratti collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli NON collegabili
            return true;
        }

        /// Stabilisce se deve generare un movimento di tipo variazione: (trattasi di dettaglio sostituito collegato a rateo)
        /// se data fine in esercizio corrente e ha successivo e anno origine di anni precedenti
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoDiTipoVariazionePerRateo(DataRow rDetail, DataRow main) {
            //il dettaglio sostituito deve avere data inizio nell'anno, ossia questo deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //ci deve essere un elemento successivo
            var next = getNextRow(rDetail);
            if (next == null) return false;

            //l'anno di origine deve essere precedente 
            if (annoOrigineDettaglioContratto(rDetail, main) >= esercizio) return false;

            bool scrittureAbilitate = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            bool collegabileAFattura = !scrittureAbilitate;
            if (collegabileAFattura) {
                if (rateo(rDetail)) {
                    if (getTotaleImponibile(main, next) == 0) return true; //se rateo
                }
            }

            //  i contratti collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli NON collegabili
            return false;
        }

        /// <summary>
        /// Verifica che la data fine sia dell'anno
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool annulloGenericoDaGenerare(DataRow rDetail, DataRow main) {
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;
            return true;
        }

        /// <summary>
        /// Stabilisce se deve generare una VARIAZIONE di ANNULLO O A RESIDUO(var) del movimento di budget esistente
        /// stop dell'anno, anno originale=esercizio
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool variazioneAnnulloOAResiduoDaGenerare_5(DataRow rDetail, DataRow main) {
            //deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //non ci deve essere elemento successivo, se c'è un elemento successivo non è un vero annullo ma una sostituzione
            if (getNextRow(rDetail) != null)
                return false; //NO questo prescinde e invece SI, con le recenti modifiche è necessaria questa condizione

            if (annoOrigineDettaglioContratto(rDetail, main) == esercizio) return true;

            bool scrittureAbilitate = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            bool collegabile = !scrittureAbilitate;
            if (collegabile) return true; //& !rateoOFatturaARicevere(rDetail) 

            //Ratei o fatture a ricevere nell'anno di annullo devono azzerare l'accertamento di budget
            //if (rateoOFatturaARicevere(rDetail)) return true;

            //  i contratti collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli non collegabili
            //NO i fatt.  a ricevere no
            //l'anno di origine deve essere il corrente OPPURE deve essere collegabile a fattura, nel qual caso va lo stesso bene la variazione di annullo
            return false;

        }

        /// <summary>
        /// Validato con Cinzia
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoOppostoDaGenerare(DataRow rDetail, DataRow main) {
            //deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //creato in anno precedente
            if (annoOrigineDettaglioContratto(rDetail, main) >= esercizio) return false;

            bool scrittureAbilitate = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            bool collegabile = !scrittureAbilitate;

            if (!collegabile) return true;

            if (fatturaARicevereOEmettere(rDetail)) return true;

            if (rateo(rDetail) && getNextRow(rDetail) == null) return true;

            return false;
        }


        /// <summary>
        /// Vede se deve generare una variazione di movimento  in generale (non considera gli accertamenti di tipo variazione)
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool variazionemovimentoDettaglioContrattoDaGenerare_3(DataRow rDetail, DataRow main) {
            if (variazioneAnnulloOAResiduoDaGenerare_5(rDetail, main)) return true;
            if (variazioneSuMovimento_4(rDetail, main)) return true;
            return false;
        }

        /// <summary>



        /// <summary>
        /// Stabilisce se deve creare un movimento normale o correggere l'importo di un movimento
        /// Nell'anno di creazione di un dettaglio si deve generare un accertamento di budget.
        ///		Questo è l'anno del contratto se il dettaglio non ha data inizio, altrimenti l'anno della data inizio.
        ///		Se il dettaglio è parte di un gruppo, la data inizio è quella del primo dettaglio della catena, e l'accertamento
        ///		va associato all'ultimo dettaglio della catena, quello che non ha successori, ma i dati vanno presi dal primo dettaglio della catena,
        /// quello che non ha precedenti.
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoCreazioneDettaglioContrattoDaGenerare_2(DataRow rDetail, DataRow main) {
            //l'anno di origine deve essere il corrente
            if (annoOrigineDettaglioContratto(rDetail, main) != esercizio) return false;

            //non ci deve essere un elemento successivo 
            var next = getNextRow(rDetail);
            if (next != null) {
                return false;
            }

            if (rDetail["stop"] == DBNull.Value) return true;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year == esercizio) return false; //non ricrea movimenti annullati nell'anno
            return true;
        }

        /// <summary>
        /// Stabilisce se deve generare una  variazione movimento in anni successivi del proprio successore
        /// Deve essere un dettaglio di contratto collegabile a fattura.
        ///	L'anno del contratto deve essere precedente la data (inizio?)
        ///		Se il dettaglio è parte di un gruppo, la data inizio è quella del primo dettaglio della catena, e l'accertamento
        ///		va associato all'ultimo dettaglio della catena, quello che non ha successori NELL'ANNO, ma i dati vanno presi dal primo dettaglio della catena,
        /// quello che non ha precedenti.
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoCreazioneDettaglioContrattoDaGenerareComeModificaSuccessivo(DataRow rDetail, DataRow main) {

            if (rDetail["stop"] == DBNull.Value) return false; //deve essere un dettaglio annullato nell'anno
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //se non collegabile, la modifica dell'importo vale solo per il primo anno
            if (annoOrigineDettaglioContratto(rDetail, main) == esercizio) return false;

            //bool scrittureAbilitate = isEstimKindEpEnabled(rDetail["idestimkind"]);
            //if (scrittureAbilitate) return false;
            //l'anno di origine non deve essere il corrente NO non più, va bene anche il corrente
            //if (annoOrigineDettaglioContratto(rDetail, main) == esercizio) return false;
            bool nonCollegabile = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);

            bool Collegabile = !nonCollegabile;
            if (nonCollegabile || fatturaARicevereOEmettere(rDetail)) return false;

            //ci deve essere un elemento successivo
            var next = getNextRow(rDetail);
            if (next == null) return false;

            //il dettaglio successivo non deve essere annullato nello stesso anno
            if (next["stop"] == DBNull.Value) return true;
            DateTime nextStop = (DateTime) next["stop"];
            if (nextStop.Year == esercizio) return false;
            return true;
        }

        /// <summary>
        /// Stabilisce se deve generare una  variazione movimento in anni successivi di se stesso, è la stessa condizione di prima vista dalla riga sostituente
        /// Deve essere un dettaglio di contratto collegabile a fattura.
        ///	L'anno del contratto deve essere precedente la data 
        ///		Se il dettaglio è parte di un gruppo, la data inizio è quella del primo dettaglio della catena, e l'accertamento
        ///		va associato all'ultimo dettaglio della catena, quello che non ha successori, ma i dati vanno presi dal primo dettaglio della catena,
        /// quello che non ha precedenti.
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        /// 
        bool movimentoCreazioneDettaglioContrattoDaGenerareComeModificaPropria(DataRow rDetail, DataRow main) {
            bool nonCollegabile = (rDetail.Table.TableName == "estimatedetail")
                ? isEstimKindEpEnabled(rDetail["idestimkind"])
                : isManKindEpEnabled(rDetail["idmankind"]);
            //if (scrittureAbilitate && (annoOrigineDettaglioContratto(rDetail, main) != esercizio)) return false;
            bool collegabile = !nonCollegabile;

            //  i contratti NON collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli collegabili
            // scrittureAbilitate == non collegabile
            if (nonCollegabile || fatturaARicevereOEmettere(rDetail) ||
                annoOrigineDettaglioContratto(rDetail, main) == esercizio) return false;

            var prev = getPrevRow(rDetail);

            //ci deve essere un elemento precedente annullato nell'anno
            if (prev == null) return false;
            if (prev["stop"] == DBNull.Value) return false;
            DateTime prevStop = (DateTime) prev["stop"];
            if (prevStop.Year != esercizio) return false;

            //if (causaleCosto(rDetail["idaccmotiveannulment"])) return false;

            //il dettaglio stesso non deve essere annullato nello stesso anno
            if (rDetail["stop"] == DBNull.Value) return true; //deve essere un dettaglio annullato nell'anno
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year == esercizio) return false;

            return true;
        }

        /// <summary>
        /// Stabilisce se deve generare un movimento di budget oppsto (ossia un impegno nei contratti attivi)
        /// </summary>
        /// <param name="rDetail"></param>
        /// <param name="main"></param>
        /// <returns></returns>
        bool movimentoOppostoDettaglioContrattoDaGenerare(DataRow rDetail, DataRow main) {
            //deve avere data fine nell'anno
            if (rDetail["stop"] == DBNull.Value) return false;
            DateTime stop = (DateTime) rDetail["stop"];
            if (stop.Year != esercizio) return false;

            //l'anno di origine deve essere di precedente l'esercizio
            if (annoOrigineDettaglioContratto(rDetail, main) >= esercizio) return false;

            //non ci deve essere elemento successivo
            if (getNextRow(rDetail) != null) return false;


            return true;
        }

        DataRow getEpMovYear(BudgetFunction bf, DataRow rDetail, int nphase) {
            if (rDetail.Table.TableName == "estimatedetail") {
                if (nphase == 2) {
                    return bf.getEpAccYearById(rDetail["idepacc"]);
                }
                else {
                    var idrel = BudgetFunction.GetIdForDocument(rDetail);
                    DataRow rParEpacc = bf.getEpAccRow(idrel, 1);
                    object paridepacc = rParEpacc?["idepacc"] ??
                                        Conn.DO_READ_VALUE("epacc", QHS.CmpEq("idepacc", rDetail["idepacc"]),
                                            "paridepacc");
                    return bf.getEpAccYearById(paridepacc);
                }
            }

            if (rDetail.Table.TableName == "mandatedetail") {
                if (nphase == 2) {
                    return bf.getEpExpYearById(rDetail["idepexp"]);
                }
                else {
                    var idrel = BudgetFunction.GetIdForDocument(rDetail);
                    DataRow rParEpExp = bf.getEpExpRow(idrel, 1);
                    object paridepexp = rParEpExp?["idepexp"] ??
                                        Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", rDetail["idepexp"]),
                                            "paridepexp");
                    return bf.getEpExpYearById(paridepexp);
                }
            }

            return null;
        }

        void ripristinaMovimento(BudgetFunction bf, DataRow rDetail, int nphase) {
            if (rDetail.Table.TableName == "estimatedetail") {
                if (nphase == 2) {
                    bf.RemoveEpAcc(rDetail["idepacc"]);
                }
                else {
                    var idrel = BudgetFunction.GetIdForDocument(rDetail);
                    DataRow rParEpacc = bf.getEpAccRow(idrel, 1);
                    object paridepacc = rParEpacc?["idepacc"] ??
                                        Conn.DO_READ_VALUE("epacc", QHS.CmpEq("idepacc", rDetail["idepacc"]),
                                            "paridepacc");
                    bf.RemoveEpAcc(paridepacc);
                }
            }

            if (rDetail.Table.TableName == "mandatedetail") {
                if (nphase == 2) {
                    bf.RemoveEpExp(rDetail["idepexp"]);
                }
                else {
                    var idrel = BudgetFunction.GetIdForDocument(rDetail);
                    DataRow rParEpExp = bf.getEpExpRow(idrel, 1);
                    object paridepexp = rParEpExp?["idepexp"] ??
                                        Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", rDetail["idepexp"]),
                                            "paridepexp");
                    bf.RemoveEpExp(paridepexp);
                }
            }
        }

        bool causaleCosto(object idaccmotiveannulment) {
            if (idaccmotiveannulment == DBNull.Value) return false;
            DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveannulment);
            if (rEntries.Length != 1) return false;
            object idContoAnnullo = rEntries[0]["idacc"];
            if (!isBudgetEnabled(idContoAnnullo)) return false;
            return EP.isCosto(idContoAnnullo);

        }

        bool generaAccertamentiContrattoAttivoUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            object doc = "C.A." +
                         curr["idestimkind"] + "/" +
                         curr["yestim"].ToString().Substring(2, 2) + "/" +
                         curr["nestim"].ToString().PadLeft(6, '0');

            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);
            string fAyear = QHS.CmpEq("ayear", esercizio);
            DataTable estimDet = DS.Tables["estimatedetail"];

            bool somethingfound = false;
            string filterMainCurrent = QHC.CmpKey(curr);
            DateTime primoGennaio = new DateTime(esercizio, 1, 1);
            DateTime trentunoDic = new DateTime(esercizio, 12, 31);

            int yestim = CfgFn.GetNoNullInt32(curr["yestim"]);


            //if (yestim == esercizio) {
            //Non ricalcola i dettagli inseriti in anni successivi (non saranno neanche considerati nei cicli successivi)
            string filterToRemove = QHC.AppAnd(filterMainCurrent, QHC.CmpGt("start", trentunoDic));
            foreach (DataRow rDettaglio in estimDet.Select(filterToRemove)) {
                if (rDettaglio["idupb"] == DBNull.Value) continue;
                string idaccmotive = rDettaglio["idaccmotive"].ToString();
                if (idaccmotive == "") continue;
                if (rDettaglio["idepacc"] == DBNull.Value) continue;
                if (movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr)) continue;
                ripristinaMovimento(bf, rDettaglio, nphase);

                //bisognerà poi nel proseguio del metodo stare attenti a non creare roba su questi dettagli
            }

            //}

            string idrelated_estimate = BudgetFunction.GetIdForDocument(curr).ToLower();
            // correzione/allineamento accertamenti
            if (yestim < esercizio) {
                //Non modifica gli acc. di budget per dettagli precedenti a quest'anno --> 2020: questa affermazione continua ad essere valida però la data da considerare
                //  non è quella del dettaglio, ma dipende sia dalla data inizio che dalla data fine.
                //  se è un dettaglio annullato ed ha un elemento successivo, la data fine è da considerare (in cui è creato l'accertamento di variazione)
                //  se è un dettaglio annullato e NON ha un elemento successivo  la data fine NON è da considerare
                //  se è un ha un elemento precedente, allora avrà data inizio, ed è quella da considerare per l'accertamento 
                //  se è un dettaglio non annullato che NON ha un elemento precedente allora va considerata la sua data o la data del contratto
                //    questi ultimi due casi si possono fondere considerando la data inizio o contratto per i dettagli non annullati senza precedenti 

                //considera solo dettagli di anni precedenti
                //NO, sbagliato: anche quello di esercizio corrente ma che ha elemento precedente, infatti in quel caso l'accertamento
                //  è stato fatto in data di anno precedente se il dettaglio  corrente è subentrato in una sostituzione
                foreach (DataRow rDettaglio in estimDet.Select(filterMainCurrent)) {
                    if (rDettaglio["idupb"] == DBNull.Value) continue;
                    var idrel = BudgetFunction.GetIdForDocument(rDettaglio);
                    string idaccmotive = rDettaglio["idaccmotive"].ToString();
                    if (idaccmotive == "") continue;
                    if (rDettaglio["idepacc"] == DBNull.Value) continue; //non c'è nulla da azzerare 

                    if (rDettaglio["stop"] != DBNull.Value) {
                        //Scollega i dettagli annullati collegati ad accertamenti incoerenti
                        //if (((DateTime)rDettaglio["stop"]).Year == esercizio) {
                        object idrelated_linked = Conn.DO_READ_VALUE("epacc",
                            QHS.CmpEq("idepacc", rDettaglio["idepacc"]), "idrelated");
                        if (idrelated_linked == null) idrelated_linked = "";
                        // Se l'accertamento collegato ha un id incoerente con quelli di questo dettaglio, 
                        if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_estimate) &&
                            idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                            //Nino 8/7/2000 task 15055 Non ripristina questo accertamento perchè è relativo all'altro dettaglio
                            //var imp = bf.getEpAccRow(idrelated_linked, nphase);
                            //imp["idrelated"] = idrel;
                            //bf.setEpAccRow(idrelated_linked.ToString(), nphase, null);
                            //bf.setEpAccRow(idrel, nphase, imp);

                            //visto che non è il suo, lo dissocia. Se scatteranno delle regole correggeremo i dati a mano
                            rDettaglio["idepacc"] = DBNull.Value;
                            //24/9 c'è stato un momento in cui questi erano elaborati per spostare tali accertamenti sul dettaglio di annullo, 
                            //  ora questo non accade più quindi possiamo dissociare tranquillamente tali dettagli se incoerenti. 
                            // Per come funzionava prima la sostituzione, il dettaglio annullato conservava sempre l'id dell'accertamento del dettaglio originale
                            //   ora questo non accade più, e al dettaglio annullato è associato un nuovo accertamento di tipo variazione

                            //Visto che l'accertamento NON è il suo, non gli compete stabilire se azzerarlo o meno, continuiamo lasciando le cose come stanno
                            continue;
                        }

                        //}
                    }
                    //ripristina tutti i movimenti di budget che per motivi interni aveva preliminarmente azzerato e di cui non deve generare movimentazione

                    bool toConsider = movimentoDiTipoVariazione_1(rDettaglio, curr) ||
                                      movimentoDiTipoVariazionePerRateo(rDettaglio, curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr) ||
                                      variazionemovimentoDettaglioContrattoDaGenerare_3(rDettaglio, curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerareComeModificaPropria(rDettaglio,
                                          curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerareComeModificaSuccessivo(rDettaglio,
                                          curr); //dovrebbe azzerare il movimento eventualmente presente qui
                    // perchè non dovrebbe manco esistere

                    //inserire qui altri possibili motivi per rigenerare il movimento

                    if (toConsider) continue;
                    //Se passa di qui ha data inizio di anni precedenti, NON va intaccata col meccanismo automatico di rigenerazione

                    ripristinaMovimento(bf, rDettaglio, nphase);


                    //Se non ha data fine ed inizia prima dell'anno in corso, non lo considera  --- LO RIPRISTINA, perchè di base parte azzerato



                }
            }

            // Contratto non collegabile a fattura --> scritture abilitate
            bool scrittureAbilitate = isEstimKindEpEnabled(curr["idestimkind"]);
            bool collegabileAFattura = !scrittureAbilitate;
            //Si occupa degli ANNULLAMENTI dei dettagli o simili, effettuati quest'anno
            //Dobbiamo distinguere due casi:

            //1 : non esiste un dettaglio consecutivo
            //  se collegabile deve generare una variazione di annullo  ( a prescindere da anno annullo = anno origine) (ignorando la causale di annullo)
            //  se non collegabile:
            //      se anno origine = anno annullo deve variare il movimento portandolo a zero  (ignorando la causale di annullo)
            //		se anno origine < anno annullo deve generare un accertamento di variazione o un impegno di budget
            //   
            //2 : esiste un dettaglio consecutivo 
            //  se il dettaglio non è collegabile a fattura
            //		deve creare un ACCERTAMENTO di tipo variazione pari alla differenza tra questo dettaglio (es. 100) ed il successivo (es. 80), es. 20
            //		oppure un impegno se la causale è di costo (sempre pari alla differenza..)
            //  se il dettaglio è collegabile a fattura, deve:
            //		se il prossimo dettaglio è annullato nello stesso anno, non deve fare nulla
            //		se il prossimo dettaglio non è annullato o annullato in anni successivi, deve adeguare l'importo all'importo del prossimo dettaglio,
            //          ossia implicitamente genererà una variazione per la differenza


            foreach (DataRow rDettaglio in estimDet.Select(filterMainCurrent)) { //, QHC.IsNotNull("stop")
                bool annullaConVariazione =
                    variazioneAnnulloOAResiduoDaGenerare_5(rDettaglio,
                        curr); //attenzione qui dobbiamo distinguere se "a zero" o "al disponibile"
                bool annullaConMovimentoDiTipoVariazione = movimentoDiTipoVariazione_1(rDettaglio, curr);
                bool annullaConMovimentoDiTipoVariazioneRateo = movimentoDiTipoVariazionePerRateo(rDettaglio, curr);
                bool generaVariazioneSuMovimentoPerSostituzione = variazioneSuMovimento_4(rDettaglio, curr);
                bool annulloDaGenerare = annulloGenericoDaGenerare(rDettaglio, curr);
                bool modificaDaGenerare =
                    movimentoCreazioneDettaglioContrattoDaGenerareComeModificaSuccessivo(rDettaglio, curr);
                if (!(annullaConVariazione | annullaConMovimentoDiTipoVariazione |
                      generaVariazioneSuMovimentoPerSostituzione | annulloDaGenerare | modificaDaGenerare |
                      annullaConMovimentoDiTipoVariazioneRateo)) continue;

                //Considera solo i dettagli annullati nell'anno corrente
                int yearCurrentStop = ((DateTime) rDettaglio["stop"]).Year;
                if (yearCurrentStop != esercizio) continue;

                object epkind = rDettaglio["epkind"];


                DataRow nextRow = getNextRow(rDettaglio);
                DataRow prevRow = getPrevRow(rDettaglio);
                DataRow firstRow = getFirstRow(rDettaglio);
                DataRow lastRow = getLastRow(rDettaglio);

                //Anno iniziale 
                DateTime realStart = (DateTime) (firstRow["start"] == DBNull.Value ? curr["adate"] : firstRow["start"]);
                int annoOrigine = realStart.Year;

                DateTime currStart =
                    (DateTime) (rDettaglio["start"] == DBNull.Value ? curr["adate"] : rDettaglio["start"]);
                int annoDettaglioCorrente = currStart.Year;

                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);


                //Salta i dettagli annullati collegati ad accertamenti di budget poi passati ad altri dettagli (ambo i casi)
                // questa situazione l'abbiamo esclusa prima, commento il codice
                //if (rDettaglio["idepacc"] != DBNull.Value) {
                //	object idrelated_linked = Conn.DO_READ_VALUE("epacc", QHS.CmpEq("idepacc", rDettaglio["idepacc"]),
                //		"idrelated");
                //	if (idrelated_linked == null) idrelated_linked = "";
                //	if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_estimate) &&
                //	    idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                //		rDettaglio["idepacc"] = DBNull.Value; //questo impegno appartiene all'altro dettaglio
                //	}
                //}

                //Se le scritture sono differite occorre che start sia valorizzato per effettuare le scritture, se questo non c'è allora 
                //  nemmeno l'annullamento deve agire
                bool scrittureDifferite = false;
                if (estimDet.Columns.Contains("flag")) {
                    scrittureDifferite = (CfgFn.GetNoNullInt32(rDettaglio["flag"]) & 1) != 0;
                }

                if (rDettaglio["start"] == DBNull.Value && scrittureDifferite)
                    continue; //va bene anche per i dett. sostituiti

                if (rDettaglio["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                //13718  Se l'esercizio di annullo coincide con quello del contratto, deve essere ignorata la causale di annullo, anche se è valorizzata.


                if (annullaConVariazione) { //stop dell'anno e  anno originale=esercizio
                    DataRow rEpAcc = bf.getEpAccRow(BudgetFunction.GetIdForDocument(rDettaglio), nphase);
                    if (rEpAcc != null) {
                        var ry = bf.getEpAccYearById(rEpAcc["idepacc"]);
                        var pagato = bf.getPagatoAnniPrecedenti(true, rEpAcc, ry);
                        if (annoOrigine < esercizio) {
                            ripristinaMovimento(bf, rDettaglio, nphase);
                        }

                        if (rateoOFatturaARicevere(rDettaglio)) {
                            ry["amount"] = pagato[0];
                            for (int i = 2; i <= 5; i++) {
                                ry[$"amount{i}"] = pagato[i - 1];
                            }
                        }
                        else {
                            annullaAccertamentoEP(bf, rDettaglio, rEpAcc["idepacc"]);
                        }
                    }

                    somethingfound = true;
                    if (!rateoOFatturaARicevere(rDettaglio)) continue;
                }

                //Stiamo ora considerando accertamenti di anni precedenti 
                object idaccmotiveannulment = rDettaglio["idaccmotiveannulment"];
                string whichDet = rDettaglio["detaildescription"].ToString();



                if (modificaDaGenerare) {
                    DataRow exEpAcc = getEpMovYear(bf, lastRow, nphase);

                    if (exEpAcc != null) {
                        //modifica l'importo del movimento
                        if (rateo(rDettaglio)) {
                            decimal newValue = getTotaleImponibile(curr, lastRow);
                            //exEpAcc["amount"]= newValue;

                            exEpAcc.RejectChanges();
                            var diff = newValue - CfgFn.GetNoNullDecimal(exEpAcc["amount"]);
                            for (int i = 2; i <= 5; i++)
                                diff -= CfgFn.GetNoNullDecimal(exEpAcc["amount" + i.ToString()]);
                            diff = -diff;
                            if (diff > 0) {
                                decimal oldvalue;

                                for (int i = 5; i > 1; i--) {
                                    if (diff > 0) {
                                        oldvalue = CfgFn.GetNoNullDecimal(exEpAcc["amount" + i.ToString()]);
                                        if (oldvalue >= diff) {
                                            exEpAcc["amount" + i.ToString()] = oldvalue - diff;
                                            diff = 0;
                                        }
                                        else {
                                            exEpAcc["amount" + i.ToString()] = 0;
                                            diff -= oldvalue;
                                        }
                                    }
                                }

                                oldvalue = CfgFn.GetNoNullDecimal(exEpAcc["amount"]);
                                exEpAcc["amount"] = oldvalue - diff;
                                //if (diff > 0) {
                                //	if (oldvalue >= diff) {
                                //		exEpAcc["amount"] = oldvalue - diff;
                                //		diff = 0;
                                //	} else {
                                //		exEpAcc["amount"] = 0;
                                //		diff -= oldvalue;
                                //	}
                                //}


                            }
                            else {
                                exEpAcc["amount"] = CfgFn.GetNoNullDecimal(exEpAcc["amount"]) - diff;
                            }



                            //exEpAcc["amount"] = CfgFn.GetNoNullDecimal(exEpAcc["amount"]) + getTotaleImponibile(curr, lastRow) - getTotaleImponibile(curr, rDettaglio);
                        }
                        else {
                            exEpAcc["amount"] = getTotaleImponibile(curr, lastRow);
                        }

                        somethingfound = true;
                        continue;

                    }
                }

                //  i contratti NON collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli collegabili
                //  scritture abilitate = contratti non collegabili
                //  scritture abilitate== false =>> contratti collegabili, deve accomunare anche il caso dei rati o fatt.ric
                // se trova invece
                if (nextRow == null && (scrittureAbilitate == false && !rateoOFatturaARicevere(rDettaglio))) {
                    //considera casi normali e non sostituzioni
                    //collegabile a fattura, non sostituisce altro dettaglio
                    if (idaccmotiveannulment != DBNull.Value) {
                        //se ha causale di annullo
                        ShowMessage(
                            $"Attenzione, il dettaglio {whichDet} non dovrebbe avere la causale di annullo.",
                            "Errore");
                        continue;
                    }


                    //Se collegabile a fattura  e NON c'è causale di annullo, annulla l'accertamento (come se fosse stato dell'anno)
                    DataRow rEpAcc = bf.getEpAccRow(BudgetFunction.GetIdForDocument(rDettaglio), nphase);
                    if (rEpAcc != null) {
                        annullaAccertamentoEP(bf, rDettaglio, rEpAcc["idepacc"]);
                    }

                    somethingfound = true;
                    continue;
                }

                //Stiamo ora considerando accertamenti di anni precedenti con scritture abilitate
                if ((!scrittureAbilitate) && annoOrigine == esercizio && idaccmotiveannulment != DBNull.Value &&
                    nextRow != null) { //collegabile a fattura e con causale di annullo  //era 
                    ShowMessage(
                        $"Attenzione, il dettaglio {rDettaglio["detaildescription"]} non dovrebbe avere la causale di annullo.",
                        "Errore");
                    continue;
                }

                //Se non ha causale di annullo ed ha successore prende la causale del prossimo dettaglio
                if (nextRow != null && idaccmotiveannulment == DBNull.Value) {
                    idaccmotiveannulment = nextRow["idaccmotive"];
                    whichDet = nextRow["detaildescription"].ToString();
                }

                if (idaccmotiveannulment == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {whichDet} non ha la causale di annullo",
                        "Errore");
                    continue;
                }

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveannulment);
                if (rEntries.Length != 1) {
                    ShowMessage(
                        $"La causale di annullo del dettaglio {whichDet} non è ben configurata.",
                        "Errore");
                    return false;
                }

                object idContoAnnullo = rEntries[0]["idacc"];


                if (!isBudgetEnabled(idContoAnnullo)) continue;
                var amount = getTotaleImponibile(curr, rDettaglio);

                if (nextRow != null &&
                    (generaVariazioneSuMovimentoPerSostituzione || annullaConMovimentoDiTipoVariazione)) {
                    //Dall'importo di questo dettaglio sottraiamo il valore del dettaglio che rimane in vita 


                    if (annoDettaglioCorrente >= minimoAnnoImpegniDiBudget) {
                        amount -= getTotaleImponibile(curr, nextRow);
                    }
                    else { // Il contratto è di anni precedenti quando ancora non esisteva il budget: manca quindi 
                        // il movimento di budget sul dettaglio contratto che stiamo sostituendo. Dobbiamo creare un movimento di budget
                        // pari all'importo del dettaglio nuovo, che sostituisce il dettaglio corrente e lo dobbiamo associare al nuovo
                        amount = getTotaleImponibile(curr, nextRow);
                        if (dettaglioContrattoInseritoinFattura(nextRow)) {
                            // In questo caso invece posticipiamo la creazione del movimento di budget al momento dell'inserimento in fattura.
                            // Abbiamo già iniziato a generare i movimenti di budget sulla fattura, 
                            // dobbiamo continuare sulla fattura anche se  stiamo sostituendo questo dettaglio. Pertanto metto a zero l'importo
                            amount = 0;
                        }

                    }

                }
                //Non tocca gli accertamenti di questo dettaglio annullato di cui sta generando l'impegno di budget


                // CINZIA dice che non deve scattare mai 5/10/2020
                //if ((nextRow == null) && EP.isRicavo(idContoAnnullo)) {
                //	ShowMessage(
                //		$"La causale di annullo del dettaglio {rDettaglio["detaildescription"]} non non può essere di ricavo.",
                //		"Errore");
                //	somethingfound = true;
                //	continue;
                //	//se  c'è la riga successiva, è ammesso avere una causale di annullo di ricavo, sarà generato un accertamento di budget di tipo variazione
                //}

                var idregToConsider = curr["idreg"];
                if (idregToConsider == DBNull.Value) idregToConsider = rDettaglio["idreg"];

                if (EP.isCosto(idContoAnnullo) && movimentoOppostoDaGenerare(rDettaglio, curr)) {
                    if (!rateoOFatturaARicevere(rDettaglio)) {
                        ripristinaMovimento(bf, rDettaglio, nphase);
                    }

                    if (rateoOFatturaARicevere(rDettaglio) && nextRow == null) { // importo come da scrittura
                        amount = -CfgFn.GetNoNullDecimal(
                            Conn.readValue("entrydetail",
                                q.lt("amount", 0) & getFilterDetailForRateo(rDettaglio,
                                                      "idepacc") // q.eq("idepacc", getLastRow(rDettaglio)["idepacc"]) 
                                                  & q.eq("idacc",
                                                      rateo(rDettaglio) ? _idrateo_attivo : _idaccInvoicetoemit),
                                "sum(amount)"));
                        if (amount == 0) {
                            ShowMessage(
                                $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rDettaglio["detaildescription"]} perchè marcato come fattura da emettere");
                            continue;
                        }
                    }

                    if (amount == 0) continue;
                    var currEpExp = bf.addEpExp(idregToConsider, curr["idman"], amount,
                        rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                        idContoAnnullo, rDettaglio["idupb"], idrel, doc, curr["adate"],
                        DBNull.Value, DBNull.Value, //rDettaglio["competencystart"], rDettaglio["competencystop"],
                        nphase, getIdEpExpByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                    if (currEpExp == null) return false;
                    addImpegnoToDict(currEpExp, idrel);

                    if (nphase == 2) {
                        _listaImpegni[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpExp;
                    }
                }
                else {
                    //se generaVariazioneSuMovimentoPerSostituzione l'accertamento da considerare è il "last" e idem idrel, 
                    //  quindi non è di tipo sostituzione

                    //L'importo dell'accertamento variazione è pari alla differenza tra quello sostituito (ossia curr) ed il sostituente (che è nextRow)
                    if (generaVariazioneSuMovimentoPerSostituzione) {
                        if (amount == 0) continue;
                        var idrelToUse = BudgetFunction.GetIdForDocument(lastRow);
                        var currEpacc = bf.addEpAcc(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpAccByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        addAccertamentoToDict(currEpacc, idrelToUse);


                        if (nphase == 2) {

                            if (annoDettaglioCorrente < minimoAnnoImpegniDiBudget) {
                                _listaAccertamenti[CfgFn.GetNoNullInt32(nextRow["rownum"])] = currEpacc;
                            }
                            else {
                                _listaAccertamenti[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpacc;
                            }
                        }

                    }

                    if (annullaConMovimentoDiTipoVariazione) {
                        if (amount == 0) continue;
                        var idrelToUse = idrel;
                        var currEpacc = bf.addEpAcc(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpAccByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        currEpacc["flagvariation"] = "S";
                        addAccertamentoToDict(currEpacc, idrelToUse);

                        if (nphase == 2) {
                            _listaAccertamenti[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpacc;
                        }
                    }

                    if (annullaConMovimentoDiTipoVariazioneRateo) {
                        amount = -CfgFn.GetNoNullDecimal(
                            Conn.readValue("entrydetail",
                                q.lt("amount", 0) & q.eq("idepacc", getLastRow(rDettaglio)["idepacc"])
                                                  & q.eq("idacc",
                                                      rateo(rDettaglio) ? _idrateo_attivo : _idaccInvoicetoemit),
                                "sum(amount)"));
                        if (amount == 0) {
                            ShowMessage(
                                $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rDettaglio["detaildescription"]} perchè marcato come fattura da emettere");
                            continue;
                        }

                        var idrelToUse = idrel;
                        var currEpacc = bf.addEpAcc(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpAccByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        currEpacc["flagvariation"] = "S";
                        addAccertamentoToDict(currEpacc, idrelToUse);

                        if (nphase == 2) {
                            _listaAccertamenti[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpacc;
                        }
                    }
                }

                somethingfound = true;
                continue;

            }


            //Considera gli accertamenti DA CREARE
            //Agisce su dettagli "attivi" da quest'anno, non agisce sui dettagli annullati o cancellati però
            //Si occupa della parte "attiva" ossia della creazione dei movimenti di budget
            foreach (DataRow rDettaglio in estimDet.Select(filterMainCurrent)) {
                //Condizione: (2) anno origine di questo esercizio e non c'è successivo
                if (!movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr)) continue;
                // Nei dettagli "attivi" deve considerare anche, come imponibile,iva e iva indetr., gli importi dei dettagli che lo annullano, nell'anno di origine in cui genera le scritture, per non generare casini

                object parentIdEpAcc = DBNull.Value;
                if (rDettaglio.Table.Columns.Contains("idepacc_pre")) parentIdEpAcc = rDettaglio["idepacc_pre"];

                if (nphase == 1 && parentIdEpAcc != DBNull.Value) continue;

                object epkind = rDettaglio["epkind"];

                bool scrittureDifferite = false;
                if (estimDet.Columns.Contains("flag")) {
                    scrittureDifferite = (CfgFn.GetNoNullInt32(rDettaglio["flag"]) & 1) != 0;
                }

                //Se le scritture sono differite occorre che start sia valorizzato per effettuare le scritture o gli accertamenti
                if (rDettaglio["start"] == DBNull.Value && scrittureDifferite) continue;

                DataRow firstRow = getFirstRow(rDettaglio);
                DateTime dataOriginale = firstRow["start"] == DBNull.Value
                    ? (DateTime) curr["adate"]
                    : (DateTime) firstRow["start"];

                if (firstRow["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                string idaccmotive = firstRow["idaccmotive"].ToString();
                if (idaccmotive == "") {
                    ShowMessage("Causale non configurata bene per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                int ayearOriginale = ((DateTime) dataOriginale).Year;


                if (ayearOriginale < esercizio) dataOriginale = primoGennaio;
                DataRow prevRow = getPrevRow(rDettaglio);
                DataRow nextRow = getNextRow(rDettaglio);

                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);

                int yearStartAccertamenti = dataOriginale.Year;


                if (prevRow != null && ayearOriginale < esercizio) {
                    //Ha già movimento di budget, che non va toccato. La variazione sarà stata fatta dal dettaglio precedente (fase di annullamento)
                    //Quindi non tocca questo accertamento di budget
                    if (rDettaglio["idepacc"] == DBNull.Value) continue;
                    bf.RemoveEpAcc(rDettaglio["idepacc"]);
                    object paridepacc = Conn.DO_READ_VALUE("epacc", QHS.CmpEq("idepacc", rDettaglio["idepacc"]),
                        "paridepacc");
                    bf.RemoveEpAcc(paridepacc);
                    continue;
                }

                if (nextRow != null) {
                    //solo l'ultima riga (che poi è la prima inserita in ordine di tempo) genera gli accertamenti in creazione
                    //se ha riga successiva, allora il movimento sta nel successivo, e questo genera solo l'accertamento di variazione (in fase di annullamento)
                    continue;
                }


                //Scollega l'accertamento di budget sulle incoerenze
                //Salta i dettagli annullati collegati a accertamenti di budget poi passati ad altri dettagli (questa parte credo sia comune)
                if (rDettaglio["idepacc"] != DBNull.Value) {
                    object idrelated_linked = getIdRelatedByEpAcc(bf, rDettaglio["idepacc"]);
                    if (idrelated_linked == null) idrelated_linked = "";

                    if (scrittureAbilitate || rateoOFatturaARicevere(rDettaglio)) { //qui non siamo in fase di annullo
                        if (yearStartAccertamenti < esercizio) {
                            var acc = bf.getEpAccRow(idrelated_linked, nphase);
                            acc["idrelated"] = idrel; //corregge l'idrelated dell'accertamento di budget
                            bf.setEpAccRow(idrelated_linked.ToString(), nphase, null);
                            bf.setEpAccRow(idrel, nphase, acc);
                            addAccertamentoToDict(acc, idrel);
                            removeAccertamentoFromDict(nphase,
                                idrelated_linked.ToString()); //rimuove il vecchio idrelated dal dizionario
                            //idrelatedDIAltroDettaglio = true;
                        }
                        else {
                            if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_estimate) &&
                                idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                                rDettaglio["idepacc"] =
                                    DBNull.Value; //scollega l'acc. di budget da questo dettaglio, non è il suo
                            }
                        }
                    }
                    else {
                        //in origine faceva sempre e solo questo al posto di if (scrittureAbilitate && nextRow==null) {
                        if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_estimate) &&
                            idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                            rDettaglio["idepacc"] =
                                DBNull.Value; //scollega l'acc. di budget da questo dettaglio, non è il suo
                        }

                        // passando di qui implicitamente azzera il movimento di budget
                        //rDettaglio["idepacc"] = DBNull.Value;
                        //continue; //Non generare un nuovo movimento di budget su questo dettaglio, che è annullato
                    }
                }

                somethingfound = true;

                var rowToConsider = firstRow;
                while (getNextRow(rowToConsider) != null) {
                    var nextR = getNextRow(rowToConsider);
                    var startR = (DateTime) nextR["start"];
                    if (startR.Year != esercizio) break;
                    rowToConsider = nextR;
                }


                //La creazione va fatta sull'ultimo dettaglio della catena con i dati dell'ULTIMO dettaglio della catena presente NEL PRIMO ANNO
                decimal amount = getTotaleImponibile(curr, rowToConsider);
                if (amount == 0) continue;

                var idacc = getIdAccForDocument(rDettaglio, DBNull.Value); //Non accede al conto speciale
                if (idacc == null || idacc == DBNull.Value) {
                    ShowMessage("Causale non configurata bene per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                if (!isBudgetEnabled(idacc)) continue;

                if (parentIdEpAcc == DBNull.Value) {
                    parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);
                }

                var idregToConsider = curr["idreg"];
                if (idregToConsider == DBNull.Value) idregToConsider = rDettaglio["idreg"];

                //Imposta l'accertamento di budget relativo al dettaglio, tutti i dati sono presi dal dettaglio originale
                var currEpAcc = bf.addEpAcc(idregToConsider, curr["idman"], amount,
                    firstRow["detaildescription"], dataOriginale,
                    idacc, firstRow["idupb"], idrel, doc, curr["adate"],
                    firstRow["competencystart"], firstRow["competencystop"], nphase, parentIdEpAcc, idaccmotive);

                if (currEpAcc == null) return false;
                addAccertamentoToDict(currEpAcc, idrel);


                if (nphase == 2 && currEpAcc != null) {
                    _listaAccertamenti[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpAcc;
                }
            }


            foreach (DataRow rDettaglio in estimDet.Select(QHC.AppAnd(filterMainCurrent, QHC.IsNotNull("start")))) {
                if (rDettaglio.RowState == DataRowState.Added) continue;
                bool scrittureDifferite = false;
                if (estimDet.Columns.Contains("flag")) {
                    scrittureDifferite = (CfgFn.GetNoNullInt32(rDettaglio["flag"]) & 1) != 0;
                }

                //Se le scritture sono differite e non c'è data inizio, non generare neanche l'accertamento
                if (rDettaglio["start"] == DBNull.Value && scrittureDifferite) continue;

                if (rDettaglio["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                if (rDettaglio["stop"] != DBNull.Value) {
                    int yearCurrentStop = ((DateTime) rDettaglio["stop"]).Year;
                    if (yearCurrentStop == esercizio) continue; //già annullato dal ciclo precedente
                }

                int yearCurrentStart = ((DateTime) rDettaglio["start"]).Year;
                if (yearCurrentStart > esercizio) {
                    //stiamo mettendo la data inizio ad un dettaglio ma con esercizio diverso da questo esercizio
                    // ossia è una azione manuale dell'utente
                    //annullaAccertamentoEP(bf, rDettaglio);
                    somethingfound = true;
                }
            }

            if (!somethingfound) {
                var obj = (nphase == 1) ? "preaccertamento" : "accertamento";
                if (!silent) {
                    ShowMessage(
                        "Nessun dettaglio di competenza dell'anno ha la causale EP quindi nessun " + obj +
                        " è stato generato.",
                        "Avviso", false);
                }

                return true;
            }



            return true;
        }



        private void annullaImpegnoEP(BudgetFunction bf, DataRow rDettaglio, object idepexp,
            decimal importoVariazione = 0) {
            DataRowVersion toConsider = DataRowVersion.Current;
            if (rDettaglio.RowState == DataRowState.Deleted) {
                toConsider = DataRowVersion.Original;
            }

            string what = "Annullamento o sostituzione o cancellazione";
            what = what + " dett. contratto passivo " +
                   rDettaglio["idmankind", toConsider] + "/" +
                   rDettaglio["yman", toConsider] + "/" +
                   rDettaglio["nman", toConsider];
            //object idepexp = rDettaglio["idepexp", toConsider];
            DataTable TEpExp = Conn.RUN_SELECT("epexpview", "idepexp", null,
                QHS.AppAnd(QHS.CmpEq("idepexp", idepexp), QHS.CmpEq("ayear", esercizio)), null, false);


            if (TEpExp.Rows.Count == 0) {
                //Deve creare un nuovo impegno di budget (potrebbe aver cambiato l'idacc o idupb??)
                //questo caso lo demandiamo all'afterpost, che opererà in modo generico sui totali

                string filterEpExpYear = QHC.AppAnd(QHC.CmpEq("idepexp", idepexp), QHC.CmpEq("ayear", esercizio));
                DataRow[] arrExpYearEsistente = bf?.D.Tables["epexpyear"].Select(filterEpExpYear);
                var accYear = arrExpYearEsistente[0];
                decimal[] amount = new decimal[5];
                if (importoVariazione == 0) {
                    amount[0] = -CfgFn.GetNoNullDecimal(accYear["amount"]);
                    amount[1] = -CfgFn.GetNoNullDecimal(accYear["amount2"]);
                    amount[2] = -CfgFn.GetNoNullDecimal(accYear["amount3"]);
                    amount[3] = -CfgFn.GetNoNullDecimal(accYear["amount4"]);
                    amount[4] = -CfgFn.GetNoNullDecimal(accYear["amount5"]);
                }
                else {
                    decimal nonPagato = importoVariazione;
                    //eventualmente valutare altra strategia di azzeramento
                    for (int i = 0; i < 5; i++) {
                        if (amount[i] >= nonPagato) {
                            amount[i] -= nonPagato;
                            nonPagato = 0;
                            break;
                        }
                        else {
                            nonPagato -= amount[i];
                            amount[i] = 0;
                        }
                    }
                }

                if (amount[0] != 0 || amount[1] != 0 || amount[2] != 0 || amount[3] != 0 || amount[4] != 0) {
                    DateTime data = (DateTime) meta.GetSys("datacontabile");
                    if (rDettaglio.RowState != DataRowState.Deleted && (rDettaglio["stop"] != DBNull.Value)) {
                        data = (DateTime) rDettaglio["stop"];
                    }

                    bf.addEpExpVar(idepexp, what, data, amount);
                }

                return;
            }
            else {
                // vedo se esiste una variazione su quell'idepexp e descrizione, se non c'è la crea
                DataTable epexptot = Conn.RUN_SELECT("epexptotal", "*", null,
                    QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idepexp", idepexp)), null, false);
                if (epexptot.Rows.Count > 0) {
                    DataRow r = epexptot.Rows[0];
                    DateTime data = (DateTime) meta.GetSys("datacontabile");
                    if (rDettaglio.RowState != DataRowState.Deleted && (rDettaglio["stop"] != DBNull.Value)) {
                        data = (DateTime) rDettaglio["stop"];
                    }

                    decimal[] amount = new decimal[5];
                    amount[0] = -CfgFn.GetNoNullDecimal(r["curramount"]);
                    amount[1] = -CfgFn.GetNoNullDecimal(r["curramount2"]);
                    amount[2] = -CfgFn.GetNoNullDecimal(r["curramount3"]);
                    amount[3] = -CfgFn.GetNoNullDecimal(r["curramount4"]);
                    amount[4] = -CfgFn.GetNoNullDecimal(r["curramount5"]);
                    if (amount[0] != 0 || amount[1] != 0 || amount[2] != 0 || amount[3] != 0 || amount[4] != 0) {
                        bf.addEpExpVar(idepexp, what, data, amount);
                    }


                    string filterEpExpYear = QHC.AppAnd(QHC.CmpEq("idepexp", idepexp), QHC.CmpEq("ayear", esercizio));
                    DataRow[] arrAccYearEsistente = bf.D.Tables["epexpyear"].Select(filterEpExpYear);
                    if (arrAccYearEsistente.Length > 0) {
                        var accYear = arrAccYearEsistente[0];
                        accYear["amount"] = 0;
                        accYear["amount2"] = 0;
                        accYear["amount3"] = 0;
                        accYear["amount4"] = 0;
                        accYear["amount5"] = 0;
                    }

                }
            }
        }




        private void annullaAccertamentoEP(BudgetFunction bf, DataRow rDettaglio, object idepacc) {
            DataRowVersion toConsider = DataRowVersion.Current;
            if (rDettaglio.RowState == DataRowState.Deleted) {
                toConsider = DataRowVersion.Original;
            }

            //object idepacc = rDettaglio["idepacc", toConsider];
            DataTable TEpExp = Conn.RUN_SELECT("epaccview", "idepacc", null,
                QHS.AppAnd(QHS.CmpEq("idepacc", idepacc), QHS.CmpEq("ayear", esercizio)), null, false);

            string what = "Annullamento o sostituzione o cancellazione ";
            what = what + " dett. contratto attivo " +
                   rDettaglio["idestimkind", toConsider] + "/" +
                   rDettaglio["yestim", toConsider] + "/" +
                   rDettaglio["nestim", toConsider];

            if (TEpExp.Rows.Count == 0) {
                //Deve creare un nuovo impegno di budget (potrebbe aver cambiato l'idacc o idupb??)
                //questo caso lo demandiamo all'afterpost, che opererà in modo generico sui totali
                string filterEpAccYear = QHC.AppAnd(QHC.CmpEq("idepacc", idepacc), QHC.CmpEq("ayear", esercizio));
                DataRow[] arrAccYearEsistente = bf.D.Tables["epaccyear"].Select(filterEpAccYear);
                if (arrAccYearEsistente.Length > 0) {
                    var accYear = arrAccYearEsistente[0];
                    decimal[] amount = new decimal[5];
                    amount[0] = -CfgFn.GetNoNullDecimal(accYear["amount"]);
                    amount[1] = -CfgFn.GetNoNullDecimal(accYear["amount2"]);
                    amount[2] = -CfgFn.GetNoNullDecimal(accYear["amount3"]);
                    amount[3] = -CfgFn.GetNoNullDecimal(accYear["amount4"]);
                    amount[4] = -CfgFn.GetNoNullDecimal(accYear["amount5"]);
                    if (amount[0] != 0 || amount[1] != 0 || amount[2] != 0 || amount[3] != 0 || amount[4] != 0) {
                        DateTime data = (DateTime) meta.GetSys("datacontabile");
                        if (rDettaglio.RowState != DataRowState.Deleted && (rDettaglio["stop"] != DBNull.Value)) {
                            data = (DateTime) rDettaglio["stop"];
                        }

                        bf.addEpAccVar(idepacc, what, data, amount);
                    }
                }

                return;
            }
            else {
                // vedo se esiste una variazione su quell'idepexp e descrizione, se non c'è la crea                

                DataTable epexptot = Conn.RUN_SELECT("epacctotal", "*", null,
                    QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idepacc", idepacc)), null, false);
                if (epexptot.Rows.Count > 0) {
                    DataRow r = epexptot.Rows[0];
                    decimal[] amount = new decimal[5];
                    amount[0] = -CfgFn.GetNoNullDecimal(r["curramount"]);
                    amount[1] = -CfgFn.GetNoNullDecimal(r["curramount2"]);
                    amount[2] = -CfgFn.GetNoNullDecimal(r["curramount3"]);
                    amount[3] = -CfgFn.GetNoNullDecimal(r["curramount4"]);
                    amount[4] = -CfgFn.GetNoNullDecimal(r["curramount5"]);
                    if (amount[0] != 0 || amount[1] != 0 || amount[2] != 0 || amount[3] != 0 || amount[4] != 0) {
                        DateTime data = (DateTime) meta.GetSys("datacontabile");
                        if (rDettaglio.RowState != DataRowState.Deleted && (rDettaglio["stop"] != DBNull.Value)) {
                            data = (DateTime) rDettaglio["stop"];
                        }

                        bf.addEpAccVar(idepacc, what, data, amount);
                    }

                    string filterEpAccYear = QHC.AppAnd(QHC.CmpEq("idepacc", idepacc), QHC.CmpEq("ayear", esercizio));
                    DataRow[] arrAccYearEsistente = bf.D.Tables["epaccyear"].Select(filterEpAccYear);
                    if (arrAccYearEsistente.Length > 0) {
                        var accYear = arrAccYearEsistente[0];
                        accYear["amount"] = 0;
                        accYear["amount2"] = 0;
                        accYear["amount3"] = 0;
                        accYear["amount4"] = 0;
                        accYear["amount5"] = 0;
                    }
                }
            }
        }

        bool generaImpegniProvisionUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            object doc = "Accantonamento " + curr["description"];
            bool somethingfound = false;
            DataTable details = DS.Tables["provisiondetail"];

            string idaccmotive = curr["idaccmotive"].ToString();
            if (idaccmotive == "") {
                ShowMessage("Causale di costo non configurata bene per l'accantonamento " + curr["description"]);
                return false;
            }

            DataRow[] rEntriesCosto = EP.GetAccMotiveDetails(idaccmotive);

            if (rEntriesCosto.Length != 1) {
                ShowMessage("Causale di costo non configurata bene per l'accantonamento " + curr["description"]);
                return false;
            }

            object idaccCosto = rEntriesCosto[0]["idacc"];

          
            //Considera tutte le righe senza la causale di ricavo, potrebbero avere importo positivo o negativo
            foreach (DataRow rDettaglio in details.Select(QHC.IsNull("idaccmotive"))) {
                //var idrelDetail = BudgetFunction.GetIdForDocument(rDettaglio);
                // questa parte viene spostata nel ciclo sui dettagli in quanto non deve essere possibile generare unico impegno di budget sul fondo
                // devono essere generati più impegni di budget per le variazioni e devono essere singoli
                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);
                var idrelprovision = BudgetFunction.GetIdForDocument(curr);
                object parentIdEpExp = getIdEpExpByIdRelated(idrel, nphase - 1);


                if (rDettaglio["adate"] == DBNull.Value) continue;
                DateTime detDate = (DateTime) rDettaglio["adate"];


                //1) Un impegno di budget di esercizio precedente non deve mai essere ripreso per essere variato
                //2) Le variazioni in diminuzione avvenute nell'esercizio successivo a quello del fondo, devono generare un accertamento di budget mettendo la opportuna causale di ricavo sulla variazione
                //3) Le variazioni in diminuzione avvenute nell'esercizio successivo, devono generare un impegno di budget di tipo variazione  senza specificare la causale
                //4) Le variazioni in aumento avvenute nell'esercizio successivo, devono generare un impegno di budget nuovo 
                if (detDate.Year != esercizio) {
                    object idepexp = getIdEpExpByIdRelated(idrel, nphase);
                    // la struttura dell'idrelated era nel frattempo cambiata aggiungendo il numero dettaglio, ma su
                    // db sta  ancora un buon numero di impegni di budget con il vecchio idrelated
                    if (idepexp == DBNull.Value) {
                        idepexp = getIdEpExpByIdRelated(idrelprovision, nphase);
                    }
                    if (idepexp != DBNull.Value)
                    {
                        bf.RemoveEpExp(idepexp);
                    }
                    // non deve fare niente se non evitare di modificare vecchi impegni di budget
                    continue;
                }
                decimal amount = CfgFn.GetNoNullDecimal(rDettaglio["amount"]);
                bool flagvariation = false;
                if (amount < 0) { 
                    amount = -amount;
                    flagvariation = true;
                }
                object description = rDettaglio["description"];
                if (description == DBNull.Value) {
                    ShowMessage("Descrizione assente sul dettaglio fondo " + rDettaglio["rownum"]);
                    return false;
                }

                var currEpExp = bf.addEpExp(curr["idreg"], DBNull.Value, amount,
                    rDettaglio["description"], rDettaglio["adate"],
                    idaccCosto, curr["idupb"], idrel, curr["doc"], curr["docdate"],
                    DBNull.Value, DBNull.Value, nphase, parentIdEpExp, idaccmotive);
                if (currEpExp == null) return false;

          
               if (flagvariation) {
                    currEpExp["flagvariation"] = "S";
                }

                addImpegnoToDict(currEpExp, idrel);
                    somethingfound = true;
                }

            if (!somethingfound) {
                var obj = (nphase == 1) ? "preimpegno" : "impegno";
                if (!silent) {
                    ShowMessage("Nessun " + obj + " è stato generato.", "Avviso", false);
                }

                return true;
            }

            return true;
        }


        /// <summary>
        /// Prendere da config la nuova causale di reddito per risconti su donazione
        /// </summary>
        /// <returns></returns>
        object getIdAccMotiveRiscontoReddito() {
            return _rConfig["idaccmotive_assetrevenue"];
        }

        object getIdAccMotiveRicavoProrata() {
            return _rConfig["idaccmotive_prorata_revenue"];
        }

        object getIdAccMotiveCostoProrata() {
            return _rConfig["idaccmotive_prorata_cost"];
        }

        DataTable ottieniCostiUPB(object idupb) {
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);
            string query = "select  sum(ed.amount) as amount, " + //" ed.idreg " +//,ed.idepexp,ed.idacc,
                           " from entrydetail ed " +
                           " join entry e on e.yentry=ed.yentry and e.nentry=ed.nentry " +
                           " join account A on ED.idacc=A.idacc " +
                           " WHERE " +
                           " A.flagaccountusage & 64 <> 0 " + //costi
                           " AND ED.yentry= " + strYear + //scritture di quest'anno
                           " AND E.identrykind not in (8,11,12) " +
                           " AND ED.idupb= " + QHS.quote(idupb);
            // +" group by  ed.idreg"; //,ed.idepexp,ed.idacc
            DataTable t = Conn.SQLRunner(query, false, 600);
            return t;
        }

        void ripartisciSommaInBaseATabella(decimal somma, DataTable ricavi) {
            decimal sommaRicavi = MetaData.SumColumn(ricavi, "amount");
            decimal sommaDaRipartire = somma;
            foreach (DataRow r in ricavi.Rows) {
                //string idacc = r["idacc"].ToString();
                decimal amount = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(r["amount"]));
                if (amount == 0) {
                    r["amount"] = 0;
                    continue;
                }

                if (sommaRicavi == 0) {
                    r["amount"] = 0;
                    continue;
                }

                decimal quota = CfgFn.RoundValuta(sommaDaRipartire * (amount / sommaRicavi));
                r["amount"] = quota;
                sommaRicavi -= amount;
                sommaDaRipartire -= quota;
            }
        }
 
        DataTable ottieniRicaviUPB(object idupb, bool totali, bool leggiIdEpAcc, 
            bool splitIdsor /*splitIdsor Ripartisci i ricavi anche su coordinate analitiche*/) {
           
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);
            string filter = totali ? QHS.CmpLe("ED.yentry", currAyear) : QHS.CmpEq("ED.yentry", currAyear);
            string strIdepacc = leggiIdEpAcc ? ",ed.idepa                                 cc" : "";
            string strIdsor = splitIdsor ? ",ed.idsor1, ed.idsor2,ed.idsor3 " : "";
            string query = "select  sum(ed.amount) as amount, ed.idacc, ed.idreg,ed.idaccmotive" +
                            strIdsor + strIdepacc +
                           " from entrydetail ed " +
                           " join entry e on e.yentry=ed.yentry and e.nentry=ed.nentry " +
                           " join account A on ED.idacc=A.idacc " +
                           " WHERE " +
                           " ((A.flagaccountusage & 128) <> 0) " + //ricavo
                           " AND ((A.flagaccountusage & 524288) = 0) " +  // Escludi da calcolo Commessa completata . Task 15404
                           " AND E.identrykind not in (8,11,12) " +
                           " AND " + filter + //scritture di quest'anno o tutte le prec. a seconda del par. di input
                           " AND ED.idupb= " + QHS.quote(idupb) +
                           " group by  ed.idreg, ed.idacc,ed.idaccmotive" +
                             strIdsor + strIdepacc; //ed.idepacc,
            DataTable t = Conn.SQLRunner(query, false, 600);
            return t;
        }


        DataTable ottieniRateiUPB(object idupb, bool totali, bool leggiIdEpAcc) {
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);
            string filter = totali ? QHS.CmpLe("ED.yentry", currAyear) : QHS.CmpEq("ED.yentry", currAyear);
            string strIdepacc = leggiIdEpAcc ? ",ed.idepacc" : "";
            string query = "select  sum(ed.amount) as amount, ed.idacc, ed.idreg,ed.idaccmotive" + strIdepacc +
                           " from entrydetail ed " +
                           " join entry e on e.yentry=ed.yentry and e.nentry=ed.nentry " +
                           " join account A on ED.idacc=A.idacc " +
                           " WHERE " +
                           " ((A.flagaccountusage & 128) <> 0) " + //ricavo
                           " AND E.identrykind not in (8,11,12) " +
                           " AND " + filter + //scritture di quest'anno o tutte le prec. a seconda del par. di input
                           " AND ED.idupb= " + QHS.quote(idupb) +
                           " group by  ed.idreg, ed.idacc,ed.idaccmotive" + strIdepacc; //ed.idepacc,
            DataTable t = Conn.SQLRunner(query, false, 600);
            return t;
        }

        Hashtable ricaviAZero = new Hashtable();

        bool generaAccertamentiUpbCommessaCompletata(BudgetFunction bf, DataRow curr, int nphase) {

            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries
                return false;
            }

            object doc = $"UPB {curr["codeupb"]} ";
            DataTable details = DS.Tables["upbcommessa"];

            DateTime dec31 = new DateTime(esercizio, 12, 31);

            string campoRicavo = "idacc_revenue";
            string campoCausaleRicavo = "idaccmotive_revenue";

            bool annoFine = (CfgFn.GetNoNullInt32(curr["yearstop"]) == esercizio);

            //Accertamenti  nell'ultimo anno
            if (annoFine) {
                //se i costi sono inferiori ai ricavi
                bool risconta_ammortamenti_futuri =
                    _rConfig["risconta_ammortamenti_futuri"].ToString().ToUpper() == "S";
                // Questa gestione è opzionale e dipende da un parametro di configurazione annuale;
                if (!risconta_ammortamenti_futuri) return false;
                decimal costi = CfgFn.GetNoNullDecimal(curr["cost"]);
                decimal ricavi = CfgFn.GetNoNullDecimal(curr["revenue"]);
                decimal ratei = CfgFn.GetNoNullDecimal(curr["accruals"]);
                decimal importo_ammortamenti = CfgFn.GetNoNullDecimal(curr["assetamortization"]);
                if (ratei != 0) return false;
                if ((ricavi - costi) <= 0) return false;
                if (importo_ammortamenti == 0) return false;
                decimal importo_risconto = 0;

                if ((ricavi - costi) <= importo_ammortamenti) importo_risconto = ricavi;
                else importo_risconto = importo_ammortamenti;

                if (importo_risconto == 0) return false;

                var mainidrel = BudgetFunction.GetIdForDocument(curr);
                //  RICAVI a RISCONTO PASSIVO   >> var. accertamento
                //  Il conto di RISCONTO PASSIVO va preso dal tipo UPB o, ove non configurato, da CONFIG
                //  ripartiti proporzionalmente in base ai ricavi dell'anno
                //  Ossia detto RIS = somma ricavi dell'anno - somma costi dell'anno, ed Rt la somma dei ricavi dell'anno,
                //  i vari importi da riscontare ripartiti per ricavo saranno pari a RIS *(ricavo / Rt)

                DataTable tRicavi = ottieniRicaviUPB(curr["idupb"], false, false,false); //amount / idacc / idreg
                ripartisciSommaInBaseATabella(importo_risconto, tRicavi);
        
                foreach (DataRow r in tRicavi.Select()) {
                    var idaccRicavo = r["idacc"];
                    var idaccmotive = r["idaccmotive"];
                    var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                    var idreg = r["idreg"];
                    if (amount == 0) {
                        string key = getHash(r, new[] {"idacc", "idreg", "idaccmotive" });
                        ricaviAZero.Add(key, r);
                        continue;
                    }

                    string idrel = BudgetFunction.ComposeObjects(new[] {mainidrel, idreg, idaccRicavo});

                    object parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);

                    var currEpAcc = bf.addEpAcc(idreg, DBNull.Value, amount,
                        $"Assestamento {curr["ayear"]} per UPB {curr["codeupb"]}", dec31,
                        idaccRicavo, curr["idupb"], idrel, DBNull.Value, DBNull.Value,
                        DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, idaccmotive);
                    addAccertamentoToDict(currEpAcc, idrel);
                    idupbForEpAcc[(int) currEpAcc["idepacc"]] = curr["idupb"];
                    currEpAcc["flagvariation"] = "S";

                    //task 12767
                    // Sulla commessa completata quando generiamo un risconto passivo e quindi generiamo l'accertamento di budget 
                    // di tipo variazione, dobbiamo mettere l'importo della nota variazione anche nella casella dell'esercizio x+1 con segno meno.
                    var epaccYear = bf.epaccyearList[(int) currEpAcc["idepacc"]];
                    epaccYear["amount2"] = CfgFn.GetNoNullDecimal(epaccYear["amount2"]) - amount;
                }

                return true;
            }

            else {
                //Accertamenti  negli anni diversi dall'ultimo

                var mainidrel = BudgetFunction.GetIdForDocument(curr);

                decimal costi = CfgFn.GetNoNullDecimal(curr["cost"]);
                decimal ricavi = CfgFn.GetNoNullDecimal(curr["revenue"]);
                decimal riserve = CfgFn.GetNoNullDecimal(curr["reserve"]);

                if (costi >= ricavi && costi <= ricavi + riserve) return false;

                if (costi > ricavi + riserve) {
                    //  RATEO ATTIVO A RICAVI   >> accertamento
                    //  per la parte di costo che supera ricavi +riserve
                    //  Il conto di ricavo sarà un conto predefinito per quel progetto, 
                    //                  idem il rateo ma il rateo attivo ove assente prendere il rateo di config

                    decimal importo_rateo = costi - (ricavi + riserve);


                    if (curr[campoRicavo] == DBNull.Value) {
                        ShowMessage(
                            $"Conto di ricavo non configurata bene per l'upb {curr["codeupb"]} {curr["title"]}");
                        return false;
                    }

                    object parentIdEpAcc = getIdEpAccByIdRelated(mainidrel, nphase - 1);
                    var currEpAcc = bf.addEpAcc(DBNull.Value, DBNull.Value, importo_rateo,
                        $"Assestamento {curr["ayear"]} per UPB {curr["codeupb"]}", dec31,
                        curr[campoRicavo], curr["idupb"], mainidrel, DBNull.Value, DBNull.Value,
                        DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, curr[campoCausaleRicavo]);
                    addAccertamentoToDict(currEpAcc, mainidrel);
                    idupbForEpAcc[(int) currEpAcc["idepacc"]] = curr["idupb"];
                    currEpAcc["flagvariation"] = "N";

                }
                else {
                    //se i costi sono inferiori ai ricavi
                    decimal importo_risconto = ricavi - costi;

                    //  RICAVI a RISCONTO PASSIVO   >> var. accertamento
                    //  Il conto di RISCONTO PASSIVO va preso dal tipo UPB o, ove non configurato, da CONFIG
                    //  ripartiti proporzionalmente in base ai ricavi dell'anno
                    //  Ossia detto RIS = somma ricavi dell'anno - somma costi dell'anno, ed Rt la somma dei ricavi dell'anno,
                    //  i vari importi da riscontare ripartiti per ricavo saranno pari a RIS *(ricavo / Rt)
                    DataTable tRicavi = ottieniRicaviUPB(curr["idupb"], false, false,false); //amount / idacc / idreg
                    ripartisciSommaInBaseATabella(importo_risconto, tRicavi);
                    foreach (DataRow r in tRicavi.Select()) {
                        var idaccRicavo = r["idacc"];
                        var idaccmotive = r["idaccmotive"];
                        var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                        var idreg = r["idreg"];
                        if (amount == 0) {
                            continue;
                        }
                            
                        string idrel = BudgetFunction.ComposeObjects(new[] {mainidrel, idreg, idaccRicavo});

                        object parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);

                        var currEpAcc = bf.addEpAcc(idreg, DBNull.Value, amount,
                            $"Assestamento {curr["ayear"]} per UPB {curr["codeupb"]}", dec31,
                            idaccRicavo, curr["idupb"], idrel, DBNull.Value, DBNull.Value,
                            DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, idaccmotive);
                        addAccertamentoToDict(currEpAcc, idrel);
                        idupbForEpAcc[(int) currEpAcc["idepacc"]] = curr["idupb"];
                        currEpAcc["flagvariation"] = "S";

                        //task 12767
                        // Sulla commessa completata quando generiamo un risconto passivo e quindi generiamo l'accertamento di budget 
                        // di tipo variazione, dobbiamo mettere l'importo della nota variazione anche nella casella dell'esercizio x+1 con segno meno.
                        var epaccYear = bf.epaccyearList[(int) currEpAcc["idepacc"]];
                        epaccYear["amount2"] = CfgFn.GetNoNullDecimal(epaccYear["amount2"]) - amount;

                    }
                }
            }

            return true;
        }

        private DataTable ottieniRateiAssestamentoCommessaCompletata(object idupb) {
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);
            string query =
                "select U.idupb,  " +
                "-sum(case when A.idacc = EU.idacc_accruals then ED.amount else 0 end) as accruals," +
                "EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals," +
                "EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
                "year(U.stop) as yearstop, year(U.start) as yearstart,   EU.adjustmentkind,U.idepupbkind,U.codeupb,U.title,ED.idepacc " +
                "from entrydetail ed (nolock) " +
                "join upb u (nolock) on ed.idupb = u.idupb " +
                "join epupbkindyear EU (nolock)  on EU.idepupbkind = U.idepupbkind " +
                "join account A (nolock) on A.idacc = ed.idacc " +
                " where " +
                QHS.AppAnd(QHS.NullOrLe("year(U.start)", currAyear),
                    QHS.CmpGt("year(U.stop)", currAyear), QHS.CmpEq("EU.ayear", currAyear),
                    QHS.CmpEq("EU.adjustmentkind", "C"), QHS.CmpEq("ED.yentry", currAyear),
                    QHS.CmpEq("U.idupb", idupb)
                ) +

                " group by U.idupb,EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals, " +
                " EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
                " EU.adjustmentkind,year(U.stop),year(U.start),U.idepupbkind,U.codeupb,U.title,ED.idepacc  ";


            DataTable tPluri = DataAccess.SQLRunner(Conn, query, false, 600);
            return tPluri;
        }

        //private DataTable ottieniDettagliAssestamentoCommessaCompletata(object idupb) {
        //    int currAyear = esercizio;
        //    string strYear = QHS.quote(currAyear);
        //    string query =
        //        "select U.idupb,  " +
        //        "-sum(case when A.flagaccountusage & 64 <> 0 then ED.amount else 0 end) as cost," +
        //        "sum(case when A.flagaccountusage & 128 <> 0 then ED.amount else 0 end) as revenue," +
        //        "sum(case when A.flagaccountusage & 2048 <> 0 then ED.amount else 0 end) as reserve," +
        //        "-sum(case when A.idacc = EU.idacc_accruals then ED.amount else 0 end) as accruals," +
        //        "EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals," +
        //        "EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
        //        "year(U.stop) as yearstop, year(U.start) as yearstart,   EU.adjustmentkind,U.idepupbkind,U.codeupb,U.title " +
        //        "from entrydetail ed (nolock) " +
        //        "join upb u (nolock) on ed.idupb = u.idupb " +
        //        "join epupbkindyear EU (nolock)  on EU.idepupbkind = U.idepupbkind " +
        //        "join account A (nolock) on A.idacc = ed.idacc " +
        //        " where " +
        //        QHS.AppAnd(QHS.NullOrLe("year(U.start)", currAyear),
        //                    QHS.CmpGt("year(U.stop)", currAyear), QHS.CmpEq("EU.ayear", currAyear),
        //            QHS.CmpEq("EU.adjustmentkind", "C"), QHS.CmpEq("ED.yentry", currAyear),
        //            QHS.CmpEq("U.idupb", idupb)
        //            ) +

        //        " group by U.idupb,EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals, " +
        //        " EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
        //        " EU.adjustmentkind,year(U.stop),year(U.start),U.idepupbkind,U.codeupb,U.title  ";


        //    DataTable tPluri = DataAccess.SQLRunner(Conn, query, false, 600);
        //    return tPluri;
        //}

        bool generaImpegniUpbCommessaCompletata(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            string campoCosto = "idacc_cost";
            string causaleCosto = "idaccmotive_cost";

            object doc =
                $"UPB {curr["codeupb"]} ";

            DateTime dec31 = new DateTime(esercizio, 12, 31);
            bool annoFine = (CfgFn.GetNoNullInt32(curr["yearstop"]) == esercizio);
            if (!annoFine) return false;

            //DataTable tEntryDetailSource = ottieniRateiAssestamentoCommessaCompletata(curr["idupb"]);      

            //Impegni solo nell'ultimo anno, sempre se ci sono ratei
            decimal rateo = CfgFn.GetNoNullDecimal(curr["accruals"]);
            if (rateo == 0) {
                //if (!silent) {
                //	ShowMessage(
                //		"Non sono presenti ratei per l'upb quindi non è stato generato alcun impegno di budget",
                //		"Avviso");
                //}

                return false;
            }

            var idrel = BudgetFunction.GetIdForDocument(curr);
            if (curr[campoCosto] == DBNull.Value) {
                ShowMessage($"Conto di costo non trovato per UPB {curr["codeupb"]} {curr["title"]} ", "Errore");
                return false;
            }

            var currEpExp = bf.addEpExp(DBNull.Value, //idreg
                DBNull.Value, //idman
                rateo,
                $"Assestamento commessa completata (anno scadenza) {curr["ayear"]} per UPB {curr["codeupb"]}",
                dec31,
                curr[campoCosto], curr["idupb"], idrel, DBNull.Value, dec31,
                DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrel, nphase - 1), curr[causaleCosto]);

            if (currEpExp == null) return false;
            addImpegnoToDict(currEpExp, idrel);

            return true;
        }

        bool generaAccertamentiProvisionUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            object doc = "Accantonamento " + curr["description"];
            bool somethingfound = false;
            DataTable details = DS.Tables["provisiondetail"];


            //Considera tutte le righe con la causale di ricavo
            foreach (DataRow rDettaglio in details.Select(QHC.IsNotNull("idaccmotive"))) {
                if (rDettaglio["adate"] == DBNull.Value) continue;
                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);
                DateTime detDate = (DateTime) rDettaglio["adate"];
                if (detDate.Year != esercizio) {
                    object idepacc = getIdEpAccByIdRelated(idrel, nphase);
                    if (idepacc != DBNull.Value) bf.RemoveEpAcc(idepacc);
                    continue;
                }

                object parentIdEpAcc = getIdEpAccByIdRelated(idrel, nphase - 1);
                string idaccmotive = rDettaglio["idaccmotive"].ToString();

                DataRow[] rEntriesRicavo = EP.GetAccMotiveDetails(idaccmotive);

                if (rEntriesRicavo.Length != 1) {
                    ShowMessage(
                        "Causale di ricavo non configurata bene per l'accantonamento " + curr["description"]);
                    return false;
                }

                object idaccRicavo = rEntriesRicavo[0]["idacc"];

                decimal amount = -CfgFn.GetNoNullDecimal(rDettaglio["amount"]);
                object description = rDettaglio["description"];
                if (description == DBNull.Value) {
                    ShowMessage("Descrizione assente sul dettaglio fondo " + rDettaglio["rownum"]);
                    return false;
                }

                var currEpAcc = bf.addEpAcc(curr["idreg"], DBNull.Value, amount,
                    rDettaglio["description"], rDettaglio["adate"],
                    idaccRicavo, curr["idupb"], idrel, curr["doc"], curr["docdate"],
                    DBNull.Value, DBNull.Value, nphase, parentIdEpAcc, idaccmotive);
                if (currEpAcc == null) return false;
                addAccertamentoToDict(currEpAcc, idrel);
                somethingfound = true;
            }

            if (!somethingfound) {
                var obj = (nphase == 1) ? "preaccertamento" : "accertamento";
                if (!silent) {
                    ShowMessage("Nessun " + obj + " è stato generato.", "Avviso", false);
                }

                return true;
            }

            return true;
        }

        bool generaAccertamentiBuonoScaricoUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                return false;
            }

            object dataImpegni = curr["adate"];

            object idreg = curr["idreg"];

            int yassetunload = CfgFn.GetNoNullInt32(curr["yassetunload"]);
            if (yassetunload != esercizio) {
                //if (!silent) {
                ShowMessage("Il buono non appartiene all'esercizio corrente", "Errore");
                //}

                return false;
            }

            bool somethingfound = false;

            string idrelated_assetunload = BudgetFunction.GetIdForDocument(curr).ToLower();

            DataTable assetpieceview;
            if (DS.Tables.Contains("assetpieceview")) {
                assetpieceview = DS.Tables["assetpieceview"];
            }
            else {
                assetpieceview = Conn.RUN_SELECT("assetpieceview", "*", null,
                    QHS.CmpEq("idassetunload", curr["idassetunload"]), null, false);
            }

            //filtra a monte solo i carichi effettuati con una causale non di reddito,salta quelli senza causale di carico
            DataTable assetamortizationrisconti = Conn.RUN_SELECT("assetamortizationrisconti", "*", null,
                QHS.AppAnd(QHS.CmpEq("idassetunload", curr["idassetunload"]),
                    QHS.IsNotNull("idaccmotive"),
                    QHS.BitSet("flagaccountusage", 3)), null, false);
            assetamortizationrisconti.TableName = "assetamortization";



            object doc = "Buono Scarico " +
                         curr["idassetunloadkind"].ToString() + "/" +
                         curr["yassetunload"].ToString().Substring(2, 2) + "/" +
                         curr["nassetunload"].ToString().PadLeft(6, '0');


            object descr = (curr["description"] != DBNull.Value) ? curr["description"] : ".";

            object idaccmotiveReddito = getIdAccMotiveRiscontoReddito();
            DataRow[] rEntriesReddito = EP.GetAccMotiveDetails(idaccmotiveReddito);


            object idaccReddito = DBNull.Value;
            //DataRow RAccountReddito = null;
            if (assetamortizationrisconti.Rows.Count > 0) {
                if (rEntriesReddito.Length != 1) {
                    DataRow rAm = assetamortizationrisconti.Rows[0];
                    string rAmStr = $"cespite di inventario {rAm["ninventory"]} {rAm["inventory"]} ";
                    if (!silent)
                        ShowMessage(
                            "Causale di reddito  non configurata bene per i risconti su donazione (in config).\r\n" +
                            "E' presente un ammortamento sul " + rAmStr);
                    return false;
                }

                idaccReddito = rEntriesReddito[0]["idacc"];
                //RAccountReddito = EP.getRowIdAcc(idaccReddito);
            }



            bool isAmmortamento = false;
            string idepcontext = "";
            foreach (DataRow rAssAmm in assetamortizationrisconti.Rows) {
                decimal importoAmm = -CfgFn.GetNoNullDecimal(rAssAmm["amount"]);
                if (importoAmm == 0) continue;
                if (rAssAmm["idassetunload"] == DBNull.Value) continue;
                object tipoAmm = rAssAmm["idinventoryamortization"];
                DataRow rInvAmm = ottieniRowTipoAmm(tipoAmm);
                isAmmortamento = (CfgFn.GetNoNullByte(rInvAmm["flag"]) & 8) != 0;
                idepcontext = (isAmmortamento) ? "AMMORTA" : "SVALUTA";
                object idasset = rAssAmm["idasset"];
                object idpiece = rAssAmm["idpiece"];
                object idupb = rAssAmm["idupb"];
                object inventoryamortization = rAssAmm["inventoryamortization"];

                var idrel = BudgetFunction.GetIdForDocument(rAssAmm); //assetunload/idassetunload/namortization

                var currEpacc = bf.addEpAcc(idreg,
                    DBNull.Value, //idman
                    importoAmm,
                    rAssAmm["description"], dataImpegni,
                    idaccReddito, idupb, idrel, doc, curr["adate"],
                    DBNull.Value, DBNull.Value, nphase, getIdEpAccByIdRelated(idrel, nphase - 1), idaccmotiveReddito);
                if (currEpacc == null) return false;
                addAccertamentoToDict(currEpacc, idrel);
                somethingfound = true;
            }


            foreach (DataRow rAsset in assetpieceview.Rows) {
                if (rAsset["idassetunload"] == DBNull.Value) continue;
                string parte = rAsset["idpiece"].ToString() == "1" ? " " : $" n. parte {rAsset["idpiece"]} ";

                object idupb = rAsset["idupb"];

                DataTable tAssetRisc = Conn.RUN_SELECT("assetrisconti", "*", null, QHS.AppAnd(
                    QHS.CmpEq("idasset", rAsset["idasset"]), QHS.CmpEq("idpiece", rAsset["idpiece"]),
                    QHS.IsNotNull("idaccmotive"),
                    QHS.BitSet("flagaccountusage", 3)), null, false);
                if (tAssetRisc.Rows.Count == 0) {
                    continue;
                }

                object idaccRisconto = tAssetRisc.Rows[0]["idacc"];

                // Devo solo calcolare l'importo del bene da scaricare
                // perché ci possono essere delle svalutazioni associati (solo se sono svalutazioni perché se sono
                // ammortamenti non ci sono problemi)
                decimal importoIniziale = calcolaImportoInizialeCespite(rAsset);
                decimal importoAccessPossedutiScaricati = calcolaTotAccessoriPossedutiScaricati(rAsset);
                decimal importoSvalutazioni = calcolaimportoSvalutazioni(rAsset);
                // Faccio la somma algebrica, sottraendo già in partenza le svalutazioni
                decimal importoAttuale = importoIniziale - importoAccessPossedutiScaricati + importoSvalutazioni;

                // devo integrare la scrittura sui cespiti con le eventuali svalutazioni trovate
                DataTable tAmmortamento = new DataTable();
                string query =
                    "SELECT a.amount, a.idinventoryamortization,a.idasset,a.idpiece, a.inventoryamortization,a.idsor1,a.idsor2,a.idsor3 " +
                    " ,inventory,ninventory, a.description " +
                    " FROM assetamortizationunloadview a "
                    + " JOIN inventoryamortization i ON i.idinventoryamortization = a.idinventoryamortization "
                    + " WHERE " + QHS.AppAnd(QHS.MCmp(rAsset, new string[] {"idasset", "idpiece"}),
                        QHS.BitSet("i.flag", 3));
                tAmmortamento = Conn.SQLRunner(query);

                decimal totammortamenti = 0;

                foreach (DataRow rAmm in tAmmortamento.Rows) {
                    decimal importoAmm = -CfgFn.GetNoNullDecimal(rAmm["amount"]);
                    if (importoAmm == 0) continue;
                    totammortamenti += importoAmm;
                }

                decimal importoattualelordo = importoAttuale;
                importoAttuale -= totammortamenti;
                object idaccmotive = calcolaCausaleEpScaricoCespite(rAsset["idinv"]);


                if (importoAttuale != 0) {
                    DataRow assetRisc = tAssetRisc.Rows[0];

                    if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                        ShowMessage("Non è stata specificata la causale per la class. inventariale del cespite n." +
                                    rAsset["idasset"] + "/" + rAsset["idpiece"], "Errore");
                        return false;
                    }

                    if (rEntriesReddito.Length != 1) {
                        string rAmStr = $"cespite di inventario {rAsset["ninventory"]} {rAsset["inventory"]} ";
                        if (!silent)
                            ShowMessage(
                                "Causale di reddito  non configurata bene per i risconti su donazione (in config).\r\n" +
                                "Deve essere scaricato il " + rAmStr);
                        return false;
                    }

                    var idrel = BudgetFunction.ComposeObjects(new[] {
                        BudgetFunction.GetIdForDocument(curr),
                        rAsset["idasset"], rAsset["idpiece"]
                    });
                    ; //assetunload/idassetunload/idasset/idpiece

                    var currEpacc = bf.addEpAcc(idreg,
                        DBNull.Value, //idman
                        importoAttuale,
                        $"Risconto Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}", dataImpegni,
                        idaccReddito, idupb, idrel, doc, curr["adate"],
                        DBNull.Value, DBNull.Value, nphase, getIdEpAccByIdRelated(idrel, nphase - 1),
                        idaccmotiveReddito);

                    if (currEpacc == null) return false;
                    addAccertamentoToDict(currEpacc, idrel);
                    somethingfound = true;

                    //EP.EffettuaScritturaIdRelated(idepcontext, importoAttuale, idaccReddito, idreg, idupb, rAsset,
                    //    idaccmotive, idrel,
                    //   );

                }


            }

            if (!somethingfound) {
                var obj = (nphase == 1) ? "preaccertamento" : "accertamento";
                if (!silent) {
                    ShowMessage(
                        "Nessun carico ha la causale di reddito quindi nessun " + obj + " è stato generato.",
                        "Avviso", false);
                }

                return true;
            }

            return true;

        }


        bool generaImpegniBuonoCaricoUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                return false;
            }

            object doc = "Buono Carico " +
                         curr["idassetloadkind"].ToString() + "/" +
                         curr["yassetload"].ToString().Substring(2, 2) + "/" +
                         curr["nassetload"].ToString().PadLeft(6, '0');

            object dataImpegni = curr["adate"];

            int yload = CfgFn.GetNoNullInt32(curr["yassetload"]);

            if (yload != esercizio) {
                //if (!silent) {
                ShowMessage("Il buono non appartiene all'esercizio corrente", "Avviso");
                //}

                return false;
            }

            bool somethingfound = false;
            string idrelated_assetload = BudgetFunction.GetIdForDocument(curr).ToLower();

            DataTable assetacquireview;
            if (DS.Tables.Contains("assetacquireview")) {
                assetacquireview = DS.Tables["assetacquireview"];
            }
            else {
                assetacquireview = Conn.RUN_SELECT("assetacquireview", "*", null,
                    QHS.CmpEq("idassetload", curr["idassetload"]), null, false);
            }

            object descr = (curr["description"] != DBNull.Value) ? curr["description"] : ".";



            //Opera solo sui dettagli che iniziano quest'anno o che hanno data inizio null se anno contratto=anno corrente
            // e che  hanno data stop null o in anni successivi
            //Questo non agisce sui dettagli annullati o cancellati però
            foreach (DataRow rAssetAcquire in assetacquireview.Select()) {
                if (rAssetAcquire["idassetload"] == DBNull.Value) continue;

                var idrel = BudgetFunction.GetIdForDocument(rAssetAcquire);

                object assetloadMotive = rAssetAcquire["idmot"];
                bool caricoDAtrasferimento = isCaricoDaTrasferimento(assetloadMotive);

                object idaccAssetLoadMotive = caricoDAtrasferimento
                    ? calcolaCausaleEpScaricoCespite(rAssetAcquire["idinv"])
                    : calcolaIdAccMotiveCausaleCarico(assetloadMotive);

                object idreg = rAssetAcquire["idreg"];
                object idupb = rAssetAcquire["idupb"];
                if (rAssetAcquire["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il carico " + rAssetAcquire["description"]);
                    return false;
                }

                //L'importo originale 
                decimal importoOriginale = CfgFn.GetNoNullDecimal(rAssetAcquire["cost"]);
                //decimal importoUnitario = importoOriginale / CfgFn.GetNoNullDecimal(rAssetAcquire["number"]);
                decimal importoScontato = CfgFn.GetNoNullDecimal(rAssetAcquire["cost_discounted"]);
                decimal sconto = importoOriginale - importoScontato;
                object idaccmotiveImmobilizzazione = calcolaIdAccMotiveCaricoCespite(rAssetAcquire["idinv"]);
                object idaccmotiveSconto = calcolaIdAccMotiveScontoCespite(rAssetAcquire["idinv"]);
                object idaccAssetLoadTrasferimento = calcolaIdAccMotiveTrasferimentoCespite(rAssetAcquire["idinv"]);

                decimal valoreStorico = CfgFn.GetNoNullDecimal(rAssetAcquire["historicalvalue"]);


                if (idaccmotiveSconto == DBNull.Value) {
                    sconto = 0;
                    importoScontato = importoOriginale;
                }
                else {
                    importoOriginale = importoScontato; //questo è l'importo netto del costo
                }

                if (caricoDAtrasferimento && idaccAssetLoadMotive != null && idaccAssetLoadMotive != DBNull.Value &&
                    importoOriginale > 0) {
                    DataRow[] ContiCarico = EP.GetAccMotiveDetails(idaccAssetLoadMotive);
                    if (!ContiCarico._HasRows()) {
                        ShowMessage(
                            "Causale di scarico non configurata bene per la class. inventariale del carico  " +
                            rAssetAcquire["nassetacquire"]);
                        return false;
                    }

                    string idrelated = BudgetFunction.GetIdForDocument(rAssetAcquire);

                    foreach (DataRow conto in ContiCarico) {
                        if (!EP.isCosto(conto["idacc"])) continue;
                        if (EP.isImmobilizzazione(conto["idacc"])) continue;
                        var currEpExpTransfer = bf.addEpExp(idreg,
                            DBNull.Value, //idman
                            importoOriginale,
                            rAssetAcquire["description"], dataImpegni,
                            conto["idacc"], idupb, idrelated + "§reload", doc, rAssetAcquire["adate"],
                            DBNull.Value, DBNull.Value, nphase,
                            getIdEpExpByIdRelated(idrelated + "§reload", nphase - 1),
                            idaccmotiveImmobilizzazione);
                        currEpExpTransfer["flagvariation"] = "S";
                        if (currEpExpTransfer == null) return false;
                        addImpegnoToDict(currEpExpTransfer, idrelated + "§reload");
                        somethingfound = true;
                    }

                    continue;
                }

                if ((idaccmotiveImmobilizzazione == null) ||
                    (idaccmotiveImmobilizzazione == DBNull.Value) && sconto == 0) continue;


                if (((idaccmotiveImmobilizzazione == null) || (idaccmotiveImmobilizzazione == DBNull.Value)) &&
                    sconto > 0) {
                    ShowMessage("Non è stata specificata la causale per la class. inventariale del carico n." +
                                rAssetAcquire["nassetacquire"], "Errore");
                    return false;
                }

                DataRow[] ContiImmobilizzazione = EP.GetAccMotiveDetails(idaccmotiveImmobilizzazione);
                if (!ContiImmobilizzazione._HasRows() && sconto > 0) {
                    ShowMessage("Causale di carico della class.inventariale non configurata bene per il carico " +
                                rAssetAcquire["nassetacquire"]);
                    return false;
                }

                object idaccImmobilizzazione = null;
                if (ContiImmobilizzazione._HasRows()) {
                    idaccImmobilizzazione = ContiImmobilizzazione._First()["idacc"];
                    if (!isBudgetEnabled(idaccImmobilizzazione)) continue;
                }

                bool isRicavo = false;
                object idaccReddito = DBNull.Value;

                if (idaccAssetLoadMotive != null && idaccAssetLoadMotive != DBNull.Value) {
                    DataRow[] ContiReddito = EP.GetAccMotiveDetails(idaccAssetLoadMotive);
                    if (ContiReddito.Length != 0) {
                        idaccReddito = ContiReddito[0]["idacc"];
                        DataRow RAccountReddito = EP.getRowIdAcc(idaccReddito);
                        int flagReddito = CfgFn.GetNoNullInt32(RAccountReddito["flagaccountusage"]);
                        isRicavo = (flagReddito & 128) != 0;
                    }
                }


                if (isRicavo) {
                    sconto = 0;
                    importoScontato = importoOriginale;
                }

                object idaccSconto = DBNull.Value;
                DataRow RAccountSconto = null;
                if (sconto > 0) {
                    DataRow[] ContiSconto = EP.GetAccMotiveDetails(idaccmotiveSconto);
                    if (ContiSconto.Length == 0) {
                        ShowMessage(
                            "Causale di sconto non configurata per il carico " + rAssetAcquire["nassetacquire"],
                            "Avviso", false);
                        continue;
                    }

                    idaccSconto = ContiSconto[0]["idacc"];
                    RAccountSconto = EP.getRowIdAcc(idaccSconto);
                }

                //Impegno ed accertamento su sconto, a prescindere da causale di carico, tranne per quelli associati a conti di reddito
                if (sconto > 0) {
                    string idrelDiscount = idrel + "§discount";
                    var currEpAccSconto = bf.addEpAcc(idreg,
                        DBNull.Value, //idman
                        sconto,
                        rAssetAcquire["description"], dataImpegni,
                        idaccSconto, idupb, idrelDiscount, doc, rAssetAcquire["adate"],
                        DBNull.Value, DBNull.Value, nphase, getIdEpAccByIdRelated(idrelDiscount, nphase - 1),
                        idaccmotiveSconto);
                    if (currEpAccSconto == null) return false;
                    somethingfound = true;
                    addAccertamentoToDict(currEpAccSconto, idrelDiscount);

                    var currEpExpSconto = bf.addEpExp(idreg,
                        DBNull.Value, //idman
                        sconto,
                        rAssetAcquire["description"], dataImpegni,
                        idaccImmobilizzazione, idupb, idrelDiscount, doc, rAssetAcquire["adate"],
                        DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrelDiscount, nphase - 1),
                        idaccmotiveImmobilizzazione);
                    if (currEpExpSconto == null) return false;
                    somethingfound = true;
                    addImpegnoToDict(currEpExpSconto, idrelDiscount);

                }


                if ((idaccAssetLoadMotive == null) || (idaccAssetLoadMotive == DBNull.Value)) continue;
                if (idaccImmobilizzazione == null) {
                    ShowMessage("Causale di carico della class.inventariale non configurata bene per il carico " +
                                rAssetAcquire["nassetacquire"]);
                    return false;
                }


                //Imposta l'impegno di budget relativo al dettaglio
                var currEpExp = bf.addEpExp(idreg,
                    DBNull.Value, //idman
                    importoOriginale,
                    rAssetAcquire["description"], dataImpegni,
                    idaccImmobilizzazione, idupb, idrel, doc, rAssetAcquire["adate"],
                    DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrel, nphase - 1), idaccAssetLoadMotive);
                if (currEpExp == null) return false;
                addImpegnoToDict(currEpExp, idrel);
                somethingfound = true;

                if (isRicavo) {
                    if (idaccReddito == DBNull.Value) {
                        ShowMessage(
                            "Causale di reddito non configurata per il carico " + rAssetAcquire["nassetacquire"],
                            "Errore", false);
                        continue;
                    }

                    var currEpAcc = bf.addEpAcc(idreg,
                        DBNull.Value, //idman
                        importoOriginale,
                        rAssetAcquire["description"], dataImpegni,
                        idaccReddito, idupb, idrel, doc, rAssetAcquire["adate"],
                        DBNull.Value, DBNull.Value, nphase, getIdEpAccByIdRelated(idrel, nphase - 1),
                        idaccmotiveImmobilizzazione);
                    if (currEpAcc == null) return false;
                    addAccertamentoToDict(currEpAcc, idrel);
                }


            }

            if (!somethingfound) {
                if (!silent) {
                    ShowMessage(
                        "Nessun carico ha la causale di reddito o sconto quindi nessun movimento è stato generato.",
                        "Avviso", false);
                }

                return true;
            }

            return true;
        }

        bool generaImpegniBuonoScaricoUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                return false;
            }

            object dataImpegni = curr["adate"];

            object idreg = curr["idreg"];

            int yassetunload = CfgFn.GetNoNullInt32(curr["yassetunload"]);
            if (yassetunload != esercizio) {
                //if (!silent) {
                ShowMessage("Il buono non appartiene all'esercizio corrente", "Avviso");
                //}

                return false;
            }

            bool somethingfound = false;

            string idrelated_assetunload = BudgetFunction.GetIdForDocument(curr).ToLower();

            object doc = "Buono Scarico " +
                         curr["idassetunloadkind"].ToString() + "/" +
                         curr["yassetunload"].ToString().Substring(2, 2) + "/" +
                         curr["nassetunload"].ToString().PadLeft(6, '0');


            object descr = (curr["description"] != DBNull.Value) ? curr["description"] : ".";

            DataTable assetpieceview;
            if (DS.Tables.Contains("assetpieceview")) {
                assetpieceview = DS.Tables["assetpieceview"];
                //ShowMessage("Contains " + assetpieceview.Rows.Count.ToString());
            }
            else {
                assetpieceview = Conn.RUN_SELECT("assetpieceview", "*", null,
                    QHS.CmpEq("idassetunload", curr["idassetunload"]), null, false);
                //ShowMessage("RUN_SELECT " + assetpieceview.Rows.Count.ToString());
            }

            DataTable assetamortizationunloadview;
            if (DS.Tables.Contains("assetamortizationunloadview")) {
                assetamortizationunloadview = DS.Tables["assetamortizationunloadview"];
            }
            else {
                assetamortizationunloadview = Conn.RUN_SELECT("assetamortizationunloadview", "*", null,
                    QHS.CmpEq("idassetunload", curr["idassetunload"]), null, false);
            }

            foreach (DataRow rAssAmm in assetamortizationunloadview.Rows) {
                decimal importoAmm = -CfgFn.GetNoNullDecimal(rAssAmm["amount"]);
                if (importoAmm == 0) continue;
                if (rAssAmm["idassetunload"] == DBNull.Value) continue;
                object tipoAmm = rAssAmm["idinventoryamortization"];
                DataRow rInvAmm = ottieniRowTipoAmm(tipoAmm);
                bool isAmmortamento = (CfgFn.GetNoNullByte(rInvAmm["flag"]) & 8) != 0;
                var idepcontext = (isAmmortamento) ? "AMMORTA" : "SVALUTA";
                object idasset = rAssAmm["idasset"];
                object idpiece = rAssAmm["idpiece"];
                object idupb = rAssAmm["idupb"];
                string parte2 = idpiece.ToString() == "1" ? " " : $" n. parte {idpiece} ";
                object inventoryamortization = rAssAmm["inventoryamortization"];
                object idaccmotive = ottieniIdAccMotiveAmm(tipoAmm, idasset, idpiece, "idaccmotive");
                if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                    string textVar = (isAmmortamento) ? "dell'ammortamento " : "della svalutazione ";
                    ShowMessage(
                        "La causale E/P " + textVar + inventoryamortization.ToString() + " non è stata configurata!" +
                        "\nInserire la configurazione sulla classificazione inventariale del cespite ammortizzato" +
                        "\n(menu: Cespiti > Classificazione inventariale).",
                        "Errore");
                    return false;
                }

                DataRow[] ContiSpesa = EP.GetAccMotiveDetails(idaccmotive.ToString());
                var idrel = BudgetFunction.GetIdForDocument(rAssAmm);
                foreach (DataRow r in ContiSpesa) {
                    object idacc = r["idacc"];
                    if (!EP.isCosto(idacc)) continue;

                    if (!isBudgetEnabled(idacc)) continue;

                    //EP.EffettuaScrittura(idepcontext, importoAmm, idacc, idreg, idupb, null, null, rAssAmm, idaccmotive);
                    string what = ((isAmmortamento) ? "ammortamento " : "svalutazione ") +
                                  inventoryamortization.ToString() + " " + rAssAmm["inventory".ToString()] + " " +
                                  rAssAmm["ninventory"] + parte2
                                  + rAssAmm["description"];
                    if (what.Length > 150) {
                        what = what.Substring(0, 150);
                    }

                    ;
                    var currEpexp = bf.addEpExp(idreg,
                        DBNull.Value, //idman
                        importoAmm,
                        what, dataImpegni,
                        idacc, idupb, idrel, doc, curr["adate"],
                        DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrel, nphase - 1), idaccmotive);
                    if (currEpexp == null) {
                        return false;
                    }

                    currEpexp["flagvariation"] = "N";
                    addImpegnoToDict(currEpexp, idrel);
                    somethingfound = true;

                }
            }



            // Andiamo a ciclare sui cespiti da scaricare

            foreach (DataRow rAsset in assetpieceview.Rows) {
                var idrel = BudgetFunction.GetIdForDocument(rAsset);
                if (rAsset["idassetunload"] == DBNull.Value) continue;

                object idupb = rAsset["idupb"];
                // Devo applicare la causale di scarico, devo solo calcolare l'importo del bene da scaricare
                // perché ci possono essere delle svalutazioni associati (solo se sono svalutazioni perché se sono
                // ammortamenti non ci sono problemi)
                decimal importoIniziale = calcolaImportoInizialeCespite(rAsset);
                decimal importoAccessPossedutiScaricati = calcolaTotAccessoriPossedutiScaricati(rAsset);
                decimal importoSvalutazioni = calcolaimportoSvalutazioni(rAsset);
                // Faccio la somma algebrica, sottraendo già in partenza le svalutazioni
                decimal importoAttuale = importoIniziale - importoAccessPossedutiScaricati + importoSvalutazioni;


                // devo integrare la scrittura sui cespiti con le eventuali svalutazioni trovate
                DataTable tAmmortamento = new DataTable();
                string query =
                    "SELECT a.amount, a.idinventoryamortization,a.idasset,a.idpiece, a.inventoryamortization,a.idsor1,a.idsor2,a.idsor3 " +
                    " ,inventory,ninventory, a.description " +
                    " FROM assetamortizationunloadview a "
                    + " JOIN inventoryamortization i ON i.idinventoryamortization = a.idinventoryamortization "
                    + " WHERE " + QHS.AppAnd(QHS.MCmp(rAsset, new string[] {"idasset", "idpiece"}),
                        QHS.BitSet("i.flag", 3));
                tAmmortamento = Conn.SQLRunner(query);

                decimal totammortamenti = 0;

                foreach (DataRow rAmm in tAmmortamento.Rows) {
                    decimal importoAmm = -CfgFn.GetNoNullDecimal(rAmm["amount"]);
                    if (importoAmm == 0) continue;

                    totammortamenti += importoAmm;

                }

                object idaccmotive = calcolaCausaleEpScaricoCespite(rAsset["idinv"]);
                string parte = rAsset["idpiece"].ToString() == "1" ? " " : $" n. parte {rAsset["idpiece"]} ";

                decimal importoAttualeLordo = importoAttuale;
                importoAttuale -= totammortamenti;
                //ShowMessage(parte + "importo attuale" + importoAttuale.ToString() + "causale" + idaccmotive.ToString());
                if (importoAttuale != 0) {
                    if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                        ShowMessage("Non è stata specificata la causale per la class. inventariale del cespite n." +
                                    rAsset["idasset"] + "/" + rAsset["idpiece"], "Errore");
                        return false;
                    }

                    DataRow[] ContiSpesa = EP.GetAccMotiveDetails(idaccmotive);
                    //ShowMessage("Cespite/accessorio n." +
                    //               rAsset["idasset"] + "/" + rAsset["idpiece"], "Errore");
                    foreach (DataRow r in ContiSpesa) {
                        object idacc = r["idacc"];
                        // Verifico se è un conto di costo
                        if (EP.isImmobilizzazione(idacc)) {
                            //EMilia: 12090 Sull'immobilizzazione non dobbiamo fare nulla perchè se scarico un cespite non mi torna mica la disponibilità di budget.
                            //var idrelAsset = BudgetFunction.GetIdForDocument(curr) + "§" + rAsset["idasset"] + "§" + rAsset["idpiece"] + "§immob";
                            //var currEpexp = bf.addEpExp(idreg,
                            //             DBNull.Value, //idman
                            //             importoAttuale,
                            //             $"Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}", dataImpegni,
                            //             idacc, idupb, idrelAsset, doc, curr["adate"],
                            //             DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrelAsset, nphase - 1), idaccmotive);

                            //if (currEpexp == null) return false;
                            //currEpexp["flagvariation"] = "S";
                            //addImpegnoToDict(currEpexp, idrelAsset);
                            //somethingfound = true;
                        }
                        else {
                            if (EP.isCosto(idacc)) {
                                if (!isBudgetEnabled(idacc)) continue;

                                var idrelAsset = BudgetFunction.GetIdForDocument(curr) + "§" + rAsset["idasset"] + "§" +
                                                 rAsset["idpiece"] + "§costo";
                                var currEpexp = bf.addEpExp(idreg,
                                    DBNull.Value, //idman
                                    importoAttuale,
                                    $"Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}",
                                    dataImpegni,
                                    idacc, idupb, idrelAsset, doc, curr["adate"],
                                    DBNull.Value, DBNull.Value, nphase, getIdEpExpByIdRelated(idrelAsset, nphase - 1),
                                    idaccmotive);

                                if (currEpexp == null) {
                                    //ShowMessage("Non è stato generato l'impegno di budget del cespite/accessorio n." +
                                    //rAsset["idasset"] + "/" + rAsset["idpiece"], "Errore");
                                    return false;
                                }

                                currEpexp["flagvariation"] = "N";
                                addImpegnoToDict(currEpexp, idrelAsset);
                                somethingfound = true;
                            }
                        }

                    }
                }


                if (!somethingfound) {
                    var obj = (nphase == 1) ? "preimpegno" : "impegno";
                    if (!silent) {
                        ShowMessage(
                            "Le causali di scarico degli inventari utilizzati non hanno  conti di costo collegati quindi nessun " +
                            obj + " è stato generato.",
                            "Avviso", false);
                    }

                }

            }

            return true;
        }

        public static int getMainRowNum(DataRow rDetail) {
            object idmain = DBNull.Value;
            if (rDetail.Table.Columns.Contains("rownum_main") && rDetail["rownum_main"] != DBNull.Value) {
                return CfgFn.GetNoNullInt32(rDetail["rownum_main"]);

            }

            return CfgFn.GetNoNullInt32(rDetail["rownum"]);

        }



        public static List<DataRow> getGroup(DataRow rDetail) {
            var list = new List<DataRow>();
            if (!rDetail.Table.Columns.Contains("rownum_main")) {
                list.Add(rDetail);
                return list;
            }

            int idmain = getMainRowNum(rDetail);
            //aggiunge alla lista prima tutti i precedenti in modo che l'ultimo sia quello di indice minore
            DataRow main = null;
            foreach (DataRow r in rDetail.Table.Select(null, "rownum asc")) {
                if (getMainRowNum(r) == idmain) {
                    if ((int) r["rownum"] == idmain) {
                        main = r;
                    }
                    else {
                        list.Add(r);
                    }
                }
            }
            if (main != null) {
                list.Add(main);
            }

            return list;

        }



        public static DataRow getFirstRow(DataRow rDetail) {
            var group = getGroup(rDetail);
            return group[0];
        }

        public static DataRow getLastRow(DataRow rDetail) {
            var group = getGroup(rDetail);

            return group[group.Count - 1];
        }


        /// <summary>
        /// Cerca la  versione immediatamente precedente in base al rownum_main
        /// </summary>
        /// <param name="rDetail"></param>
        /// <returns></returns>
        public static DataRow getPrevRow(DataRow rDetail) {
            if (!rDetail.Table.Columns.Contains("rownum_main")) return null;
            if (rDetail["start"] == DBNull.Value) return null; //se start è null non può esserci un precedente
            var group = getGroup(rDetail);
            group.Reverse();
            int myRowNum = CfgFn.GetNoNullInt32(rDetail["rownum"]);
            foreach (var r in group) {
                if (r["rownum_main"] == DBNull.Value) continue;
                if (rDetail["rownum_main"] == DBNull.Value)
                    return r; //il precedente del primo è il secondo della lista, il primo è lui stesso
                int rNum = (int) r["rownum"];
                if (rNum < myRowNum) return r;
            }

            return null;
        }

        /// <summary>
        /// Cerca la versione immediatamente successiva in base al rownum_main
        /// </summary>
        /// <param name="rDetail"></param>
        /// <returns></returns>
        public static DataRow getNextRow(DataRow rDetail) {
            if (!rDetail.Table.Columns.Contains("rownum_main")) return null;
            if (rDetail["rownum_main"] == DBNull.Value) return null; //il dettaglio principale non ha successivo
            int myRowNum = CfgFn.GetNoNullInt32(rDetail["rownum"]);
            var group = getGroup(rDetail);
            foreach (var r in group) {
                int rNum = (int) r["rownum"];
                if (r["rownum_main"] == DBNull.Value) return r;
                if (rNum > myRowNum) return r;
            }

            return null;
        }


        Dictionary<int, double> allProrataMan = new Dictionary<int, double>();

        //r)Annullo anno successivo Fatture da ricevere con causale COSTO/RICAVO (AUA-Buono dordine Commerciale)
        //Ho corretto il calcolo perchè Emilia mi ha fatto notare che va considerato il prorata dell'anno di origine, perchè la % di prorara cambia da un anno all'altro, e
        //dobbiamo chiudere l'importo dell'apertura...
        double abatableMandateRateOfYear(DataRow rContratto, DataRow rDettaglio) {
            DataRow _FirstRow = getFirstRow(rDettaglio);
            DateTime realStart =
                (DateTime) (_FirstRow["start"] == DBNull.Value ? rContratto["adate"] : _FirstRow["start"]);
            int annoOrigine = realStart.Year;

            if (allProrataMan.ContainsKey(annoOrigine)) return allProrataMan[annoOrigine];
            double prorata =
                CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("iva_prorata", QHS.CmpEq("ayear", annoOrigine), "prorata"));
            allProrataMan[annoOrigine] = prorata;
            return prorata;
        }

        decimal getTotaleImponibile(DataRow rDoc, DataRow rDettaglio) {

            if (rDoc.Table.TableName == "mandate") {
                double tassocambio = CfgFn.GetNoNullDouble(rDoc["exchangerate"]);
                double abatablerate = abatableMandateRateOfYear(rDoc, rDettaglio); //getProrataPerc();
                if (rDettaglio["flagmixed"].ToString().ToUpper() == "S") abatablerate *= getPromiscuoPerc();
                double scontoPerc = CfgFn.GetNoNullDouble(rDettaglio["discount"]);

                var rImponibile = CfgFn.GetNoNullDouble(rDettaglio["taxable"]);
                var iva = CfgFn.GetNoNullDouble(rDettaglio["tax"]);
                var quantitaConfezioni = CfgFn.GetNoNullDouble(rDettaglio["npackage"]);
                //var imponibileNonScontato = CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio);
                //var sconto = CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio * scontoPerc);
                //var imponibile = imponibileNonScontato - sconto;

				var imponibileScontato =
					CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio *
									  (1 - CfgFn.GetNoNullDouble(rDettaglio["discount"])));

				var ivaindetraibile = CfgFn.GetNoNullDouble(rDettaglio["unabatable"]);
                var ivadetraibilelorda = CfgFn.RoundValuta((iva - ivaindetraibile)); //iva già in EURO
                var ivadetraibile = CfgFn.RoundValuta(ivadetraibilelorda * abatablerate);
                var valoreIvaTotale = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(rDettaglio["tax"]));
                var valoreIvaDetraibile = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibile));
                var ivaIndetraibile = valoreIvaTotale - valoreIvaDetraibile;
                var ivaIndetraibileNoProrata = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivaindetraibile));
                var ivaIndetraibileDovutaAProrata = ivaIndetraibile - ivaIndetraibileNoProrata;

                var amount = CfgFn.RoundValuta((decimal) (imponibileScontato + iva - ivadetraibile));
                return amount;
            }
            
            if (rDoc.Table.TableName == "estimate") {
                double tassocambio = CfgFn.GetNoNullDouble(rDoc["exchangerate"]);
                var rImponibile = CfgFn.GetNoNullDouble(rDettaglio["taxable"]);
                var iva = CfgFn.GetNoNullDouble(rDettaglio["tax"]);
                var quantitaConfezioni = CfgFn.GetNoNullDouble(rDettaglio["number"]);
                var imponibile = CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio);
                var imponibileScontato =
                    CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio *
                                      (1 - CfgFn.GetNoNullDouble(rDettaglio["discount"])));

                //var sconto = CfgFn.GetNoNullDecimal(imponibile - imponibileScontato);
                var amount = CfgFn.GetNoNullDecimal(imponibileScontato);
                return amount;
            }

            return 0;
        }


        private double? proRataPerc;

        double getProrataPerc() {
            if (proRataPerc.HasValue) return proRataPerc.Value;
            proRataPerc =
                CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("iva_prorata", QHS.CmpEq("ayear", esercizio), "prorata"));
            return proRataPerc.Value;
        }

        private double? promiscuoPerc;

        double getPromiscuoPerc() {
            if (promiscuoPerc.HasValue) return promiscuoPerc.Value;
            promiscuoPerc =
                CfgFn.GetNoNullDouble(Conn.DO_READ_VALUE("iva_mixed", QHS.CmpEq("ayear", esercizio), "mixed"));
            return promiscuoPerc.Value;
        }

        q getFilterDetailForRateo(DataRow rDettaglio, string fieldEP, object idep) {
            if (idep != DBNull.Value) {
                return q.eq(fieldEP, idep);
            }

            return q.eq("idrelated", BudgetFunction.GetIdForDocument(getLastRow(rDettaglio)));
        }


        q getFilterDetailForRateo(DataRow rDettaglio, string fieldEP) {
            if (rDettaglio[fieldEP] != DBNull.Value) {
                return q.eq(fieldEP, getLastRow(rDettaglio)[fieldEP]);
            }

            return q.eq("idrelated", BudgetFunction.GetIdForDocument(getLastRow(rDettaglio)));
        }

        bool generaImpegniContrattoPassivoUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            object doc = "Ord." +
                         curr["idmankind"] + "/" +
                         curr["yman"].ToString().Substring(2, 2) + "/" +
                         curr["nman"].ToString().PadLeft(6, '0');

            bool somethingfound = false;
            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);
            string fAyear = QHS.CmpEq("ayear", esercizio);
            DataTable manDet = DS.Tables["mandatedetail"];

            double proRataPerc = getProrataPerc();
            double promiscuoPerc = getPromiscuoPerc();

            int yman = CfgFn.GetNoNullInt32(curr["yman"]);

            string filterdetails;
            DateTime primoGennaio = new DateTime(esercizio, 1, 1);
            DateTime trentunoDic = new DateTime(esercizio, 12, 31);

            string filterMainCurrent = QHC.CmpKey(curr);



            //Io dico che MAI deve ricalcolare i dettagli inseriti in anni successivi quindi rimuovo la condizione successiva
            //if (yman == esercizio) {                
            //Non ricalcola i dettagli inseriti in anni successivi
            string filterToRemove = QHC.AppAnd(filterMainCurrent, QHC.CmpGt("start", trentunoDic));
            foreach (DataRow rDettaglio in manDet.Select(filterToRemove)) {
                if (rDettaglio["idupb"] == DBNull.Value) continue;
                string idaccmotive = rDettaglio["idaccmotive"].ToString();
                if (idaccmotive == "") continue;
                if (rDettaglio["idepexp"] == DBNull.Value) continue;
                if (movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr)) continue;
                ripristinaMovimento(bf, rDettaglio, nphase);
                //bisognerà poi nel proseguio del metodo stare attenti a non creare roba su questi dettagli
            }

            //}

            string idrelated_mandate = BudgetFunction.GetIdForDocument(curr).ToLower();
            if (yman < esercizio) {
                //Non modifica gli impegni di budget per dettagli precedenti a quest'anno, ma dovrebbe farlo per i dettagli sostituiti. 
                foreach (DataRow rDettaglio in manDet.Select(filterMainCurrent)) {
                    if (rDettaglio["idupb"] == DBNull.Value) continue;
                    var idrel = BudgetFunction.GetIdForDocument(rDettaglio);
                    string idaccmotive = rDettaglio["idaccmotive"].ToString();
                    if (idaccmotive == "") continue;
                    if (rDettaglio["idepexp"] == DBNull.Value) continue;

                    if (rDettaglio["stop"] != DBNull.Value) {
                        //opera solo sui dettagli annullati
                        //if (((DateTime)rDettaglio["stop"]).Year <= esercizio) {
                        object idrelated_linked = Conn.DO_READ_VALUE("epexp",
                            QHS.CmpEq("idepexp", rDettaglio["idepexp"]), "idrelated");
                        if (idrelated_linked == null) idrelated_linked = "";
                        //probabilmente dovremmo distinguere, in questo caso, se stop è null o no. La modifica l'avevo scritta con 
                        // in mente stop not null
                        if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_mandate) &&
                            idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                            rDettaglio["idepexp"] =
                                DBNull.Value; //20-10-2020 per coerenza con l'attivo aggiungo questa istruzione
                            //var imp = bf.getEpExpRow(idrelated_linked, nphase);
                            //imp["idrelated"] = idrel;
                            //bf.setEpExpRow(idrelated_linked.ToString(), nphase, null);
                            //bf.setEpExpRow(idrel, nphase, imp);
                            //facendo continue verrà elaborato e potenzialmente azzerato
                            continue;
                        }
                    }

                    bool toConsider = movimentoDiTipoVariazione_1(rDettaglio, curr) ||
                                      movimentoDiTipoVariazionePerRateo(rDettaglio, curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr) ||
                                      variazionemovimentoDettaglioContrattoDaGenerare_3(rDettaglio, curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerareComeModificaPropria(rDettaglio,
                                          curr) ||
                                      movimentoCreazioneDettaglioContrattoDaGenerareComeModificaSuccessivo(rDettaglio,
                                          curr); //dovrebbe azzerare il movimento eventualmente presente qui

                    if (toConsider) continue;

                    ripristinaMovimento(bf, rDettaglio, nphase);

                }
            }

            //Opera solo sui dettagli che iniziano quest'anno o che hanno data inizio null se anno contratto=anno corrente
            // e che  hanno data stop null o in anni successivi


            bool scrittureAbilitate = isManKindEpEnabled(curr["idmankind"]); //true se non collegabile a fattura

            //Si occupa degli annullamenti dei dettagli o simili, effettuati quest'anno
            foreach (DataRow rDettaglio in manDet.Select(filterMainCurrent)) {
                bool annullaConVariazione =
                    variazioneAnnulloOAResiduoDaGenerare_5(rDettaglio,
                        curr); //attenzione qui dobbiamo distinguere se "a zero" o "al disponibile"
                bool annullaConMovimentoDiTipoVariazione = movimentoDiTipoVariazione_1(rDettaglio, curr);
                bool annullaConMovimentoDiTipoVariazioneRateo = movimentoDiTipoVariazionePerRateo(rDettaglio, curr);
                bool generaVariazioneSuMovimentoPerSostituzione = variazioneSuMovimento_4(rDettaglio, curr);
                bool annulloDaGenerare = annulloGenericoDaGenerare(rDettaglio, curr);
                bool modificaDaGenerare =
                    movimentoCreazioneDettaglioContrattoDaGenerareComeModificaSuccessivo(rDettaglio, curr);
                if (!(annullaConVariazione | annullaConMovimentoDiTipoVariazione |
                      generaVariazioneSuMovimentoPerSostituzione | annulloDaGenerare | modificaDaGenerare)) continue;

                //Considera solo i dettagli annullati nell'anno corrente
                int yearCurrentStop = ((DateTime) rDettaglio["stop"]).Year;
                if (yearCurrentStop != esercizio) continue;

                object epkind = rDettaglio["epkind"];


                //Dettaglio annullato nell'anno corrente
                DataRow nextRow = getNextRow(rDettaglio);
                DataRow prevRow = getPrevRow(rDettaglio);
                DataRow firstRow = getFirstRow(rDettaglio);
                DataRow lastRow = getLastRow(rDettaglio);

                DateTime realStart = (DateTime) (firstRow["start"] == DBNull.Value ? curr["adate"] : firstRow["start"]);
                int annoOrigine = realStart.Year;



                DateTime currStart =
                    (DateTime) (rDettaglio["start"] == DBNull.Value ? curr["adate"] : rDettaglio["start"]);
                int annoDettaglioCorrente = currStart.Year;

                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);

                if (rDettaglio["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }


                //13718  Se l'esercizio di annullo coincide con quello del contratto, deve essere ignorata la causale di annullo, anche se è valorizzata.

                if (annullaConVariazione) { //stop dell'anno e  anno originale=esercizio
                    DataRow rEpExp = bf.getEpExpRow(BudgetFunction.GetIdForDocument(rDettaglio), nphase);
                    if (rEpExp != null) {
                        var ry = bf.getEpExpYearById(rEpExp["idepexp"]);
                        var pagato = bf.getPagatoAnniPrecedenti(false, rEpExp, ry);
                        if (annoOrigine < esercizio) {
                            ripristinaMovimento(bf, rDettaglio, nphase);
                        }

                        if (rateoOFatturaARicevere(rDettaglio)) {
                            ry["amount"] = pagato[0];
                            for (int i = 2; i <= 5; i++) {
                                ry[$"amount{i}"] = pagato[i - 1];
                            }
                        }
                        else {
                            annullaImpegnoEP(bf, rDettaglio, rEpExp["idepexp"]);
                        }
                    }

                    somethingfound = true;
                    if (!rateoOFatturaARicevere(rDettaglio)) continue;
                }

                //Stiamo ora considerando impegni di anni precedenti
                object idaccmotiveannulment = rDettaglio["idaccmotiveannulment"];
                string whichDet = rDettaglio["detaildescription"].ToString();

                //if (modificaDaGenerare) {
                //	DataRow exEpExp = getEpMovYear(bf,lastRow,nphase);

                //	if (nphase == 2) {
                //		exEpExp = bf.getEpExpYearById(getLastRow(rDettaglio)["idepexp"]);
                //	}
                //	else {
                //		object paridepexp = Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", getLastRow(rDettaglio)["idepexp"]), "paridepexp");
                //		exEpExp = bf.getEpAccYearById(paridepexp);
                //	}

                //	if (exEpExp != null) {
                //		//modifica l'importo del movimento
                //		if (rateo(rDettaglio)) {
                //			decimal newValue = getTotaleImponibile(curr, lastRow);
                //			exEpExp.RejectChanges();
                //			var diff = newValue- CfgFn.GetNoNullDecimal(exEpExp["amount"]);
                //			for (int i = 2; i <= 5; i++) diff -= CfgFn.GetNoNullDecimal(exEpExp["amount" + i.ToString()]);
                //			diff = -diff;
                //			if (diff > 0) {
                //				decimal oldvalue = CfgFn.GetNoNullDecimal(exEpExp["amount"]);
                //				if (oldvalue >= diff) {
                //					exEpExp["amount"] = oldvalue - diff;
                //					diff = 0;
                //				}
                //				else {
                //					exEpExp["amount"] = 0;
                //					diff -= oldvalue;
                //				}

                //				for (int i = 2; i <= 5; i++) {
                //					if (diff > 0) {
                //						oldvalue = CfgFn.GetNoNullDecimal(exEpExp["amount" + i.ToString()]);
                //						if (oldvalue >= diff) {
                //							exEpExp["amount" + i.ToString()] = oldvalue - diff;
                //							diff = 0;
                //						}
                //						else {
                //							exEpExp["amount" + i.ToString()] = 0;
                //							diff -= oldvalue;
                //						}
                //					}
                //				}

                //			}
                //			else {
                //				exEpExp["amount"]=  CfgFn.GetNoNullDecimal(exEpExp["amount"])-diff;
                //			}



                //			//exEpAcc["amount"]= CfgFn.GetNoNullDecimal(exEpAcc["amount"]) + getTotaleImponibile(curr, lastRow)-getTotaleImponibile(curr,rDettaglio);
                //		}
                //		else {
                //			exEpExp["amount"]=  getTotaleImponibile(curr, lastRow);
                //		}

                //		somethingfound = true;
                //		continue;

                //	}
                //}
                if (modificaDaGenerare) {
                    DataRow exEpExp = getEpMovYear(bf, lastRow, nphase);

                    if (exEpExp != null) {
                        //modifica l'importo del movimento
                        if (rateo(rDettaglio)) {
                            decimal newValue = getTotaleImponibile(curr, lastRow);
                            //exEpExp["amount"]= newValue;

                            exEpExp.RejectChanges();
                            var diff = newValue - CfgFn.GetNoNullDecimal(exEpExp["amount"]);
                            for (int i = 2; i <= 5; i++)
                                diff -= CfgFn.GetNoNullDecimal(exEpExp["amount" + i.ToString()]);
                            diff = -diff;
                            if (diff > 0) {
                                decimal oldvalue;

                                for (int i = 5; i > 1; i--) {
                                    if (diff > 0) {
                                        oldvalue = CfgFn.GetNoNullDecimal(exEpExp["amount" + i.ToString()]);
                                        if (oldvalue >= diff) {
                                            exEpExp["amount" + i.ToString()] = oldvalue - diff;
                                            diff = 0;
                                        }
                                        else {
                                            exEpExp["amount" + i.ToString()] = 0;
                                            diff -= oldvalue;
                                        }
                                    }
                                }

                                oldvalue = CfgFn.GetNoNullDecimal(exEpExp["amount"]);
                                exEpExp["amount"] = oldvalue - diff;
                                //if (diff > 0) {
                                //	if (oldvalue >= diff) {
                                //		exEpExp["amount"] = oldvalue - diff;
                                //		diff = 0;
                                //	} else {
                                //		exEpExp["amount"] = 0;
                                //		diff -= oldvalue;
                                //	}
                                //}


                            }
                            else {
                                exEpExp["amount"] = CfgFn.GetNoNullDecimal(exEpExp["amount"]) - diff;
                            }



                            //exEpExp["amount"] = CfgFn.GetNoNullDecimal(exEpExp["amount"]) + getTotaleImponibile(curr, lastRow) - getTotaleImponibile(curr, rDettaglio);
                        }
                        else {
                            exEpExp["amount"] = getTotaleImponibile(curr, lastRow);
                        }

                        somethingfound = true;
                        continue;

                    }
                }

                if (nextRow == null && (scrittureAbilitate == false & !rateoOFatturaARicevere(rDettaglio))) {
                    //considera casi normali e non sostituzioni
                    //collegabile a fattura, non sostituisce altro dettaglio
                    if (idaccmotiveannulment != DBNull.Value) {
                        //se ha causale di annullo
                        ShowMessage(
                            $"Attenzione, il dettaglio {whichDet} non dovrebbe avere la causale di annullo.",
                            "Errore");
                        continue;
                    }

                    //Se collegabile a fattura  e NON c'è causale di annullo, annulla l'accertamento (come se fosse stato dell'anno)
                    DataRow rEpExp = bf.getEpExpRow(BudgetFunction.GetIdForDocument(rDettaglio), nphase);
                    if (rEpExp != null) {
                        annullaImpegnoEP(bf, rDettaglio, rEpExp["idepexp"]);
                    }

                    somethingfound = true;
                    continue;
                }

                if ((!scrittureAbilitate) && annoOrigine == esercizio && idaccmotiveannulment != DBNull.Value &&
                    nextRow != null) { //collegabile a fattura e con causale di annullo  //era 
                    ShowMessage(
                        $"Attenzione, il dettaglio {rDettaglio["detaildescription"]} non dovrebbe avere la causale di annullo.",
                        "Errore");
                    continue;
                }


                //Se non ha causale di annullo ed ha successore prende la causale del prossimo dettaglio
                if (nextRow != null && idaccmotiveannulment == DBNull.Value) {
                    idaccmotiveannulment = nextRow["idaccmotive"];
                    whichDet = nextRow["detaildescription"].ToString();
                }



                //Stiamo ora considerando impegni di anni precedenti con scritture abilitate
                if (idaccmotiveannulment == DBNull.Value) {
                    ShowMessage(
                        $"Attenzione, il dettaglio {rDettaglio["detaildescription"]} non ha la causale di annullo.",
                        "Errore");
                    continue;
                }

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveannulment);
                if (rEntries.Length != 1) {
                    ShowMessage(
                        $"La causale di annullo del dettaglio {rDettaglio["detaildescription"]} non è ben configurata.",
                        "Errore");
                    return false;
                }

                object idContoAnnullo = rEntries[0]["idacc"];
                if (!isBudgetEnabled(idContoAnnullo)) continue;
                var amount = getTotaleImponibile(curr, rDettaglio);
                if (nextRow != null &&
                    (generaVariazioneSuMovimentoPerSostituzione || annullaConMovimentoDiTipoVariazione)) {
                    // dall'importo di questo dettaglio sottraiamo il valore del dettaglio che rimane in vita 
                    if (annoDettaglioCorrente >= minimoAnnoImpegniDiBudget) {
                        amount -= getTotaleImponibile(curr, nextRow);
                    }
                    else { // Il contratto è di anni precedenti quando ancora non esisteva il budget: manca quindi 
                        // il movimento di budget sul dettaglio contratto che stiamo sostituendo. Dobbiamo creare un movimento di budget
                        // pari all'importo del dettaglio nuovo, che sostituisce il dettaglio corrente e lo dobbiamo associare al nuovo
                        amount = getTotaleImponibile(curr, nextRow);
                        if (dettaglioContrattoInseritoinFattura(nextRow)) {
                            // In questo caso invece posticipiamo la creazione del movimento di budget al momento dell'inserimento in fattura.
                            // Abbiamo già iniziato a generare i movimenti di budget sulla fattura, 
                            // dobbiamo continuare sulla fattura anche se  stiamo sostituendo questo dettaglio. Pertanto metto a zero l'importo
                            amount = 0;
                        }

                    }

                }

                var idregToConsider = curr["idreg"];
                if (idregToConsider == DBNull.Value) idregToConsider = rDettaglio["idreg"];

                if (EP.isRicavo(idContoAnnullo) && movimentoOppostoDaGenerare(rDettaglio, curr)) {
                    if (!rateoOFatturaARicevere(rDettaglio)) {
                        ripristinaMovimento(bf, rDettaglio, nphase);
                    }

                    if (rateoOFatturaARicevere(rDettaglio) && nextRow == null) { // importo come da scrittura
                        amount = CfgFn.GetNoNullDecimal( // verificare
                            Conn.readValue("entrydetail",
                                q.gt("amount", 0) & getFilterDetailForRateo(rDettaglio, "idepexp") & q.eq("idacc",
                                    rateo(rDettaglio) ? _idrateo_passivo : _idaccInvoicetoreceive),
                                "sum(amount)"));
                        if (amount == 0) {
                            ShowMessage(
                                $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rDettaglio["detaildescription"]} perchè marcato come fattura da ricevere");
                            continue;
                        }
                    }

                    if (amount == 0) continue;

                    var currEpAcc = bf.addEpAcc(idregToConsider, curr["idman"], amount,
                        rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                        idContoAnnullo, rDettaglio["idupb"], idrel, doc, curr["adate"],
                        DBNull.Value, DBNull.Value, //rDettaglio["competencystart"], rDettaglio["competencystop"], 
                        nphase, getIdEpAccByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                    if (currEpAcc == null) return false;
                    addAccertamentoToDict(currEpAcc, idrel);
                    if (nphase == 2) {
                        _listaAccertamenti[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpAcc;
                    }
                }
                else {
                    if (generaVariazioneSuMovimentoPerSostituzione) {
                        if (amount == 0) continue;
                        var idrelToUse = BudgetFunction.GetIdForDocument(lastRow);
                        var currEpExp = bf.addEpExp(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpExpByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        addImpegnoToDict(currEpExp, idrelToUse);


                        if (nphase == 2) {

                            if (annoDettaglioCorrente < minimoAnnoImpegniDiBudget) {
                                _listaImpegni[CfgFn.GetNoNullInt32(nextRow["rownum"])] = currEpExp;
                            }
                            else {
                                _listaImpegni[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpExp;
                            }
                        }
                    }

                    if (annullaConMovimentoDiTipoVariazione) {
                        if (amount == 0) continue;
                        var idrelToUse = idrel;
                        var currEpExp = bf.addEpExp(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpExpByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        currEpExp["flagvariation"] = "S";
                        addImpegnoToDict(currEpExp, idrelToUse);

                        if (nphase == 2) {
                            _listaImpegni[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpExp;
                        }
                    }

                    if (annullaConMovimentoDiTipoVariazioneRateo) {
                        amount = CfgFn.GetNoNullDecimal(
                            Conn.readValue("entrydetail",
                                q.gt("amount", 0) & q.eq("idepexp",
                                                      getLastRow(rDettaglio)[
                                                          "idepexp"]) //& getFilterDetailForRateo(rDettaglio,"idepexp")
                                                  & q.eq("idacc",
                                                      rateo(rDettaglio) ? _idrateo_passivo : _idaccInvoicetoreceive),
                                "sum(amount)"));
                        if (amount == 0) {
                            ShowMessage(
                                $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rDettaglio["detaildescription"]} perchè marcato come fattura da ricevere");
                            continue;
                        }

                        var idrelToUse = idrel;
                        var currEpExp = bf.addEpExp(idregToConsider, curr["idman"], amount,
                            rDettaglio["detaildescription"], (DateTime) rDettaglio["stop"],
                            idContoAnnullo, rDettaglio["idupb"], idrelToUse, doc, curr["adate"],
                            rDettaglio["competencystart"], rDettaglio["competencystop"], nphase,
                            getIdEpExpByIdRelated(idrel, nphase - 1), idaccmotiveannulment);
                        currEpExp["flagvariation"] = "S";
                        addImpegnoToDict(currEpExp, idrelToUse);
                        if (nphase == 2) {
                            _listaImpegni[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpExp;
                        }
                    }


                }

                //annullaAccertamentoEP(bf, rDettaglio);
                somethingfound = true;
                continue;
            }

            //Agisce su dettagli "attivi" da quest'anno, non agisce sui dettagli annullati o cancellati però
            foreach (DataRow rDettaglio in manDet.Select(filterMainCurrent)) {
                //Condizione: (2) anno origine di questo esercizio e non c'è successivo
                if (!movimentoCreazioneDettaglioContrattoDaGenerare_2(rDettaglio, curr)) continue;

                // Nei dettagli "attivi" deve considerare anche, come imponibile,iva e iva indetr., gli importi dei dettagli che lo annullano, nell'anno di origine in cui genera le scritture, per non generare casini

                object parentIdEpExp = DBNull.Value;
                if (rDettaglio.Table.Columns.Contains("idepexp_pre")) parentIdEpExp = rDettaglio["idepexp_pre"];

                if (nphase == 1 && parentIdEpExp != DBNull.Value) continue;

                //Crea l'impegno di budget collegato al dettaglio contratto
                object epkind = rDettaglio["epkind"];

                DataRow firstRow = getFirstRow(rDettaglio);
                DateTime dataOriginale = firstRow["start"] == DBNull.Value
                    ? (DateTime) curr["adate"]
                    : (DateTime) firstRow["start"];


                if (rDettaglio["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                string idaccmotive = firstRow["idaccmotive"].ToString();
                if (idaccmotive == "") {
                    ShowMessage("Causale non configurata bene per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                //Non tocca gli impegni di budget già presenti se la data del dettagli è precedente l'esercizio e il dettaglio è rateo o fattura a ricevere

                int ayearOriginale = ((DateTime) dataOriginale).Year;


                if (ayearOriginale < esercizio) dataOriginale = primoGennaio;

                DataRow prevRow = getPrevRow(rDettaglio);
                DataRow nextRow = getNextRow(rDettaglio);

                var idrel = BudgetFunction.GetIdForDocument(rDettaglio);

                int yearStartAccertamenti = dataOriginale.Year;


                if (prevRow != null && ayearOriginale < esercizio) {
                    //Ha già movimento di budget, che non va toccato. La variazione sarà stata fatta dal dettaglio precedente (fase di annullamento)
                    //Quindi non tocca questo accertamento di budget
                    if (rDettaglio["idepexp"] == DBNull.Value) continue;
                    bf.RemoveEpExp(rDettaglio["idepexp"]);
                    object paridepexp = Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", rDettaglio["idepexp"]),
                        "paridepexp");
                    bf.RemoveEpExp(paridepexp);
                    continue;
                }

                if (nextRow != null) {
                    //se ha riga successiva, allora il movimento sta nel successivo, e questo genera solo l'accertamento di variazione (in fase di annullamento)
                    continue;
                }


                ////Questa parte nel contratto attivo non c'è, per ora la lascio
                //// serve a non azzerare i  movimenti di budget di dettagli contratto rateo o fatture a ricevere
                //if (yearStartAccertamenti < esercizio && (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")
                //                      && yearStartAccertamenti < minimoAnnoImpegniDiBudget) {
                //	if (rDettaglio["idepexp"] == DBNull.Value) continue;
                //	bf.RemoveEpExp(rDettaglio["idepexp"]); //Annulla l'azzeramento implicito apportato
                //	object paridepexp = Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", rDettaglio["idepexp"]),
                //		"paridepexp");
                //	bf.RemoveEpExp(paridepexp);
                //	continue;
                //}




                int attivita = CfgFn.GetNoNullInt32(rDettaglio["flagactivity"]);

                int yearStartImpegno = dataOriginale.Year;


                if (prevRow != null && ayearOriginale < esercizio) {
                    //non ha e non deve avere impegno di budget, la variazione è stata gestita nel dettaglio annullato con l'accertamento di budget
                    //Questa parte la prendo dalla parte attiv, nella passiva non c'era, andava direttamente al continue
                    if (rDettaglio["idepexp"] == DBNull.Value) continue;
                    bf.RemoveEpExp(rDettaglio["idepexp"]);
                    object paridepexp = Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", rDettaglio["idepexp"]),
                        "paridepexp");
                    bf.RemoveEpExp(paridepexp);
                    continue;
                }

                if (nextRow != null) {
                    //non ha e non deve avere impegno di budget, la variazione è stata gestita implicitamente nella variazione di importo del dettaglio rimasto in vita
                    continue;
                }


                //Salta i dettagli annullati collegati a impegni di budget poi passati ad altri dettagli
                if (rDettaglio["idepexp"] != DBNull.Value) {
                    object idrelated_linked = getIdRelatedByEpExp(bf, rDettaglio["idepexp"]);
                    if (idrelated_linked == null) idrelated_linked = "";

                    //i contratti collegabili a fattura, di tipo rateo o fatture a ricevere di anni precedenti si comportano, nell'anno di annullo, come quelli non collegabili
                    // scritture abilitate = non collegabili, deve essere accomunata ai RateiFattRic
                    if (scrittureAbilitate || rateoOFatturaARicevere(rDettaglio)) {
                        if (yearStartImpegno < esercizio) {
                            var imp = bf.getEpExpRow(idrelated_linked, nphase);
                            imp["idrelated"] = idrel; //corregge l'idrelated dell'accertamento di budget
                            bf.setEpExpRow(idrelated_linked.ToString(), nphase, null);
                            bf.setEpExpRow(idrel, nphase, imp);
                            addImpegnoToDict(imp, idrel);
                            removeImpegnoFromDict(nphase,
                                idrelated_linked.ToString()); //rimuove il vecchio idrelated dal dizionario
                            //idrelatedDIAltroDettaglio = true;
                        }
                        else {
                            if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_mandate) &&
                                idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                                rDettaglio["idepexp"] =
                                    DBNull.Value; //scollega l'acc. di budget da questo dettaglio, non è il suo
                            }
                        }
                    }
                    else {
                        //in origine faceva sempre e solo questo al posto di if (scrittureAbilitate && nextRow==null) {
                        if (idrelated_linked.ToString().ToLower().StartsWith(idrelated_mandate) &&
                            idrelated_linked.ToString().ToLower() != idrel.ToLower()) {
                            rDettaglio["idepexp"] =
                                DBNull.Value; //scollega l'acc. di budget da questo dettaglio, non è il suo
                        }

                        // passando di qui implicitamente azzera il movimento di budget
                        //rDettaglio["idepacc"] = DBNull.Value;
                        //continue; //Non generare un nuovo movimento di budget su questo dettaglio, che è annullato
                    }

                }



                somethingfound = true;

                var rowToConsider = firstRow;
                while (getNextRow(rowToConsider) != null) {
                    var nextR = getNextRow(rowToConsider);
                    var startR = (DateTime) nextR["start"];
                    if (startR.Year != esercizio) break;
                    rowToConsider = nextR;
                }

                decimal amount = getTotaleImponibile(curr, rowToConsider);
                if (amount == 0) continue;

                //Nuovo campo che ove presente rappresenta l'importo del NUOVO dettaglio ossia quello che rimane in vita
                //if (rDettaglio["startamount"] != DBNull.Value) {
                //	amount = CfgFn.GetNoNullDecimal(rDettaglio["startamount"]);
                //}
                //if (rDettaglio["oldidepexp"] != DBNull.Value) {
                //	amount = 0; //??
                //}

                var idacc = getIdAccForDocument(rDettaglio, DBNull.Value); //Non accede al conto speciale
                if (idacc == null || idacc == DBNull.Value) {
                    ShowMessage($"Causale non configurata bene per il dettaglio {rDettaglio["detaildescription"]}");
                    return false;
                }

                if (!isBudgetEnabled(idacc)) continue;


                if (parentIdEpExp == DBNull.Value) {
                    parentIdEpExp = getIdEpExpByIdRelated(idrel, nphase - 1);
                }

                var idregToConsider = curr["idreg"];
                if (idregToConsider == DBNull.Value) idregToConsider = rDettaglio["idreg"];

                //Imposta l'impegno di budget relativo al dettaglio
                var currEpExp = bf.addEpExp(idregToConsider, curr["idman"], amount,
                    firstRow["detaildescription"], dataOriginale,
                    idacc, firstRow["idupb"], idrel, doc,
                    curr["adate"],
                    firstRow["competencystart"], firstRow["competencystop"], nphase, parentIdEpExp, idaccmotive);
                if (currEpExp == null) return false;
                addImpegnoToDict(currEpExp, idrel);
                if (nphase == 2 && currEpExp != null) {
                    _listaImpegni[CfgFn.GetNoNullInt32(rDettaglio["rownum"])] = currEpExp;
                }
            }

            foreach (DataRow rDettaglio in manDet.Select(QHC.AppAnd(filterMainCurrent, QHC.IsNotNull("start")))) {
                if (rDettaglio.RowState == DataRowState.Added) continue;
                if (rDettaglio["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente per il dettaglio " + rDettaglio["detaildescription"]);
                    return false;
                }

                if (rDettaglio["stop"] != DBNull.Value) {
                    int yearCurrentStop = ((DateTime) rDettaglio["stop"]).Year;
                    if (yearCurrentStop == esercizio) continue; //già annullato dal ciclo precedente
                }

                int yearCurrentStart = ((DateTime) rDettaglio["start"]).Year;
                if (yearCurrentStart > esercizio) {
                    //stiamo mettendo la data inizio ad un dettaglio ma con esercizio diverso da questo esercizio
                    // ossia è una azione manuale dell'utente
                    //annullaAccertamentoEP(bf, rDettaglio);
                    somethingfound = true;
                }
            }

            if (!somethingfound) {
                var obj = (nphase == 1) ? "preimpegno" : "impegno";
                if (!silent) {
                    ShowMessage(
                        $"Nessun {obj} è stato generato. Si consiglia di controllare se tutti i dettagli hanno la causale EP, le date del contratto e dei dettagli, o se vi sono movimenti collegati manualmente.",
                        "Avviso", false);
                }

                return true;
            }

            return true;
        }

        string getIdRelatedByEpExp(BudgetFunction bf, object idepexp) {
            var r = bf.getEpExpById(idepexp);
            object idrel = null;
            if (r != null) {
                idrel = r["idrelated"];
            }
            else {
                idrel = Conn.readValue("epexp", q.eq("idepexp", idepexp), "idrelated");
            }

            if (idrel == DBNull.Value) idrel = null;
            if (idrel == null) return null;
            return (string) idrel;
        }

        string getIdRelatedByEpAcc(BudgetFunction bf, object idepacc) {
            var r = bf.getEpAccById(idepacc);
            object idrel = null;
            if (r != null) {
                idrel = r["idrelated"];
            }
            else {
                idrel = Conn.readValue("epacc", q.eq("idepacc", idepacc), "idrelated");
            }

            if (idrel == DBNull.Value) idrel = null;
            if (idrel == null) return null;
            return (string) idrel;
        }

        bool generaAccertamentiFatturaUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            string filtroInvKind = QHC.CmpEq("idinvkind", curr["idinvkind"]);
            DataRow rTipoDoc = DS.Tables["invoicekind"].Select(filtroInvKind)[0];
            object doc = "Fatt." +
                         rTipoDoc["codeinvkind"] + "/" +
                         curr["yinv"].ToString().Substring(2, 2) + "/" +
                         curr["ninv"].ToString().PadLeft(6, '0');

            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);
            int flag = CfgFn.GetNoNullInt32(rTipoDoc["flag"]);
            int flagInvoice = CfgFn.GetNoNullInt32(curr["flagbit"]);
            bool bollaDoganale = ((flagInvoice & 1) != 0);
            bool flagvariazione = (flag & 4) != 0;
            string registroAV = tipoRegistroAV(curr["idinvkind"]);
            bool registroVendita = (registroAV == "V");
            bool movEntrata = ((flag & 1) != 0);
            bool registroAcquisto = !registroVendita;
            if (movEntrata != registroVendita) flagvariazione = !flagvariazione;
            int attivita = tipoAttivita(curr["idinvkind"]);
            bool istituzionale = (attivita == 1);
            bool fatturaSpedizioniere = ((flagInvoice & 2) != 0);
            bool commercialePromiscuo = (attivita != 1);
            if (registroAcquisto) flagvariazione = !flagvariazione;


            DataTable invKindYear = Conn.RUN_SELECT("invoicekindyear", "*", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idinvkind", curr["idinvkind"])), null, false);
            if (invKindYear.Select().Length == 0) {
                ShowMessage(
                    "Il tipo fattura selezionato non ha la configurazione per l'EP", "Errore");
                return false;
            }

            bool deferred = (curr["flagdeferred"].ToString().ToUpper() == "S");

            bool isFattRic = false;
            DataRow linkedProfServiceMain = null;
            int annoFattura = CfgFn.GetNoNullInt32(curr["yinv"]);

            if (!deferred) {
                //vecchia gestione fattura collegata direttamente a contratto, invece ora è sui dettagli
                DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.CmpKey(curr), null, false);
                if (profService != null && profService.Rows.Count == 1) {
                    linkedProfServiceMain = profService.Rows[0];
                }
            }

            DataRow tipoDocYear = invKindYear.Rows[0];
            object idreg = curr["idreg"];
            bool somethingfound = false;
            bool contractLinked = false;
            var tassoProRataAttuale = CfgFn.GetNoNullDouble(
                Conn.DO_READ_VALUE("invoicekindyearview",
                    QHS.AppAnd(QHS.CmpEq("idinvkind", curr["idinvkind"]), QHS.CmpEq("ayear", esercizio)),
                    "abatablerate", null));

            bool noMessage = false;
            bool contractlinked = false;
            foreach (DataRow rInvDet in DS.Tables["invoicedetail"].Select()) {
                bool usaProRataAnnoOrigineDettaglio = usaProRataAnnoOrigine;

                DataRow rEstimateDetail = null;
                if (rInvDet["idestimkind"] != DBNull.Value) {
                    DataTable tEstimDet = Conn.RUN_SELECT("estimatedetail", "*", null,
                        QHS.AppAnd(QHS.MCmp(rInvDet, "idestimkind", "yestim", "nestim"),
                            QHS.CmpEq("rownum", rInvDet["estimrownum"])), null, false);
                    if (tEstimDet.Rows.Count > 0) rEstimateDetail = tEstimDet.Rows[0];
                }

                DataRow rMandateDetail = null;
                if (rInvDet["idmankind"] != DBNull.Value) {
                    DataTable tManDet = Conn.RUN_SELECT("mandatedetail", "*", null,
                        QHS.AppAnd(QHS.MCmp(rInvDet, "idmankind", "yman", "nman"),
                            QHS.CmpEq("rownum", rInvDet["manrownum"])), null, false);
                    if (tManDet.Rows.Count > 0) rMandateDetail = tManDet.Rows[0];
                }

                isFattRic = false;
                DataRow linkedProfService = linkedProfServiceMain;

                if (rInvDet["ycon"] != DBNull.Value && rInvDet["ncon"] != DBNull.Value) {
                    //considera la parcella collegata al dettaglio
                    DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.MCmp(rInvDet, "ycon", "ncon"),
                        null, false);
                    if (profService != null && profService.Rows.Count == 1) {
                        linkedProfService = profService.Rows[0];

                    }
                }

                //task 8714 Implementazione sui contratti professionali della gestione automatica ratei e fatture da ricevere
                if (linkedProfService != null) {
                    int annoCProf = CfgFn.GetNoNullInt32(linkedProfService["ycon"]);
                    if (annoCProf < annoFattura) {
                        object epkind = linkedProfService["epkind"];
                        if (epkind != null) {
                            if (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")
                                isFattRic = true; //valorizza fatt.  a ricevere per professionali
                        }

                        noMessage = true;
                    }
                }

                //se c'è un ordine collegato di tipo fatture a ricevere, COMUNQUE non deve generare un impegno di budget
                // 10268: tranne per la parte iva indetraibile delle fatt. commerciali >>questa parte è di nuovo oggetto di richiesta, 
                //  è vero che ci sarà un nuovo impegno di budget ma solo per la parte di iva indetraibile dovuta ad un AUMENTO del prorata
                //  invece se il prorata diminuisce sarà generato un accertamento di budget
                if (rMandateDetail != null) {
                    noMessage = true;
                    object epkind = rMandateDetail["epkind"];
                    if (epkind != null && (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")) {
                        if (istituzionale) {
                            contractlinked = true;
                            continue;
                        }

                        isFattRic = true;
                    }

                }

                //se c'è un contratto collegato di tipo fatture a ricevere, COMUNQUE non deve generare un impegno di budget
                if (rEstimateDetail != null) {
                    object epkind = rEstimateDetail["epkind"];
                    if (epkind != null && (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")) {
                        contractLinked = true;
                        continue;
                    }
                }


                if (rEstimateDetail != null) {
                    string epkind = rEstimateDetail["epkind"].ToString().ToUpper();

                    int annoDettaglio = CfgFn.GetNoNullInt32(rInvDet["yestim"]);
                    object oDataInizio = rEstimateDetail["start"];
                    if (oDataInizio != DBNull.Value) {
                        annoDettaglio = ((DateTime) oDataInizio).Year;
                    }

                    //Fattura collegata a contratto attivo
                    //non dovrebbe generare nulla perchè l'accertamento l'ha generato nel c.attivo
                    if (annoDettaglio >= minimoAnnoImpegniDiBudget) {
                        contractLinked = true;
                        noMessage = true;
                        continue;
                    }

                    //else {
                    //    if (rEstimateDetail["idepacc"] != DBNull.Value && !isFattRic) {
                    //        //in questo caso non deve produrre imp. di budget a meno che non ci sia già un imp. di budget diverso collegato a questo dett.
                    //        if (rInvDet["idepacc"] == DBNull.Value ||
                    //            rInvDet["idepacc"].Equals(rEstimateDetail["idepacc"])) {
                    //            contractlinked = true;
                    //            noMessage = true;
                    //            continue; //come caso di sopra, di fatto lo trattiamo come se fosse nato dopo il primo anno di budget anche se non lo è
                    //        }
                    //    }
                    //}
                }

                //prorata per fatt. a ricevere, usato nell'impegno se fatto in anni precedenti
                double proRataFattRic = abatableRateOfYear(esercizio);


                int flagDetail = CfgFn.GetNoNullInt32(rInvDet["flagbit"]);
                bool valoreDoganale = ((flagDetail & 1) != 0);
                bool speseAnticipate = ((flagDetail & 2) != 0);



                if (!commercialePromiscuo) usaProRataAnnoOrigineDettaglio = false;

                if (isFattRic && istituzionale) {
                    noMessage = true;
                    continue; //10268
                }

                if (registroAcquisto) {
                    noMessage = true;
                    //task  10014  non consideriamo i contratti passivi creati prima del primo anno in cui si sono gestiti gli impegni di budget
                    if (rMandateDetail != null) {
                        // successivamente 10416: conta data inizi dett.
                        int annoDettaglio = CfgFn.GetNoNullInt32(rInvDet["yman"]);
                        object oDataInizio = rMandateDetail["start"];
                        if (oDataInizio != null && oDataInizio != DBNull.Value) {
                            annoDettaglio = ((DateTime) oDataInizio).Year;
                        }

                        if (annoDettaglio >= minimoAnnoImpegniDiBudget) {
                            //Fattura collegata a contratto passivo
                            //I dett. associati a c.passivo di tipo "valore doganale" con iva indetraibile generano imp. di budget, gli altri no
                            //if (CfgFn.GetNoNullDecimal(rInvDet["unabatable"]) == 0) {
                            //    contractlinked = true;
                            //    if (!usaProRataAnnoOrigineDettaglio)
                            //        continue; //se deve usare il prorata anno origine non può uscire già da ora
                            //}
                            if ((valoreDoganale == false) && !isFattRic) {
                                contractlinked = true;
                                noMessage = true;
                                continue; //se non è fatt. a ricevere e nemmeno rateo e nemmeno val. doganale non deve generare alcun accertamento 18/1/2018
                            }
                        }

                        if (annoDettaglio > 0) {
                            string idrelatedMandateDetail = BudgetFunction.GetIdForDocument(rMandateDetail);
                            int primoAnnoScrittura = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("entrydetail",
                                QHS.CmpEq("idrelated", idrelatedMandateDetail), "min(yentry)"));
                            if (primoAnnoScrittura != 0) {
                                annoDettaglio = primoAnnoScrittura;
                            }
                            else {
                                annoDettaglio = esercizio;
                            }

                            proRataFattRic = abatableRateOfYear(annoDettaglio);
                        }

                    }
                }

                if ((flagDetail & 1) != 0) valoreDoganale = true;
                //I dettagli fattura di tipo "spese anticipate spedizioniere" NON generano mov. di budget - a prescindere
                if ((flagDetail & 2) != 0) {
                    noMessage = true;
                    continue;
                }

                if (flagvariazione && rInvDet["idepexp"] != DBNull.Value && rInvDet["idepacc"] != DBNull.Value) {
                    somethingfound = true;
                    continue;
                }

                object idaccmotive = rInvDet["idaccmotive"];
                if (idaccmotive == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {rInvDet["detaildescription"]} non ha la causale");
                    return false;
                }

                if (rInvDet["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente nel dettaglio " + rInvDet["detaildescription"]);
                    return false;
                }

                somethingfound = true;
                var rImponibile = CfgFn.GetNoNullDouble(rInvDet["taxable"]);
                var iva = CfgFn.GetNoNullDouble(rInvDet["tax"]);

                var quantita = CfgFn.GetNoNullDouble(rInvDet["npackage"]);
                var scontoPerc = CfgFn.GetNoNullDouble(rInvDet["discount"]);
                var imponibileD = CfgFn.RoundValuta(rImponibile * quantita * tassocambio * (1 - scontoPerc));
                var imponibile = Convert.ToDecimal(imponibileD);

                double ivaindetraibile; //CfgFn.GetNoNullDouble(Rinvdet["unabatable"]);
                double ivadetraibileProRataCorrente; //CfgFn.RoundValuta(ivadetraibilelorda*abatablerate);		
                double ivadetraibileFattRic;


                if (istituzionale) {
                    ivaindetraibile = CfgFn.RoundValuta(iva);
                    ivadetraibileProRataCorrente = 0;
                    ivadetraibileFattRic = 0;
                }
                else {
                    ivaindetraibile = CfgFn.GetNoNullDouble(rInvDet["unabatable"]);
                    var ivadetraibilelorda =
                        CfgFn.RoundValuta(
                            (iva - ivaindetraibile)); //CfgFn.RoundValuta((iva-ivaindetraibile)*tassocambio);
                    ivadetraibileProRataCorrente = CfgFn.RoundValuta(ivadetraibilelorda * tassoProRataAttuale);
                    ivadetraibileFattRic = CfgFn.RoundValuta(ivadetraibilelorda * proRataFattRic);
                }

                var ivaIndetraibileNoProrata = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivaindetraibile));
                var valoreIvaTotale = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(rInvDet["tax"]));

                var valoreIvaDetraibileAttuale =
                    CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileProRataCorrente));
                decimal valoreIvaDetraibileFattRic = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileFattRic));

                var ivaIndetraibileAttuale = valoreIvaTotale - valoreIvaDetraibileAttuale;
                decimal ivaIndetraibileFattRic = valoreIvaTotale - valoreIvaDetraibileFattRic;


                var ivaIndetraibileDovutaAProrataAttuale = ivaIndetraibileAttuale - ivaIndetraibileNoProrata;
                decimal ivaIndetraibileDovutaAProrataFattRic = ivaIndetraibileFattRic - ivaIndetraibileNoProrata;

                //se positiva c'è più costo rispetto a quanto impegnato e bisognerà creare un impegno aggiuntivo (o variazione di quello esist.),
                //  se negativa ce n'è di meno e ci sarà un ricavo
                decimal diffProrata = ivaIndetraibileDovutaAProrataAttuale - ivaIndetraibileDovutaAProrataFattRic;

                if (!commercialePromiscuo) diffProrata = 0;

                //ivadetraibile corrente = iva totale - iva indetraibile corrente
                // diffProrata = iva indetr. corrente - iva indetr. fattric
                // ivadetraibile corrente = iva totale - iva indetr. fattric - diffProrata
                // ivadetraibile corrente = iva detraibile fatt.ric  - diffProrata
                // se applichiamo il codice in if(usaProRataAnnoOrigine) ->
                //     ivadetraibile "corrente" = ivaDetraibilePerDettaglio - diffProrata
                //     iva indetraibile "corrente" = ivaIndetraibileDovutaAProrataFattRic + diffProrata
                //     è coerente perchè la somma deve sempre fare l'iva totale
                if (!commercialePromiscuo) {
                    usaProRataAnnoOrigineDettaglio = false;
                }

                if (!isFattRic) {
                    usaProRataAnnoOrigineDettaglio = false;
                }

                var idaccRicavo = getIdAccForDocument(rInvDet, rInvDet["idupb"]);


                if (valoreDoganale) {
                    imponibile = 0;
                    imponibileD = 0; //l'imponibile non è considerato per gli impegni sul valore doganale
                }

                if (isFattRic && commercialePromiscuo) {
                    imponibile = 0;
                    imponibileD = 0; //l'imponibile non è considerato per gli impegni sulle fatt. commerciali a ricevere
                    idaccmotive = getIdAccMotiveRicavoProrata();
                    idaccRicavo = getIdAccFromMotive(idaccmotive, rInvDet["idupb"]);
                }


                var valoreRicavo = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(imponibile));
                if (registroAcquisto) {
                    if (!valoreDoganale) {
                        if (isFattRic && commercialePromiscuo) {
                            valoreRicavo = 0; //l'unico costo ammissibile in questo caso è la diff. per prorata
                            ivaIndetraibileDovutaAProrataAttuale = 0;
                            ivaIndetraibileNoProrata = 0;
                        }
                        else {
                            valoreRicavo += ivaIndetraibileDovutaAProrataAttuale;
                            valoreRicavo += ivaIndetraibileNoProrata;
                            ivaIndetraibileDovutaAProrataAttuale = 0;
                            ivaIndetraibileNoProrata = 0;
                        }
                    }
                }



                if (idaccRicavo == null || idaccRicavo == DBNull.Value) {
                    ShowMessage("Causale non configurata bene per il dettaglio " + rInvDet["detaildescription"]);
                    return false;
                }

                if (!isBudgetEnabled(idaccRicavo)) continue;

                bool dettVariazione = flagvariazione;
                if (valoreRicavo < 0) {
                    ivaIndetraibileDovutaAProrataAttuale = -ivaIndetraibileDovutaAProrataAttuale;
                    ivaIndetraibileNoProrata = -ivaIndetraibileNoProrata;
                    dettVariazione = !dettVariazione;
                    valoreRicavo = -valoreRicavo;
                }

                //valoreRicavo -= sconto;
                var idupbRicavo = rInvDet["idupb"];
                var idrelated = BudgetFunction.GetIdForDocument(rInvDet);
                var idrelatedDiffProrata = BudgetFunction.GetIdForDocument(rInvDet) + "§diffprorata";

                object idaccmotiveDiffProrata =
                    diffProrata > 0 ? getIdAccMotiveCostoProrata() : getIdAccMotiveRicavoProrata();
                object idaccCostoRicavoDiffProrata = getIdAccFromMotive(idaccmotiveDiffProrata, rInvDet["idupb"]);

                if (!EP.isRicavo(idaccRicavo)) {
                    noMessage = true;
                }

                if (valoreRicavo != 0 && EP.isRicavo(idaccRicavo)) {
                    var currRicavo = bf.addEpAcc(idreg, getIdMan(idupbRicavo),
                        valoreRicavo,
                        rInvDet["detaildescription"], curr["adate"],
                        idaccRicavo, idupbRicavo,
                        idrelated, doc, curr["adate"],
                        rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                        getIdEpAccByIdRelated(idrelated, nphase - 1), idaccmotive);
                    if (dettVariazione) currRicavo["flagvariation"] = "S";
                    addAccertamentoToDict(currRicavo, idrelated);
                    if (nphase == 2) {
                        _listaAccertamenti[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currRicavo;
                    }
                }

                if (usaProRataAnnoOrigineDettaglio && diffProrata < 0) {
                    var currEpAccProRataDiff = bf.addEpAcc(idreg, getIdMan(idupbRicavo),
                        -diffProrata,
                        rInvDet["detaildescription"], curr["adate"],
                        idaccCostoRicavoDiffProrata, idupbRicavo,
                        idrelatedDiffProrata, doc, curr["adate"],
                        rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                        getIdEpAccByIdRelated(idrelatedDiffProrata, nphase - 1), idaccmotiveDiffProrata);
                    if (dettVariazione) currEpAccProRataDiff["flagvariation"] = "S";
                    addAccertamentoToDict(currEpAccProRataDiff, idrelatedDiffProrata);
                    if (nphase == 2) {
                        _listaAccertamenti[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currEpAccProRataDiff;
                        _listaAccertamentiDiffProrata.Add(CfgFn.GetNoNullInt32(rInvDet["rownum"]), true);
                    }
                }

            }


            if (!somethingfound && !contractLinked && !noMessage) {
                string obj = (nphase == 1) ? "preaccertamento" : "accertamento";
                if (!silent) {
                    ShowMessage(
                        "Nessun dettaglio di competenza dell'anno ha la causale EP quindi nessun " + obj +
                        " è stato generato.", "Avviso", false);

                }

                return true;
            }

            if (contractLinked && !somethingfound && !silent && !noMessage) {
                ShowMessage(
                    "Gli accertamenti sono già stati generati in fase di contratto attivo", "Avviso", false);

            }

            if (contractLinked && somethingfound && !silent && !noMessage) {
                ShowMessage(
                    "Alcuni accertamenti sono già stati generati in fase di contratto attivo", "Avviso", false);
            }

            return true;
        }



        bool generaImpegniFatturaUnaFase(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            string filtroInvKind = QHC.CmpEq("idinvkind", curr["idinvkind"]);
            if (DS.Tables["invoicekind"].Select(filtroInvKind).Length == 0) return false;
            DataRow rTipoDoc = DS.Tables["invoicekind"].Select(filtroInvKind)[0];
            object doc = "Fatt." +
                         rTipoDoc["codeinvkind"] + "/" +
                         curr["yinv"].ToString().Substring(2, 2) + "/" +
                         curr["ninv"].ToString().PadLeft(6, '0');

            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);

            int attivita = tipoAttivita(curr["idinvkind"]);
            string registroAV = tipoRegistroAV(curr["idinvkind"]);
            bool istituzionale = (attivita == 1);
            bool isIntraCom = (curr["flagintracom"].ToString().ToUpper() != "N");
            bool isFlagReverseCharge = (curr["flag_reverse_charge"].ToString().ToUpper() != "N");
            bool applicaSplitPaymentCommerciale =
                (curr["flag_enable_split_payment"].ToString().ToUpper() == "S") && //split payment
                (attivita != 1) && //commerciale o promiscuo
                (registroAV == "A"); //acquisto
            int flag = CfgFn.GetNoNullInt32(rTipoDoc["flag"]);
            bool registroVendita = (registroAV == "V");
            bool movEntrata = ((flag & 1) != 0);
            bool registroAcquisto = !registroVendita;
            bool flagvariazione = (flag & 4) != 0;
            if (registroVendita) flagvariazione = !flagvariazione;
            if (movEntrata != registroVendita) flagvariazione = !flagvariazione;
            bool commercialePromiscuo = (attivita != 1);

            DataTable invKindYear = Conn.RUN_SELECT("invoicekindyear", "*", null,
                QHS.AppAnd(QHS.CmpEq("ayear", esercizio), QHS.CmpEq("idinvkind", curr["idinvkind"])), null, false);
            if (invKindYear.Select().Length == 0) {
                ShowMessage($"Il tipo fattura selezionato {curr["idinvkind"]} non ha la configurazione per l'EP",
                    "Errore");
                return false;
            }

            DataRow tipoDocYear = invKindYear.Rows[0];
            bool noMessage = false;

            object idaccUnabatable = DBNull.Value;
            //costo iva indetraibile (per chi calcola riga per riga e gestisce tale conto)
            if (isIntraCom || isFlagReverseCharge) {
                idaccUnabatable = tipoDocYear["idacc_unabatable_intra"];
            }

            if (applicaSplitPaymentCommerciale) {
                idaccUnabatable = tipoDocYear["idacc_unabatable_split"];
            }

            if (!(isIntraCom || applicaSplitPaymentCommerciale || isFlagReverseCharge) ||
                idaccUnabatable == DBNull.Value) {
                idaccUnabatable = tipoDocYear["idacc_unabatable"];
            }

            bool deferred = (curr["flagdeferred"].ToString().ToUpper() == "S");
            bool isFattRic = false;
            //parcella collegata alla fattura
            DataRow linkedProfServiceMain = null;
            int annoFattura = CfgFn.GetNoNullInt32(curr["yinv"]);

            if (!deferred) {
                //vecchia gestione fattura collegata direttamente a contratto, invece ora è sui dettagli
                DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.CmpKey(curr), null, false);
                if (profService != null && profService.Rows.Count == 1) {
                    linkedProfServiceMain = profService.Rows[0];
                }
            }

            object idreg = curr["idreg"];

            bool somethingfound = false;
            bool contractlinked = false;

            var tassoProRataAttuale = CfgFn.GetNoNullDouble(
                Conn.DO_READ_VALUE("invoicekindyearview",
                    QHS.AppAnd(QHS.CmpEq("idinvkind", curr["idinvkind"]), QHS.CmpEq("ayear", esercizio)),
                    "abatablerate", null));


            //Ciclo sui dettagli
            foreach (DataRow rInvDet in DS.Tables["invoicedetail"].Select()) {
                if (nphase == 1 && rInvDet["idepexp_pre"] != DBNull.Value) continue;

                bool usaProRataAnnoOrigineDettaglio = usaProRataAnnoOrigine; // true con la nuova gestione

                DataRow rMandateDetail = null;
                if (rInvDet["idmankind"] != DBNull.Value) {
                    DataTable tManDet = Conn.RUN_SELECT("mandatedetail", "*", null,
                        QHS.AppAnd(QHS.MCmp(rInvDet, "idmankind", "yman", "nman"),
                            QHS.CmpEq("rownum", rInvDet["manrownum"])), null, false);
                    if (tManDet.Rows.Count > 0) rMandateDetail = tManDet.Rows[0];
                }

                if (flagvariazione && rInvDet["idepexp"] != DBNull.Value && rInvDet["idepacc"] != DBNull.Value) {
                    //nota di variazione con impegno e accertamento di budget già collegati, non fa nulla e annulla la scrittura (sic)
                    somethingfound = true;
                    continue;
                }

                #region calcolo isFattRic

                isFattRic = false;
                bool isProrata = false;
                //parcella collegata al dettaglio o alla fattura 
                DataRow linkedProfService = linkedProfServiceMain; //parcella collegata alla fattura

                if (rInvDet["ycon"] != DBNull.Value && rInvDet["ncon"] != DBNull.Value) {
                    //considera la parcella collegata al DETTAGLIO ove esista
                    DataTable profService = Conn.RUN_SELECT("profservice", "*", null, QHS.MCmp(rInvDet, "ycon", "ncon"),
                        null, false);
                    if (profService != null && profService.Rows.Count == 1) {
                        linkedProfService = profService.Rows[0];
                    }
                }

                //task 8714 Implementazione sui contratti professionali della gestione automatica ratei e fatture da ricevere
                //TODO: ragionare su cosa fare nell'ambito della nuova gestione in cui andremo a generare un imp. di budget
                // nel primo anno di budget, comunque, per la parcella professionale. In questo caso
                //  l'unica differenza potrebbe essere per il discorso del prorata
                if (linkedProfService != null) {
                    int annoCProf = CfgFn.GetNoNullInt32(linkedProfService["ycon"]);
                    if (annoCProf < annoFattura) {
                        object epkind = linkedProfService["epkind"];
                        if (epkind != null) {
                            if (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")
                                isFattRic = true; //valorizza fatt.  a ricevere per professionali
                        }
                    }

                    //12382:applico questa parte solo se non è rateo o fatt.ric
                    if (annoCProf < minimoAnnoImpegniDiBudget && !isFattRic) {
                        usaProRataAnnoOrigineDettaglio = false;
                    }
                }

                //prorata per fatt. a ricevere, usato nell'impegno se fatto in anni precedenti
                double proRataFattRic = abatableRateOfYear(esercizio);

                int flagDetail = CfgFn.GetNoNullInt32(rInvDet["flagbit"]);
                bool valoreDoganale = ((flagDetail & 1) != 0);
                bool speseAnticipate = ((flagDetail & 2) != 0);

                // se c'è un ordine collegato di tipo fatture a ricevere, COMUNQUE non deve generare un impegno di budget
                // 10268: tranne per la parte iva indetraibile delle fatt. commerciali >>questa parte è di nuovo oggetto di richiesta, 
                //  è vero che ci sarà un nuovo impegno di budget ma solo per la parte di iva indetraibile dovuta ad un AUMENTO del prorata
                //  invece se il prorata diminuisce sarà generato un accertamento di budget
                if (rMandateDetail != null) {
                    object epkind = rMandateDetail["epkind"];
                    if (epkind != null && (epkind.ToString().ToUpper() == "F" || epkind.ToString().ToUpper() == "R")) {
                        if (istituzionale) {
                            contractlinked = true;
                            continue;
                        }

                        isFattRic = true;
                        isProrata = epkind.ToString().ToUpper() == "R";
                        noMessage = true;
                    }
                }
                bool soloDiffProrata = false;

                //task  10014  non consideriamo i contratti passivi creati prima del primo anno in cui si sono gestiti gli impegni di budget
                if (rMandateDetail != null) {
                    string epkind = rMandateDetail["epkind"].ToString().ToUpper();

                    // successivamente 10416: conta data inizio dett.
                    int annoDettaglio = CfgFn.GetNoNullInt32(rInvDet["yman"]);
                    object oDataInizio = rMandateDetail["start"];
                    if (oDataInizio != null && oDataInizio != DBNull.Value) {
                        annoDettaglio = ((DateTime) oDataInizio).Year;
                    }

                    if (annoDettaglio >= minimoAnnoImpegniDiBudget) {
                        //Fattura collegata a contratto passivo
                        //I dett. associati a c.passivo di tipo "valore doganale" con iva indetraibile generano imp. di budget, gli altri no
                        //if (CfgFn.GetNoNullDecimal(rInvDet["unabatable"]) == 0 && isFattRic) {
                        //    contractlinked = true;
                        //    soloDiffProrata = true;
                        //    if (!usaProRataAnnoOrigineDettaglio) continue;      //se deve usare il prorata anno origine non può uscire già da ora
                        //}

                        if ((valoreDoganale == false) && !isFattRic) {
                            contractlinked = true;
                            noMessage = true;
                            continue; //se non è fatt. a ricevere e nemmeno rateo e nemmeno val. doganale non deve generare alcun impegno 18/1/2018
                        }
                    }
                    else {
                        ////12382 - generazione impegni di budget SUL CONTRATTO PASSIVO nel primo anno di budget e non più in fattura
                        //if (rMandateDetail["idepexp"] != DBNull.Value && !isFattRic) {
                        //    //in questo caso non deve produrre imp. di budget a meno che non ci sia già un imp. di budget diverso collegato a questo dett.
                        //    if (rInvDet["idepexp"] == DBNull.Value ||
                        //        rInvDet["idepexp"].Equals(rMandateDetail["idepexp"])) {
                        //        contractlinked = true;
                        //        noMessage = true;
                        //        continue; //come caso di sopra, di fatto lo trattiamo come se fosse nato dopo il primo anno di budget anche se non lo è
                        //    }
                        //}
                        if (!isFattRic) usaProRataAnnoOrigineDettaglio = false;
                    }

                    if (annoDettaglio > 0) {
                        string idrelatedMandateDetail = BudgetFunction.GetIdForDocument(rMandateDetail);
                        int primoAnnoScrittura = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("entrydetail",
                            QHS.CmpEq("idrelated", idrelatedMandateDetail), "min(yentry)"));
                        if (primoAnnoScrittura != 0) {
                            annoDettaglio = primoAnnoScrittura;
                        }
                        else {
                            annoDettaglio = esercizio;
                        }

                        proRataFattRic = abatableRateOfYear(annoDettaglio);
                    }
                }

                #endregion

                if (!commercialePromiscuo) usaProRataAnnoOrigineDettaglio = false;

                if (isFattRic && istituzionale) continue; //10268

                if ((flagDetail & 1) != 0) valoreDoganale = true;

                //I dettagli fattura di tipo "spese anticipate spedizioniere" NON generano impegni di budget - a prescindere
                if ((flagDetail & 2) != 0) continue;

                object idaccmotive = rInvDet["idaccmotive"];
                if (idaccmotive == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {rInvDet["detaildescription"]} non ha la causale");
                    return false;
                }

                if (rInvDet["idupb"] == DBNull.Value) {
                    ShowMessage("UPB non presente nel dettaglio " + rInvDet["detaildescription"]);
                    return false;
                }

                somethingfound = true;

                var rImponibile = CfgFn.GetNoNullDouble(rInvDet["taxable"]);
                var iva = CfgFn.GetNoNullDouble(rInvDet["tax"]);

                var quantita = CfgFn.GetNoNullDouble(rInvDet["npackage"]);
                double scontoPerc = CfgFn.GetNoNullDouble(rInvDet["discount"]);
                var imponibileD = CfgFn.RoundValuta(rImponibile * quantita * tassocambio * (1 - scontoPerc));
                var imponibile = Convert.ToDecimal(imponibileD);
                if (valoreDoganale) {
                    imponibile = 0;
                    imponibileD = 0; //l'imponibile non è considerato per gli impegni sul valore doganale
                }

                if (isFattRic && commercialePromiscuo) {
                    imponibile = 0;
                    imponibileD = 0; //l'imponibile non è considerato per gli impegni sulle fatt. commerciali a ricevere
                }


                double ivaindetraibile; //CfgFn.GetNoNullDouble(Rinvdet["unabatable"]);
                double ivadetraibileProRataCorrente; //CfgFn.RoundValuta(ivadetraibilelorda*abatablerate);		
                double ivadetraibileFattRic;

                if (istituzionale) {
                    ivaindetraibile = CfgFn.RoundValuta(iva);
                    ivadetraibileProRataCorrente = 0;
                    ivadetraibileFattRic = 0;
                }
                else {
                    ivaindetraibile = CfgFn.GetNoNullDouble(rInvDet["unabatable"]);
                    var ivadetraibilelorda =
                        CfgFn.RoundValuta(
                            (iva - ivaindetraibile)); //CfgFn.RoundValuta((iva-ivaindetraibile)*tassocambio);
                    ivadetraibileProRataCorrente = CfgFn.RoundValuta(ivadetraibilelorda * tassoProRataAttuale);
                    ivadetraibileFattRic = CfgFn.RoundValuta(ivadetraibilelorda * proRataFattRic);
                }

                var ivaIndetraibileNoProrata = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivaindetraibile));
                var valoreIvaTotale = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(rInvDet["tax"]));

                //iva = iva detraibile, da movimentarsi con il conto normale dell'iva (acq/vendite)
                var ivaDetraibileAttuale = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileProRataCorrente));
                decimal valoreIvaDetraibileFattRic = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(ivadetraibileFattRic));

                var ivaIndetraibileAttuale = valoreIvaTotale - ivaDetraibileAttuale;
                decimal ivaIndetraibileFattRic = valoreIvaTotale - valoreIvaDetraibileFattRic;

                var ivaIndetraibileDovutaAProrataAttuale = ivaIndetraibileAttuale - ivaIndetraibileNoProrata;
                decimal ivaIndetraibileDovutaAProrataFattRic = ivaIndetraibileFattRic - ivaIndetraibileNoProrata;


                //se positiva c'è più costo rispetto a quanto impegnato e bisognerà creare un impegno aggiuntivo (o variazione di quello esist.),
                //  se negativa ce n'è di meno e ci sarà un ricavo
                decimal diffProrata = ivaIndetraibileDovutaAProrataAttuale - ivaIndetraibileDovutaAProrataFattRic;

                if (!usaProRataAnnoOrigineDettaglio || !commercialePromiscuo) diffProrata = 0;

                //DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
                //if (account.Length == 0) continue;
                //DataRow rAccount = account[0];
                //string idacc = rAccount["idacc"].ToString();
                var idaccCost = getIdAccForDocument(rInvDet, rInvDet["idupb"]);
                if (idaccCost == null || idaccCost == DBNull.Value) {
                    ShowMessage("Causale non configurata bene per il dettaglio " + rInvDet["detaildescription"]);
                    return false;
                }

                if (!valoreDoganale && usaProRataAnnoOrigineDettaglio && diffProrata > 0) {
                    idaccmotive = getIdAccMotiveCostoProrata();
                    idaccCost = getIdAccFromMotive(idaccmotive, rInvDet["idupb"]);
                }



                var idAccIvaIndetraibileNoProrata = idaccUnabatable;
                var idAccIvaIndetraibileDovutaAProrata = idaccUnabatable;

                if (idAccIvaIndetraibileDovutaAProrata == DBNull.Value || (valoreDoganale == false)) {
                    idAccIvaIndetraibileDovutaAProrata = idaccCost;
                    idAccIvaIndetraibileNoProrata = idaccCost;
                }


                //Mette insieme le cose associate agli stessi conti

                // valore_costo = da usare unitamente al conto di costo
                //   è pari all'imponibile + iva indetraibile ove il conto dell'iva indetraibile non sia configurato
                var valoreCosto = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(imponibile));

                object idaccmotiveCostoProrata = DBNull.Value;
                object idaccCostoProrata = DBNull.Value;
                object preimpegno = (rInvDet["idepexp_pre"] == DBNull.Value || nphase == 1)
                    ? null
                    : rInvDet["idepexp_pre"];

                if (!valoreDoganale) {
                    if (((isFattRic || diffProrata != 0) && commercialePromiscuo) || soloDiffProrata) {
                        valoreCosto = 0; //l'unico costo ammissibile in questo caso è la diff. per prorata
                        ivaIndetraibileDovutaAProrataAttuale = 0;
                        ivaIndetraibileNoProrata = 0;
                        idaccmotiveCostoProrata = getIdAccMotiveCostoProrata();
                        idaccCostoProrata = getIdAccFromMotive(idaccmotiveCostoProrata, rInvDet["idupb"]);
                    }
                    else {
                        // 1) Se registro acquisti deve sommare al costo dell'imponibile il costo dell'iva indetraibile dovuta
                        // all'applicazione del prorata e dell'iva indetraibile oggettiva (campo "unabatable")

                        // 2)Se invece si tratta una fattura registrata su registro vendite e si è specificata una causale di costo,
                        // invece di una causale di ricavo,
                        // deve generare un impegno di budget ma non deve sommare al valore costo nè l'iva indetraibile
                        // dovuta a prorata, nè l'iva indetraibile oggettiva "unabatable" (vedere task 15748). Il costo 
                        // deve essere pari all'imponibile

                        if (registroAcquisto) {

                            if (idAccIvaIndetraibileDovutaAProrata == DBNull.Value ||
                                idAccIvaIndetraibileDovutaAProrata.Equals(idaccCost)) {
                                valoreCosto += ivaIndetraibileDovutaAProrataAttuale;
                                ivaIndetraibileDovutaAProrataAttuale = 0;
                            }

                            if (idAccIvaIndetraibileNoProrata == DBNull.Value ||
                                idAccIvaIndetraibileNoProrata.Equals(idaccCost)) {
                                valoreCosto += ivaIndetraibileNoProrata;
                                ivaIndetraibileNoProrata = 0;
                            }

                            if (idAccIvaIndetraibileNoProrata.Equals(idAccIvaIndetraibileDovutaAProrata)) {
                                ivaIndetraibileDovutaAProrataAttuale += ivaIndetraibileNoProrata;
                                ivaIndetraibileNoProrata = 0;
                            }
                        }
                        else {
                            ivaIndetraibileDovutaAProrataAttuale = 0;
                            ivaIndetraibileNoProrata = 0;
                        }
                    }
                }





                bool impegnoPrincipale = true;
                if (!isBudgetEnabled(idaccCost)) impegnoPrincipale = false;

                bool dettVariazione = flagvariazione;
                if (valoreCosto < 0) {
                    ivaIndetraibileDovutaAProrataAttuale = -ivaIndetraibileDovutaAProrataAttuale;
                    ivaIndetraibileNoProrata = -ivaIndetraibileNoProrata;
                    valoreCosto = -valoreCosto;
                    dettVariazione = !dettVariazione;
                }
                //valoreCosto -= sconto;

                var idupbCosto = rInvDet["idupb"];
                var idrelated = BudgetFunction.GetIdForDocument(rInvDet);
                var idrelatedDiffProrata = BudgetFunction.GetIdForDocument(rInvDet) + "§diffprorata";
                var idrelatedProrata = idrelated + "§prorata";
                var idrelatedNoProrata = idrelated + "§noprorata";

                if (idAccIvaIndetraibileDovutaAProrata != DBNull.Value && ivaIndetraibileDovutaAProrataAttuale > 0) {
                    var currEpExpUnabatableProrata = bf.addEpExp(idreg, getIdMan(idupbCosto),
                        ivaIndetraibileDovutaAProrataAttuale,
                        rInvDet["detaildescription"], curr["adate"],
                        idAccIvaIndetraibileDovutaAProrata, idupbCosto,
                        idrelatedProrata, doc, curr["adate"],
                        rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                        preimpegno ?? getIdEpExpByIdRelated(idrelatedProrata, nphase - 1), idaccmotive);
                    if (dettVariazione) currEpExpUnabatableProrata["flagvariation"] = "S";
                    addImpegnoToDict(currEpExpUnabatableProrata, idrelatedProrata);

                    if (nphase == 2) {
                        _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currEpExpUnabatableProrata;
                    }
                }

                if (idAccIvaIndetraibileNoProrata != DBNull.Value && ivaIndetraibileNoProrata > 0) {
                    var currEpExpUnabatableNoProrata = bf.addEpExp(idreg, getIdMan(idupbCosto),
                        ivaIndetraibileNoProrata,
                        rInvDet["detaildescription"], curr["adate"],
                        idAccIvaIndetraibileNoProrata, idupbCosto,
                        idrelatedNoProrata, doc, curr["adate"],
                        rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                        preimpegno ?? getIdEpExpByIdRelated(idrelatedNoProrata, nphase - 1), idaccmotive);
                    if (dettVariazione) currEpExpUnabatableNoProrata["flagvariation"] = "S";
                    addImpegnoToDict(currEpExpUnabatableNoProrata, idrelatedNoProrata);
                    if (nphase == 2) {
                        _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currEpExpUnabatableNoProrata;
                    }
                }

                if (usaProRataAnnoOrigineDettaglio && diffProrata > 0) {
                    var currEpExpProRataDiff = bf.addEpExp(idreg, getIdMan(idupbCosto),
                        diffProrata,
                        rInvDet["detaildescription"], curr["adate"],
                        idaccCostoProrata, idupbCosto,
                        idrelatedDiffProrata, doc, curr["adate"],
                        rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                        preimpegno ?? getIdEpExpByIdRelated(idrelatedDiffProrata, nphase - 1), idaccmotiveCostoProrata);
                    if (dettVariazione) currEpExpProRataDiff["flagvariation"] = "S";
                    addImpegnoToDict(currEpExpProRataDiff, idrelatedDiffProrata);
                    if (nphase == 2) {
                        _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currEpExpProRataDiff;
                        _listaImpegniDiffProrata.Add(CfgFn.GetNoNullInt32(rInvDet["rownum"]), true);
                    }
                }

                if (EP.isCosto(idaccCost)) {
                    if (valoreCosto != 0 && (valoreDoganale == false) && impegnoPrincipale) {
                        var currCosto = bf.addEpExp(idreg, getIdMan(idupbCosto),
                            valoreCosto,
                            rInvDet["detaildescription"], curr["adate"],
                            idaccCost, idupbCosto,
                            idrelated, doc, curr["adate"],
                            rInvDet["competencystart"], rInvDet["competencystop"], nphase,
                            preimpegno ?? getIdEpExpByIdRelated(idrelated, nphase - 1),
                            idaccmotive); //, rInvDet["idepexp"] 
                        if (dettVariazione) currCosto["flagvariation"] = "S";
                        addImpegnoToDict(currCosto, idrelated);
                        if (nphase == 2) {
                            _listaImpegni[CfgFn.GetNoNullInt32(rInvDet["rownum"])] = currCosto;
                        }
                    }
                }
                else {
                    noMessage = true;
                }
            }

            if (!somethingfound && !contractlinked && !noMessage) {
                string obj = (nphase == 1) ? "preimpegno" : "impegno";
                if (!silent) {
                    ShowMessage(
                        "Nessun dettaglio di competenza dell'anno ha la causale EP quindi nessun " + obj +
                        " è stato generato.",
                        "Avviso", false);
                }

                return true;
            }

            if (contractlinked && !somethingfound && !silent) {
                ShowMessage(
                    "Gli impegni sono stati già generati in fase di contratto passivo",
                    "Avviso", false);
            }

            if (contractlinked && somethingfound && !silent) {
                ShowMessage(
                    "Alcuni impegni sono stati già generati in fase di contratto passivo",
                    "Avviso", false);
            }


            return true;
        }


        List<InfoContributi> getInfoImpegniForContributo(object idser, object taxcode, decimal importo,
            string idrelated,
            string idrelMain, int nphase) {
            if (_teh == null) {
                _teh = new TaxEntryHelper(Conn);
            }

            var tipoRit = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(taxcode));
            if (tipoRit == null) {
                ShowMessage("Non esiste nel db la ritenuta avente codice " + taxcode, "Errore");
                return null;
            }

            DataRow taxMotive = tipoRit.getInfo(CfgFn.GetNoNullInt32(idser));
            if (taxMotive == null) {
                ShowMessage(
                    "Il codice " + tipoRit.taxRef() + " non è il codice di una ritenuta configurata per l'EP.",
                    "Errore");
                return null;
            }

            var result = new List<InfoContributi>();

            if (nphase == 1) {
                //Prima su fase 1 usciva sempre con null ma non è corretto, infatti l'idrelated sarebbe sbagliato in alcuni rami
                object idepexpPreimpegnoCheck = getIdEpExpByIdRelated(idrelated, 1);
                //ora non esce più subito se non trova l'impegno con idrelated specifico, perchè ce ne potrebbe essere uno ancora più specifico
                if (idepexpPreimpegnoCheck != DBNull.Value) {
                    result.Add(new InfoContributi(DBNull.Value, importo, DBNull.Value, idrelated, null, DBNull.Value));
                    return result;
                }

            }

            object idepexpPreimpegno;
            if (preimpegniAccorpati.ContainsKey(idrelated)) {
                idepexpPreimpegno = DBNull.Value;
            }
            else {
                idepexpPreimpegno = getIdEpExpByIdRelated(idrelated, 1);
            }

            bool parentEpExp = false;
            if ((idepexpPreimpegno == null || idepexpPreimpegno == DBNull.Value) && (nphase == 2)) {

                idepexpPreimpegno = getIdEpExpByIdRelated(idrelMain, 1);
                if (idepexpPreimpegno != DBNull.Value) {
                    parentEpExp = true;
                }
            }



            //if ((idepexpPreimpegno == null || idepexpPreimpegno == DBNull.Value) && UsaImpegniDiBudget &&
            //    esercizio > 2015) {
            //    ShowMessage(
            //        "Non è stato trovato alcun preimpegno di budget per il contributo " + tipoRit.taxRef(), "Errore");
            //    return null;
            //}
            if (idepexpPreimpegno == null) {
                idepexpPreimpegno = DBNull.Value;
            }

            object idaccmotiveTouse;
            var idregauto = _rConfig["idregauto"];
            if (taxMotive["idaccmotive_debit"] != DBNull.Value) {
                idaccmotiveTouse = taxMotive["idaccmotive_debit"];
                var contiContribFinanz = EP.GetAccMotiveDetails(idaccmotiveTouse);
                if (contiContribFinanz.Length == 0) {
                    ShowMessage(
                        "Non è stata ben configurata la causale del debito del contributo " + tipoRit.taxRef(),
                        "Errore");
                    return null;
                }

                result.Add(new InfoContributi(DBNull.Value, importo, idregauto, idrelated, null, idepexpPreimpegno));
            }
            else {
                idaccmotiveTouse = taxMotive["idaccmotive_pay"];
                var contiContribFinanz = EP.GetAccMotiveDetails(idaccmotiveTouse);
                if (contiContribFinanz.Length == 0) {
                    ShowMessage(
                        "Non è stata ben configurata la causale del debito del contributo " + tipoRit.taxRef(),
                        "Errore");
                    return null;
                }

                var regs = _teh.GetIdRegFor(taxcode, DBNull.Value, DBNull.Value);
                if (regs == null || regs.Rows.Count == 0) {
                    ShowMessage(
                        "Anagrafica per il versamento non trovata per la ritenuta di tipo " + tipoRit.taxRef(),
                        "Errore");
                    return null;
                }

                foreach (DataRow registry in regs.Rows) {
                    var amountToConsider = CfgFn.RoundValuta(importo * CfgFn.GetNoNullDecimal(registry["quota"]));
                    var idreg = CfgFn.GetNoNullInt32(registry["idreg"]);
                    var idrel = idrelated + "§" + idreg;
                    //if (regs.Rows.Count == 1) idrel = idrelated;
                    object idepexpPreimpegnoCheck =
                        nphase == 1 ? DBNull.Value : getIdEpExpByIdRelated(idrelated + "§" + idreg, 1);
                    if (idepexpPreimpegnoCheck != DBNull.Value) {
                        idepexpPreimpegno = idepexpPreimpegnoCheck;
                        idrel = idrelated + "§" + idreg;
                        parentEpExp = false;
                    }

                    if (nphase == 1 && getIdEpExpByIdRelated(idrel, 1) == DBNull.Value) {
                        if (getIdEpExpByIdRelated(idrelated, 1) != DBNull.Value) {
                            idrel = idrelated;
                        }
                        else {
                            //if (getIdEpExpByIdRelated(idrelMain, 1) != DBNull.Value) idrel = idrelMain;
                            if (regs.Rows.Count == 1) {
                                //idrel = idrelated;//salviamo il salvabile?
                            }
                        }
                    }

                    if (nphase == 2 && idepexpPreimpegno == DBNull.Value) {
                        if (getIdEpExpByIdRelated(idrelated, 1) != DBNull.Value) {
                            idrel = idrelated;
                            idepexpPreimpegno = getIdEpExpByIdRelated(idrelated, 1);
                        }
                        else {
                            //if (getIdEpExpByIdRelated(idrelMain, 1) != DBNull.Value) idrel = idrelMain;
                            if (regs.Rows.Count == 1) {
                                //idrel = idrelated;//salviamo il salvabile?
                            }
                        }
                    }

                    result.Add(
                        new InfoContributi(DBNull.Value, amountToConsider, idreg, idrel, null, idepexpPreimpegno));
                }
            }

            return result;
        }

        Hashtable preimpegniAccorpati = new Hashtable();

        private bool generaImpegniMissioneUnaFase(BudgetFunction bf, DataRow curr, int nphase) {

            object doc =
                "Miss. " +
                curr["yitineration"].ToString().Substring(2, 2) + "/" +
                curr["nitineration"].ToString().PadLeft(6, '0');


            object idaccmotive = curr["idaccmotive"];
            if (idaccmotive == DBNull.Value) {
                ShowMessage("Manca la causale principale per la missione", "Avviso");
                return false;
            }

            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Selezionare prima l'UPB", "Avviso");
                return false;
            }

            object datarif = curr["datecompleted"];
            string idrelated = BudgetFunction.GetIdForDocument(curr);

            decimal amount = CfgFn.GetNoNullDecimal(curr["totalgross"]);
            decimal sommaspese = 0;
            DataTable anticipi = Conn.RUN_SELECT("itinerationrefund", "*", null,
                QHS.AppAnd(QHS.CmpEq("iditineration", curr["iditineration"]), QHS.CmpEq("flagadvancebalance", "A")),
                null, false);
            DataTable saldi = Conn.RUN_SELECT("itinerationrefund", "*", null,
                QHS.AppAnd(QHS.CmpEq("iditineration", curr["iditineration"]), QHS.CmpEq("flagadvancebalance", "S")),
                null, false);
            decimal sommaSpeseAnticipo = MetaData.SumColumn(anticipi, "amount");
            decimal sommaSpeseSaldo = MetaData.SumColumn(saldi, "amount");
            if (getFaseAnticipoMissione(curr)) {
                if (!getRealFaseAnticipoMissione(curr)) {
                    amount = amount - sommaSpeseSaldo + sommaSpeseAnticipo;
                }



                foreach (DataRow rSpesa in anticipi.Rows) {
                    var causaleSpesaAnticipo = Conn.DO_READ_VALUE("itinerationrefundkind",
                        QHS.CmpEq("iditinerationrefundkind", rSpesa["iditinerationrefundkind"]),
                        "idaccmotive", null);
                    if (causaleSpesaAnticipo == DBNull.Value) continue;
                    DataRow[] contiSpesa = bf.GetAccMotiveDetails(causaleSpesaAnticipo);
                    if (contiSpesa.Length == 0) continue;
                    object idaccSpesa = contiSpesa[0]["idacc"];


                    decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                    decimal indennitaSupp = CfgFn.GetNoNullDecimal(rSpesa["extraallowance"]);
                    importospesa += indennitaSupp;

                    sommaspese += importospesa;

                    string idrel = idrelated + "§" + rSpesa["nrefund"];
                    DataRow rAnticipo = bf.addEpExp(curr["idreg"], curr["idman"], importospesa, curr["description"],
                        datarif,
                        idaccSpesa, curr["idupb"], idrel, doc,
                        curr["adate"], curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrel, nphase - 1),
                        causaleSpesaAnticipo);
                    addImpegnoToDict(rAnticipo, idrel);


                }
            }
            else {

                foreach (DataRow rSpesa in saldi.Rows) {
                    var causaleSpesaSaldo = Conn.DO_READ_VALUE("itinerationrefundkind",
                        QHS.CmpEq("iditinerationrefundkind", rSpesa["iditinerationrefundkind"]),
                        "idaccmotive", null);
                    if (causaleSpesaSaldo == DBNull.Value) continue;
                    DataRow[] contiSpesa = bf.GetAccMotiveDetails(causaleSpesaSaldo);
                    if (contiSpesa.Length == 0) continue;
                    object idaccSpesa = contiSpesa[0]["idacc"];

                    decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                    decimal indennitaSupp = CfgFn.GetNoNullDecimal(rSpesa["extraallowance"]);
                    importospesa += indennitaSupp;

                    sommaspese += importospesa;
                    string idrel = idrelated + "§" + rSpesa["nrefund"];
                    DataRow rRefund = bf.addEpExp(curr["idreg"], curr["idman"], importospesa, curr["description"],
                        datarif,
                        idaccSpesa, curr["idupb"], idrel, doc, curr["adate"],
                        curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrel, nphase - 1),
                        causaleSpesaSaldo);
                    addImpegnoToDict(rRefund, idrel);
                }
            }

            DataRow rItinerationSetup = _rConfig;

            decimal admincarkm = CfgFn.GetNoNullDecimal(curr["admincarkm"]);
            decimal admincarkmcost = CfgFn.GetNoNullDecimal(curr["admincarkmcost"]);
            decimal admincartotalcost = CfgFn.RoundValuta(admincarkm * admincarkmcost);
            if ((admincartotalcost != 0) && (rItinerationSetup["idaccmotive_admincar"] != DBNull.Value)
                                         && rItinerationSetup["idaccmotive_admincar"].ToString() !=
                                         idaccmotive.ToString()
            ) {
                object idaccmotiveAc = rItinerationSetup["idaccmotive_admincar"];
                DataRow[] contiAc = bf.GetAccMotiveDetails(idaccmotiveAc);
                if (contiAc.Length > 0) {
                    sommaspese += admincartotalcost;
                    foreach (DataRow conti in contiAc) {
                        DataRow rAdmin = bf.addEpExp(curr["idreg"], curr["idman"], admincartotalcost,
                            curr["description"], datarif,
                            conti["idacc"], curr["idupb"], idrelated + "§admin", doc, curr["adate"],
                            curr["start"], curr["stop"], nphase,
                            getIdEpExpByIdRelated(idrelated + "§admin", nphase - 1), idaccmotiveAc);
                        addImpegnoToDict(rAdmin, idrelated + "§admin");
                    }
                }

            }

            decimal owncarkm = CfgFn.GetNoNullDecimal(curr["owncarkm"]);
            decimal owncarkmcost = CfgFn.GetNoNullDecimal(curr["owncarkmcost"]);
            decimal owncartotalcost = CfgFn.RoundValuta(owncarkm * owncarkmcost);
            if ((owncartotalcost != 0) && (rItinerationSetup["idaccmotive_owncar"] != DBNull.Value)
                                       && rItinerationSetup["idaccmotive_owncar"].ToString() !=
                                       idaccmotive.ToString()) {

                object idaccmotiveOc = rItinerationSetup["idaccmotive_owncar"];
                DataRow[] contiOc = bf.GetAccMotiveDetails(idaccmotiveOc);
                if (contiOc.Length > 0) {
                    sommaspese += owncartotalcost;
                    foreach (DataRow conti in contiOc) {
                        DataRow rOwn = bf.addEpExp(curr["idreg"], curr["idman"], owncartotalcost, curr["description"],
                            datarif,
                            conti["idacc"], curr["idupb"], idrelated + "§own", doc, curr["adate"],
                            curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelated + "§own", nphase - 1),
                            idaccmotiveOc);
                        addImpegnoToDict(rOwn, idrelated + "§own");
                    }
                }

            }


            decimal footkm = CfgFn.GetNoNullDecimal(curr["footkm"]);
            decimal footkmcost = CfgFn.GetNoNullDecimal(curr["footkmcost"]);
            decimal foottotalcost = CfgFn.RoundValuta(footkm * footkmcost);
            if ((foottotalcost != 0) && (rItinerationSetup["idaccmotive_foot"] != DBNull.Value)
                                     && rItinerationSetup["idaccmotive_foot"].ToString() != idaccmotive.ToString()) {
                object idaccmotiveF = rItinerationSetup["idaccmotive_foot"];
                DataRow[] contiF = bf.GetAccMotiveDetails(idaccmotiveF);
                if (contiF.Length > 0) {
                    sommaspese += foottotalcost;
                    foreach (DataRow conti in contiF) {
                        DataRow rAnt = bf.addEpExp(curr["idreg"], curr["idman"], foottotalcost, curr["description"],
                            datarif,
                            conti["idacc"], curr["idupb"], idrelated + "§foot", doc, curr["adate"],
                            curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelated + "§foot", nphase - 1),
                            idaccmotiveF);
                        addImpegnoToDict(rAnt, idrelated + "§foot");
                    }
                }
            }

            amount -= sommaspese;

            decimal sommaRitNonConfig = 0;
            DataTable itinerationtax = Conn.RUN_SELECT("itinerationtax", "*", null,
                QHS.CmpEq("iditineration", curr["iditineration"]), null, false);
            foreach (DataRow rRitenuta in itinerationtax.Rows) {
                decimal importoritenuta = CfgFn.GetNoNullDecimal(rRitenuta["admintax"]);
                if (importoritenuta <= 0) continue;
                string idrel = BudgetFunction.GetIdForDocument(rRitenuta);


                TaxInfo tipoRit = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(rRitenuta["taxcode"]));


                object idaccmotiveCost = getIdaccmotiveCostForTax(curr["idser"], rRitenuta["taxcode"]);
                if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive) && nphase == 1) { // 
                    //Non può accorpare se esiste già la fase generata come distinta
                    DataRow checkExist = bf.getEpExpRowLike(idrel, nphase);
                    if (checkExist == null) {
                        sommaRitNonConfig += importoritenuta;
                        //accorpa il preimpegno dei contributi a quello principale
                        preimpegniAccorpati.Add(idrel, true);
                        continue;
                    }
                }



                if (idaccmotiveCost == DBNull.Value) {
                    idaccmotiveCost = idaccmotive;
                }




                DataRow[] contiCostoContributo = bf.GetAccMotiveDetails(idaccmotiveCost);
                if (contiCostoContributo.Length == 0) {
                    ShowMessage("Contributo " + tipoRit.taxRef() + " mal configurato.", "Errore");
                    return false;
                }

                object idAccCostoContributo = contiCostoContributo[0]["idacc"];

                var lista = getInfoImpegniForContributo(curr["idser"], rRitenuta["taxcode"], importoritenuta, idrel,
                    idrelated, nphase);
                if (lista == null) {
                    return false;
                }

                foreach (var contr in lista) {
                    DataRow rExpRit = bf.addEpExp(contr.idreg, curr["idman"], contr.importo, curr["description"],
                        datarif,
                        idAccCostoContributo, curr["idupb"], contr.idrelated, doc, curr["adate"],
                        curr["start"], curr["stop"], nphase, contr.idepexp, idaccmotiveCost);
                    addImpegnoToDict(rExpRit, contr.idrelated);
                }

            }

            amount += sommaRitNonConfig;
            if (amount != 0) {
                DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
                if (account.Length == 0) {
                    ShowMessage("La causale della missione non è ben configurata", "Errore");
                    return false;
                }

                DataRow rAccount = account[0];
                object idaccMain = rAccount["idacc"];

                if (isBudgetEnabled(idaccMain)) {
                    string idrelMain = BudgetFunction.GetIdForDocument(curr);
                    DataRow rMain = bf.addEpExp(curr["idreg"], curr["idman"], amount, curr["description"], datarif,
                        idaccMain, curr["idupb"], idrelMain, doc, curr["adate"],
                        curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelMain, nphase - 1), idaccmotive);
                    addImpegnoToDict(rMain, idrelMain);
                }


            }

            return true;


        }


        private bool generaImpegniFondoEconomale(BudgetFunction bf, DataRow curr, int nphase) {

            object idreg = curr["idreg"];

            object idpettycash = curr["idpettycash"];
            string filterpcash = QHS.AppAnd(QHS.CmpEq("idpettycash", idpettycash), QHS.CmpEq("ayear", esercizio));
            DataTable pCaschSetup = Conn.RUN_SELECT("pettycashsetup", "*", null, filterpcash, null, false);
            if (pCaschSetup.Rows.Count == 0) {
                ShowMessage("Non è stata inserita la configuraz. del fondo economale per quest'anno", "Errore");
                return false;
            }

            DataRow pCash = pCaschSetup.Rows[0];
            object idpettycashreg = pCash["registrymanager"];
            if (idreg == DBNull.Value) {
                if (idpettycashreg != DBNull.Value) {
                    idreg = idpettycashreg;
                }
                else {
                    ShowMessage(
                        "Non è stato scelto un Percipiente(scheda EP)  e manca anche nella config. del fondo economale , non verrà generato alcun impegno di budget");
                    return false;
                }
            }

            object doc = "Op. Fondo Econ. " +
                         curr["idpettycash"] + "/" +
                         curr["yoperation"].ToString().Substring(2, 2) + "/" +
                         curr["noperation"].ToString().PadLeft(6, '0');


            object idaccmotCost = curr["idaccmotive_cost"];
            if (idaccmotCost == DBNull.Value) {
                ShowMessage("Non è stata selezionata la causale di costo", "Errore");
                return false;
            }

            object idupb = curr["idupb"];
            if ((idupb == DBNull.Value) && (curr["idexp"] != DBNull.Value)) {
                idupb = Conn.DO_READ_VALUE("expenseyear",
                    QHS.AppAnd(QHS.CmpEq("idexp", curr["idexp"]), QHS.CmpEq("ayear", esercizio)), "idupb");
            }

            if (idupb == DBNull.Value) {
                ShowMessage("Selezionare prima l'UPB", "Avviso");
                return false;
            }


            decimal amount = CfgFn.GetNoNullDecimal(curr["amount"]);

            DataRow[] account = bf.GetAccMotiveDetails(idaccmotCost.ToString());
            if (account.Length == 0) {
                ShowMessage(
                    "La causale di costo scelta non ha conti associati, non verrà generato alcun impegno di budget",
                    "Avviso");
                return false;
            }

            DataRow rAccount = account[0];

            string idaccMain = rAccount["idacc"].ToString();

            if (!isBudgetEnabled(idaccMain)) return false;

            object idman = curr["idman"];
            if (idman == DBNull.Value) {
                idman = getIdMan(idupb);
            }

            string idrelated = BudgetFunction.GetIdForDocument(curr);
            string CurrDescription = curr["description"].ToString();
            if (CurrDescription.Length > 150) {
                CurrDescription = CurrDescription.Substring(0, 150);
            }

            DataRow currEpExp = bf.addEpExp(idreg, idman, amount,
                CurrDescription, curr["adate"],
                idaccMain, idupb, idrelated, doc, curr["adate"],
                DBNull.Value, DBNull.Value, nphase, DBNull.Value, idaccmotCost);
            addImpegnoToDict(currEpExp, idrelated);

            return true;
        }



        private bool generaImpegniContrattoDipendente(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Selezionare prima l'UPB", "Avviso");
                return false;
            }

            string idrelMain = BudgetFunction.GetIdForDocument(curr);
            object doc = "Altri Compensi " +
                         curr["ycon"].ToString().Substring(2, 2) + "/" +
                         curr["ncon"].ToString().PadLeft(6, '0');

            object idaccmotive = curr["idaccmotive"];
            if ((idaccmotive == null) || (idaccmotive == DBNull.Value))
                return false;
            string nomeDebito = nomeCompensoDipendente(curr);

            decimal amount = CfgFn.GetNoNullDecimal(curr["feegross"]);

            decimal sommaRitNonConfig = 0;
            string filterContract = QHS.CmpKey(curr);
            DataTable wageadditiontax = Conn.RUN_SELECT("wageadditiontax", "*", null, filterContract, null, false);
            foreach (DataRow rRitenuta in wageadditiontax.Select()) {
                decimal importoritenuta = CfgFn.GetNoNullDecimal(rRitenuta["admintax"]);
                if (importoritenuta <= 0) continue;
                string idrel = BudgetFunction.GetIdForDocument(rRitenuta);

                //object idaccmotiveCost = DBNull.Value;
                //if (tipoRit["idaccmotive_cost"] != DBNull.Value) {
                //    idaccmotiveCost = tipoRit["idaccmotive_cost"];
                //}
                TaxInfo tInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(rRitenuta["taxcode"]));

                object idaccmotiveCost = getIdaccmotiveCostForTax(curr["idser"], rRitenuta["taxcode"]);
                if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive) && nphase == 1) { // 
                    //Non può accorpare se esiste già la fase generata come distinta
                    DataRow checkExist = bf.getEpExpRowLike(idrel, nphase);
                    if (checkExist == null) {
                        sommaRitNonConfig += importoritenuta;
                        //accorpa il preimpegno dei contributi a quello principale
                        preimpegniAccorpati.Add(idrel, true);
                        continue;
                    }
                }

                //if (((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive)) && nphase == 1) { // 
                //    //Non può accorpare se esiste già la fase generata come distinta
                //    DataRow checkExist = bf.getEpExpRow(idrel, nphase);
                //    if (checkExist == null) {
                //        sommaRitNonConfig += importoritenuta;
                //        //accorpa il preimpegno dei contributi a quello principale
                //        continue;
                //    }

                //}

                if (idaccmotiveCost == DBNull.Value) {
                    idaccmotiveCost = idaccmotive;
                }

                var contiCostoContributo = bf.GetAccMotiveDetails(idaccmotiveCost);
                if (contiCostoContributo.Length == 0) {
                    ShowMessage("Contributo " + tInfo.taxRef() + " mal configurato.", "Errore");
                    return false;
                }

                object idAccCostoContributo = contiCostoContributo[0]["idacc"];
                var lista = getInfoImpegniForContributo(curr["idser"], rRitenuta["taxcode"], importoritenuta, idrel,
                    idrelMain, nphase);
                if (lista == null) {
                    return false;
                }

                foreach (var contr in lista) {
                    DataRow rExpRit = bf.addEpExp(contr.idreg, getIdMan(curr["idupb"]), contr.importo,
                        curr["description"], curr["adate"],
                        idAccCostoContributo, curr["idupb"], contr.idrelated, doc, curr["adate"],
                        curr["start"], curr["stop"], nphase, contr.idepexp, idaccmotiveCost);
                    addImpegnoToDict(rExpRit, contr.idrelated);
                }

            }

            amount += sommaRitNonConfig;

            DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
            if (account.Length == 0) {
                ShowMessage(
                    "La causale del contratto non ha conti associati, non verrà generato alcun impegno di budget",
                    "Avviso");
                return false;
            }

            DataRow rAccount = account[0];
            object idaccMain = rAccount["idacc"];

            if (isBudgetEnabled(idaccMain)) {
                DataRow currEpExpMain = bf.addEpExp(curr["idreg"], getIdMan(curr["idupb"]), amount, curr["description"],
                    curr["adate"], idaccMain, curr["idupb"], idrelMain, doc, curr["adate"],
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelMain, nphase - 1), idaccmotive);
                addImpegnoToDict(currEpExpMain, idrelMain);
            }

            return true;
        }



        private bool generaImpegniCedolino(BudgetFunction bf, DataRow curr, int nphase) {
            string filterCedolino = QHS.CmpEq("idpayroll", curr["idpayroll"]);
            string filterContract = QHS.AppAnd(QHS.CmpEq("idcon", curr["idcon"]),
                QHS.CmpEq("ayear", Conn.GetSys("esercizio")));

            DataTable parasubcontractview = Conn.RUN_SELECT("parasubcontractview", "*", null, filterContract, null,
                false);
            if (parasubcontractview.Rows.Count == 0) {
                DataTable parasubcontract = Conn.RUN_SELECT("parasubcontract", "*", null,
                    QHS.CmpEq("idcon", curr["idcon"]), null,
                    false);
                DataRow currContrattoBase = parasubcontract.Rows[0];
                string descrizioneErrore = "Il contratto n." + currContrattoBase["ncon"] + " del " +
                                           currContrattoBase["ycon"] + " non è stato ribaltato nell'anno corrente.";
                ShowMessage(descrizioneErrore, "Errore");
                return false;
            }

            DataRow currContratto = parasubcontractview.Rows[0];
            string idrelMain = BudgetFunction.GetIdForDocument(curr);

            string descrizione =
                "Contratto n." + currContratto["ncon"] + " del " +
                currContratto["ycon"] + " - " +
                "Cedolino n. " + curr["npayroll"] + "/" + curr["fiscalyear"];
            object idreg = currContratto["idreg"];

            object doc = "Contr. " + currContratto["ncon"] + "/" +
                         currContratto["ycon"] +
                         " Cedolino " + curr["npayroll"] + "/" + curr["fiscalyear"];


            object idaccmotive = currContratto["idaccmotive"];
            if (idaccmotive == DBNull.Value) {
                ShowMessage("Manca la causale nel contratto", "Errore");
                return false;
            }

            //if (currContratto["idupb"] == DBNull.Value) {
            //    ShowMessage("Attenzione, il contratto non ha l'indicazione dell'UPB");
            //    return false;
            //}

            int annoContratto =
                CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("parasubcontract", QHS.CmpEq("idcon", curr["idcon"]), "ycon"));
            int annostop = esercizio;
            if (curr["stop"] != DBNull.Value) {
                annostop = ((DateTime) curr["stop"]).Year;
            }

            if (annostop < annoContratto) annostop = annoContratto;
            object flag = Conn.DO_READ_VALUE("accountingyear", QHS.CmpEq("ayear", annostop), "flag");
            bool annoStopAperto = flag != null && flag != DBNull.Value && ((CfgFn.GetNoNullInt32(flag) & 32) == 0);
            bool daConsiderare = (annoStopAperto && (annostop == esercizio)) ||
                                 (annoStopAperto == false && annostop < esercizio);

            if (!daConsiderare) {
                ShowMessage("Il cedolino n. " + curr["npayroll"] + "/" + curr["fiscalyear"] +
                            " ha competenza in anni diversi quindi non sarà generato alcun impegno nell'anno " +
                            esercizio, "Avviso");
                return false;
            }


            decimal amount = CfgFn.GetNoNullDecimal(curr["feegross"]);
            DataTable payrolltax = Conn.RUN_SELECT("payrolltax", "*", null, filterCedolino, null, false);
            decimal sommaRitNonConfig = 0;
            foreach (DataRow rRitenuta in payrolltax.Select()) {
                decimal importoritenuta = CfgFn.GetNoNullDecimal(rRitenuta["admintax"]);
                if (importoritenuta <= 0) continue;
                string idrel = BudgetFunction.GetIdForDocument(rRitenuta);

                TaxInfo tInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(rRitenuta["taxcode"]));
                //object idaccmotiveCost = DBNull.Value;
                //if (tipoRit["idaccmotive_cost"] != DBNull.Value) {
                //    idaccmotiveCost = tipoRit["idaccmotive_cost"];
                //}
                object idaccmotiveCost = getIdaccmotiveCostForTax(currContratto["idser"], rRitenuta["taxcode"]);

                if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive) && nphase == 1) { // 
                    //Non può accorpare se esiste già la fase generata come distinta
                    DataRow checkExist = bf.getEpExpRowLike(idrel, nphase);
                    if (checkExist == null) {
                        sommaRitNonConfig += importoritenuta;
                        //accorpa il preimpegno dei contributi a quello principale
                        preimpegniAccorpati.Add(idrel, true);
                        continue;
                    }
                }
                //if (((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive)) && nphase == 1) { //
                //    //Non può accorpare se esiste già la fase generata come distinta
                //    DataRow checkExist = bf.getEpExpRow(idrel, nphase);
                //    if (checkExist == null) {
                //        sommaRitNonConfig += importoritenuta;
                //        //accorpa il preimpegno dei contributi a quello principale
                //        continue;
                //    }

                //}

                if (idaccmotiveCost == DBNull.Value) {
                    idaccmotiveCost = idaccmotive;
                }

                var contiCostoContributo = bf.GetAccMotiveDetails(idaccmotiveCost);
                if (contiCostoContributo.Length == 0) {
                    ShowMessage("Contributo " + tInfo.taxRef() + " mal configurato.", "Errore");
                    return false;
                }

                object idAccCostoContributo = contiCostoContributo[0]["idacc"];

                var lista = getInfoImpegniForContributo(currContratto["idser"], rRitenuta["taxcode"], importoritenuta,
                    idrel, idrelMain, nphase);
                if (lista == null) {
                    return false;
                }

                foreach (var contr in lista) {
                    DataRow rExpRit = bf.addEpExp(contr.idreg, getIdMan(curr["idupb"]), contr.importo,
                        descrizione + "-" + tInfo.taxRef(), Conn.GetSys("datacontabile"),
                        idAccCostoContributo, curr["idupb"], contr.idrelated, doc,
                        Conn.GetSys("datacontabile"),
                        curr["start"], curr["stop"], nphase, contr.idepexp, idaccmotiveCost);
                    addImpegnoToDict(rExpRit, contr.idrelated);
                }


            }

            amount += sommaRitNonConfig;

            DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
            if (account.Length == 0) {
                ShowMessage(
                    "La causale principale non ha conti associati, non verrà generato alcun impegno di budget",
                    "Avviso");
                return false;
            }

            DataRow rAccount = account[0];
            object idaccMain = rAccount["idacc"];


            if (isBudgetEnabled(idaccMain)) {

                DataRow currEpExpMain = bf.addEpExp(idreg, getIdMan(curr["idupb"]), amount, descrizione,
                    Conn.GetSys("datacontabile"),
                    idaccMain, curr["idupb"], idrelMain, doc, Conn.GetSys("datacontabile"),
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelMain, nphase - 1), idaccmotive);
                addImpegnoToDict(currEpExpMain, idrelMain);
            }

            return true;
        }

        private bool generaImpegniProfessionale(BudgetFunction bf, DataRow curr, int nphase) {
            string filterContract = QHS.CmpKey(curr);
            DateTime primoGennaio = new DateTime(esercizio, 1, 1);
            object doc = curr["doc"];
            object docdate = curr["docdate"];
            int anno = ((DateTime) curr["adate"]).Year;
            var obj = (nphase == 1) ? "preimpegno" : "impegno";

            if (anno != esercizio) {

                if (!silent) {
                    ShowMessage(
                        "La parcella non ha competenza nell'anno quindi nessun " + obj +
                        " è stato generato.", "Avviso", false);
                }

                return anno < esercizio; //se anno precedente ritorna true altrimenti false
            }

            string idrelMain = BudgetFunction.GetIdForDocument(curr);


            object dataParcella = curr["adate"];
            //if (dataParcella != DBNull.Value) {
            //    if (((DateTime) dataParcella).Year < esercizio) dataParcella = primoGennaio;
            //}

            object idaccmotive = curr["idaccmotive"];
            if ((idaccmotive == null) || (idaccmotive == DBNull.Value))
                return false;
            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Selezionare prima l'UPB", "Avviso");
                return false;
            }


            decimal amount = CfgFn.GetNoNullDecimal(curr["totalgross"]);
            decimal sommaspese = 0;
            DataTable profservicerefund = Conn.RUN_SELECT("profservicerefund", "*", null, filterContract, null, false);
            DataTable tipiSpesa = Conn.RUN_SELECT("profrefund", "*", null, null, null, false);
            foreach (DataRow rSpesa in profservicerefund.Rows) {
                DataRow tipoSpesa = tipiSpesa.Select(QHC.CmpEq("idlinkedrefund", rSpesa["idlinkedrefund"]))[0];

                if (tipoSpesa == null)
                    continue;
                if (tipoSpesa["idaccmotive"] == DBNull.Value)
                    continue;
                if (tipoSpesa["idaccmotive"].ToString() == idaccmotive.ToString())
                    continue;

                decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                sommaspese += importospesa;

                DataRow[] contiSpesa = bf.GetAccMotiveDetails(tipoSpesa["idaccmotive"]);
                if (contiSpesa.Length == 0) {
                    ShowMessage("Il tipo spesa " + tipoSpesa["description"] + " non è ben configurato", "Errore");
                    return false;
                }

                object idaccSpesa = contiSpesa[0]["idacc"];

                string idrel = BudgetFunction.GetIdForDocument(rSpesa);
                DataRow currEpExp = bf.addEpExp(curr["idreg"], getIdMan(curr["idupb"]), importospesa,
                    curr["description"], dataParcella,
                    idaccSpesa, curr["idupb"], idrel, doc, docdate,
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrel, nphase - 1),
                    tipoSpesa["idaccmotive"]);
                addImpegnoToDict(currEpExp, idrel);

            }

            amount -= sommaspese;

            decimal sommaRitNonConfig = 0;
            DataTable profservicetax = Conn.RUN_SELECT("profservicetax", "*", null, filterContract, null, false);


            foreach (DataRow rRitenuta in profservicetax.Select()) {
                decimal importoritenuta = CfgFn.GetNoNullDecimal(rRitenuta["admintax"]);
                if (importoritenuta <= 0) continue;
                TaxInfo tInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(rRitenuta["taxcode"]));
                string idrel = BudgetFunction.GetIdForDocument(rRitenuta);

                //object idaccmotiveCost = DBNull.Value;
                //if (tipoRit["idaccmotive_cost"] != DBNull.Value) {
                //    idaccmotiveCost = tipoRit["idaccmotive_cost"];
                //}
                object idaccmotiveCost = getIdaccmotiveCostForTax(curr["idser"], rRitenuta["taxcode"]);

                if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive) && nphase == 1) { // 
                    //Non può accorpare se esiste già la fase generata come distinta
                    DataRow checkExist = bf.getEpExpRowLike(idrel, nphase);
                    if (checkExist == null) {
                        sommaRitNonConfig += importoritenuta;
                        //accorpa il preimpegno dei contributi a quello principale
                        preimpegniAccorpati.Add(idrel, true);
                        continue;
                    }
                }

                //if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive)) { // && nphase == 1
                //    //Non può accorpare se esiste già la fase generata come distinta
                //    DataRow checkExist = bf.getEpExpRow(idrel, nphase);
                //    if (checkExist == null) {
                //        sommaRitNonConfig += importoritenuta;
                //        //accorpa il preimpegno dei contributi a quello principale
                //        continue;
                //    }
                //}

                if (idaccmotiveCost == DBNull.Value) {
                    idaccmotiveCost = idaccmotive;
                }

                var contiCostoContributo = bf.GetAccMotiveDetails(idaccmotiveCost);
                if (contiCostoContributo.Length == 0) {
                    ShowMessage("Contributo " + tInfo.taxRef() + " mal configurato.", "Errore");
                    return false;
                }

                object idAccCostoContributo = contiCostoContributo[0]["idacc"];



                var lista = getInfoImpegniForContributo(curr["idser"], rRitenuta["taxcode"], importoritenuta, idrel,
                    idrelMain, nphase);
                if (lista == null) {
                    return false;
                }

                foreach (var contr in lista) {
                    DataRow rExpRit = bf.addEpExp(contr.idreg, getIdMan(curr["idupb"]), contr.importo,
                        curr["description"], dataParcella,
                        idAccCostoContributo, curr["idupb"], contr.idrelated, doc, curr["adate"],
                        curr["start"], curr["stop"], nphase, contr.idepexp, idaccmotiveCost);
                    addImpegnoToDict(rExpRit, contr.idrelated);
                }

            }

            amount += sommaRitNonConfig;

            DataRow rIvaKind = curr.GetParentRow("ivakindprofservice");
            if (rIvaKind == null) {
                ShowMessage("Tipo iva non trovato, non verrà generato alcun impegno di budget");
                return false;
            }

            double percIndetraibile = CfgFn.GetNoNullDouble(rIvaKind["unabatabilitypercentage"]);

            double ivaLorda = CfgFn.GetNoNullDouble(curr["ivaamount"]);
            double ivaIndetraibile = ivaLorda * percIndetraibile;
            double ivaDetraibileLorda = ivaLorda - ivaIndetraibile;

            double proRataPerc = CfgFn.GetNoNullDouble(
                Conn.DO_READ_VALUE("iva_prorata", "(ayear = '" + Conn.GetSys("esercizio") + "')", "prorata"));

            double promiscuoPerc = CfgFn.GetNoNullDouble(
                Conn.DO_READ_VALUE("iva_mixed", "(ayear = '" + Conn.GetSys("esercizio") + "')", "mixed"));

            double ivaDetraibile = ivaDetraibileLorda * proRataPerc;
            if (curr["flagmixed"].ToString().ToUpper() == "S")
                ivaDetraibile *= promiscuoPerc;

            amount -= (decimal) ivaDetraibile;

            DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
            if (account.Length == 0)
                return false;
            DataRow rAccount = account[0];
            object idaccMain = rAccount["idacc"];


            if (isBudgetEnabled(idaccMain)) {
                DataRow currEpExpMain = bf.addEpExp(curr["idreg"], getIdMan(curr["idupb"]), amount,
                    curr["description"], dataParcella,
                    idaccMain, curr["idupb"], idrelMain, doc, docdate,
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelMain, nphase - 1), idaccmotive);
                addImpegnoToDict(currEpExpMain, idrelMain);

                if (nphase == 2 && currEpExpMain != null) {
                    _listaImpegni[0] = currEpExpMain;
                }
            }

            return true;
        }

        private bool generaImpegniContrattoOccasionale(BudgetFunction bf, DataRow curr, int nphase) {
            if (curr["idupb"] == DBNull.Value) {
                ShowMessage("Selezionare prima l'UPB", "Avviso");
                return false;
            }

            string idrelMain = BudgetFunction.GetIdForDocument(curr);
            string filterContract = QHS.CmpKey(curr);
            DataTable tContractYear = Conn.RUN_SELECT("casualcontractyear", "*", null,
                QHS.AppAnd(filterContract, QHS.CmpEq("ayear", esercizio)), null, false);
            DataTable spese = Conn.RUN_SELECT("casualcontractrefund", "*", null, filterContract, null, false);
            DataTable tipiSpesa = Conn.RUN_SELECT("casualrefund", "*", null, null, null, false);


            DataRow currYear = tContractYear.Rows[0];
            calcolooccasionale.calcOccasionale mycalc = new calcolooccasionale.calcOccasionale(Conn, curr, currYear,
                spese, tipiSpesa);
            bool res = mycalc.GetInfoContratto();
            if (!res) return false;

            object doc = "Prestazione Occasionale " +
                         curr["ycon"].ToString().Substring(2, 2) + "/" +
                         curr["ncon"].ToString().PadLeft(6, '0');


            object idaccmotive = curr["idaccmotive"];
            if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                ShowMessage("Non è stata configurata la causale del contratto occasionale", "Avviso");
                return false;
            }

            object datarif = curr["datecompleted"];
            decimal amount = CfgFn.GetNoNullDecimal(curr["feegross"]);
            decimal sommaspese = 0;



            foreach (DataRow rSpesa in spese.Rows) {
                var causaleSpesa =
                    tipiSpesa.Select(QHC.CmpEq("idlinkedrefund", rSpesa["idlinkedrefund"]))[0][
                        "idaccmotive"];
                if (causaleSpesa == DBNull.Value) continue;
                DataRow[] contiSpesa = bf.GetAccMotiveDetails(causaleSpesa);
                if (contiSpesa.Length == 0) continue;

                decimal importospesa = CfgFn.GetNoNullDecimal(rSpesa["amount"]);
                sommaspese += importospesa;

                object idaccSpesa = contiSpesa[0]["idacc"];

                string idrel = BudgetFunction.GetIdForDocument(rSpesa);
                DataRow currEpExp = bf.addEpExp(curr["idreg"], getIdMan(curr["idupb"]), importospesa,
                    curr["description"], datarif, idaccSpesa, curr["idupb"], idrel, doc, curr["adate"],
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrel, nphase - 1), causaleSpesa);
                addImpegnoToDict(currEpExp, idrel);

            }

            amount -= sommaspese;

            DataTable tRiten = mycalc.calcolaRitenute(CfgFn.GetNoNullDecimal(curr["feegross"]));

            decimal sommaRitNonConfig = 0;
            if (tRiten != null) {
                foreach (DataRow rRitenuta in tRiten.Rows) {
                    decimal importoritenuta = CfgFn.GetNoNullDecimal(rRitenuta["admintax"]);
                    if (importoritenuta <= 0) continue;
                    string idrel = BudgetFunction.GetIdForDocument(rRitenuta);
                    TaxInfo tInfo = TaxInfo.getInfo(taxInfo, CfgFn.GetNoNullInt32(rRitenuta["taxcode"]));

                    //object idaccmotiveCost = DBNull.Value;
                    //if (tipoRit["idaccmotive_cost"] != DBNull.Value) {
                    //    idaccmotiveCost = tipoRit["idaccmotive_cost"];
                    //}
                    object idaccmotiveCost = getIdaccmotiveCostForTax(curr["idser"], rRitenuta["taxcode"]);

                    if ((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive) && nphase == 1) { // 
                        //Non può accorpare se esiste già la fase generata come distinta
                        DataRow checkExist = bf.getEpExpRowLike(idrel, nphase);
                        if (checkExist == null) {
                            sommaRitNonConfig += importoritenuta;
                            //accorpa il preimpegno dei contributi a quello principale
                            preimpegniAccorpati.Add(idrel, true);
                            continue;
                        }
                    }

                    //if (((idaccmotiveCost == DBNull.Value || idaccmotiveCost == idaccmotive)) && nphase == 1) {
                    //    // && nphase == 1
                    //    //Non può accorpare se esiste già la fase generata come distinta
                    //    DataRow checkExist = bf.getEpExpRow(idrel, nphase);
                    //    if (checkExist == null) {
                    //        sommaRitNonConfig += importoritenuta;
                    //        //accorpa il preimpegno dei contributi a quello principale
                    //        continue;
                    //    }
                    //}

                    if (idaccmotiveCost == DBNull.Value) {
                        idaccmotiveCost = idaccmotive;
                    }

                    var contiCostoContributo = bf.GetAccMotiveDetails(idaccmotiveCost);
                    if (contiCostoContributo.Length == 0) {
                        ShowMessage("Contributo " + tInfo.taxRef() + " mal configurato.", "Errore");
                        return false;
                    }

                    object idAccCostoContributo = contiCostoContributo[0]["idacc"];

                    if (!isBudgetEnabled(idAccCostoContributo)) continue;

                    var lista = getInfoImpegniForContributo(curr["idser"], rRitenuta["taxcode"], importoritenuta, idrel,
                        idrelMain, nphase);
                    if (lista == null) {
                        return false;
                    }

                    foreach (var contr in lista) {
                        DataRow rExpRit = bf.addEpExp(contr.idreg, getIdMan(curr["idupb"]), contr.importo,
                            curr["description"], datarif,
                            idAccCostoContributo, curr["idupb"], contr.idrelated, doc, curr["adate"],
                            curr["start"], curr["stop"], nphase, contr.idepexp, idaccmotiveCost);
                        addImpegnoToDict(rExpRit, contr.idrelated);
                    }

                }
            }

            amount += sommaRitNonConfig;

            DataRow[] account = bf.GetAccMotiveDetails(idaccmotive);
            if (account.Length == 0) {
                ShowMessage(
                    "La causale del contratto non ha conti associati, non verrà generato alcun impegno di budget",
                    "Avviso");
                return false;
            }

            DataRow rAccount = account[0];
            object idaccMain = rAccount["idacc"];

            if (isBudgetEnabled(idaccMain)) {
                DataRow currEpExpMain = bf.addEpExp(curr["idreg"], getIdMan(curr["idupb"]), amount,
                    curr["description"], datarif, idaccMain, curr["idupb"],
                    idrelMain, doc, curr["adate"],
                    curr["start"], curr["stop"], nphase, getIdEpExpByIdRelated(idrelMain, nphase - 1), idaccmotive);
                addImpegnoToDict(currEpExpMain, idrelMain);
            }

            return true;
        }

        Dictionary<int, List<DataRow>> importver_epexp = new Dictionary<int, List<DataRow>>();
        Dictionary<int, List<DataRow>> importver_expense = new Dictionary<int, List<DataRow>>();
        Dictionary<int, List<DataRow>> importriep_epexp = new Dictionary<int, List<DataRow>>();
        Dictionary<int, List<DataRow>> importriep_expense = new Dictionary<int, List<DataRow>>();
        private object idcsa_import_inited = DBNull.Value;

        Hashtable nphaseForIdEpExp = new Hashtable();

        void initPartitionDictionary(object idcsa_import) {
            clearPartionDictionary();
            idcsa_import_inited = idcsa_import;
            string filter = QHS.AppAnd(
                QHS.CmpEq("CE.idcsa_import", idcsa_import),
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()));
            DataTable tImportRiepEpExp = Conn.SQLRunner(
                $@"select CE.idriep,CE.ndetail,CE.idepexp,CE.quota,E.nphase,EY.idupb,EY.idacc  
                        from csa_importriep_epexp  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp
                        where {filter} order by CE.idriep, CE.ndetail
                    ", false
            );
            foreach (DataRow r in tImportRiepEpExp.Rows) {
                int idRiep = CfgFn.GetNoNullInt32(r["idriep"]);
                if (!importriep_epexp.ContainsKey(idRiep)) {
                    importriep_epexp[idRiep] = new List<DataRow>();
                }

                importriep_epexp[idRiep].Add(r);
                idupbForEpExp[r["idepexp"]] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }

            DataTable tRiep = Conn.SQLRunner(
                $@"select CE.idepexp,EY.idupb,EY.idacc,E.nphase  
                        from csa_importriep  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  EY.idepexp=CE.idepexp
                        where {QHS.CmpEq("CE.idcsa_import", idcsa_import)}                    
                ", false);
            foreach (DataRow r in tRiep.Rows) {
                int idepexp = CfgFn.GetNoNullInt32(r["idepexp"]);
                idupbForEpExp[idepexp] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }

            DataTable tImportVerEpExp = Conn.SQLRunner(
                $@"select CE.idver,CE.ndetail,CE.idepexp,CE.quota,E.nphase,EY.idupb,EY.idacc  
                        from csa_importver_epexp  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp
                        where {filter} order by CE.idver, CE.ndetail
                    ", false
            );
            foreach (DataRow r in tImportVerEpExp.Rows) {
                int idVer = CfgFn.GetNoNullInt32(r["idver"]);
                if (!importver_epexp.ContainsKey(idVer)) {
                    importver_epexp[idVer] = new List<DataRow>();
                }

                importver_epexp[idVer].Add(r);
                idupbForEpExp[r["idepexp"]] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }

            DataTable tImportRiepPartitionEp = Conn.SQLRunner(
                $@"select CE.idepexp,E.nphase,EY.idupb
                        from csa_importriep_partition  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp 
                        where {filter} 
                    ", false
            );
            foreach (DataRow r in tImportRiepPartitionEp.Rows) {
                idupbForEpExp[r["idepexp"]] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }

            DataTable tImportVerPartitionEp = Conn.SQLRunner(
                $@"select CE.idepexp,E.nphase,EY.idupb
                        from csa_importver_partition  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp
                        where {filter}
                    ", false
            );
            foreach (DataRow r in tImportVerPartitionEp.Rows) {
                idupbForEpExp[r["idepexp"]] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }




            DataTable tVer = Conn.SQLRunner(
                $@"select CE.idepexp,EY.idupb,EY.idacc,E.nphase
                        from csa_importver  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  EY.idepexp=CE.idepexp
                        where {QHS.CmpEq("CE.idcsa_import", idcsa_import)}                    
                ", false);
            foreach (DataRow r in tVer.Rows) {
                int idepexp = CfgFn.GetNoNullInt32(r["idepexp"]);
                idupbForEpExp[idepexp] = r["idupb"];
                nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])] = r["nphase"];
            }


            DataTable tImportRiepExpense =
                Conn.SQLRunner(
                    $@"select CE.idriep,CE.ndetail,CE.idexp,CE.amount,E.nphase,EY.idupb,EY.idfin  
                        from csa_importriep_expense  CE 
                            join expense E on E.idexp=CE.idexp
                            join expenseyear EY on  E.idexp=EY.idexp
                        where {filter} order by CE.idriep, CE.ndetail
                    ", false
                );
            foreach (DataRow r in tImportRiepExpense.Rows) {
                int idRiep = CfgFn.GetNoNullInt32(r["idriep"]);
                if (!importriep_expense.ContainsKey(idRiep)) {
                    importriep_expense[idRiep] = new List<DataRow>();
                }

                importriep_expense[idRiep].Add(r);
            }

            DataTable tImportVerExpense = Conn.SQLRunner(
                $@"select CE.idver,CE.ndetail,CE.idexp,CE.amount,E.nphase,EY.idupb,EY.idfin  
                        from csa_importver_expense  CE 
                            join expense E on E.idexp=CE.idexp
                            join expenseyear EY on  E.idexp=EY.idexp
                        where {filter} order by CE.idver, CE.ndetail
                    ", false
            );
            foreach (DataRow r in tImportVerExpense.Rows) {
                int idVer = CfgFn.GetNoNullInt32(r["idver"]);
                if (!importver_expense.ContainsKey(idVer)) {
                    importver_expense[idVer] = new List<DataRow>();
                }

                importver_expense[idVer].Add(r);
            }


        }

        void clearPartionDictionary() {
            idcsa_import_inited = DBNull.Value;
            importver_epexp.Clear();
            importver_expense.Clear();
            importriep_epexp.Clear();
            importriep_expense.Clear();
            nphaseForIdEpExp.Clear();
            idupbForEpAcc.Clear();
            idupbForEpExp.Clear();
            idManForUpb.Clear();

        }


        DataRow[] getImportVer_EpExp(object idcsa_import, object idver) {
            int idVer = CfgFn.GetNoNullInt32(idver);
            if (idcsa_import_inited.Equals(idcsa_import)) {
                if (importver_epexp.ContainsKey(idVer)) return importver_epexp[idVer].ToArray();
                return new DataRow[0];
            }

            string filter = QHS.AppAnd(
                QHS.CmpEq("CE.idcsa_import", idcsa_import),
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()),
                QHS.CmpEq("CE.idver", idver)
            );
            DataTable tImportVerEpExp = Conn.SQLRunner(
                $@"select CE.idver,CE.ndetail,CE.idepexp,CE.quota,E.nphase,EY.idupb,EY.idacc  
                        from csa_importver_epexp  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp
                        where {filter} order by CE.idver, CE.ndetail
                    ", false
            );

            return tImportVerEpExp.Select();
        }

        DataRow[] getImportVer_Expense(object idcsa_import, object idver) {
            int idVer = CfgFn.GetNoNullInt32(idver);
            if (idcsa_import_inited.Equals(idcsa_import)) {
                if (importver_expense.ContainsKey(idVer)) {
                    return importver_expense[idVer].ToArray();
                }

                return new DataRow[0];
            }

            string filter = QHS.AppAnd(
                QHS.CmpEq("CE.idcsa_import", idcsa_import),
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()),
                QHS.CmpEq("CE.idver", idVer)
            );
            DataTable tImportVerExpense = Conn.SQLRunner(
                $@"select CE.idver,CE.ndetail,CE.idexp,CE.amount,E.nphase,EY.idupb,EY.idfin  
                        from csa_importver_expense  CE 
                            join expense E on E.idexp=CE.idexp
                            join expenseyear EY on  E.idexp=EY.idexp
                        where {filter} order by CE.idver, CE.ndetail
                    ", false
            );
            return tImportVerExpense.Select();
        }

        DataRow[] getImportRiep_EpExp(object idcsa_import, object idriep) {
            int idRiep = CfgFn.GetNoNullInt32(idriep);
            if (idcsa_import_inited.Equals(idcsa_import)) {
                if (importriep_epexp.ContainsKey(idRiep)) return importriep_epexp[idRiep].ToArray();
                return new DataRow[0];
            }

            string filter = QHS.AppAnd(
                QHS.CmpEq("CE.idcsa_import", idcsa_import),
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()),
                QHS.CmpEq("CE.idriep", idriep)
            );
            DataTable tImportRiepEpExp = Conn.SQLRunner(
                $@"select CE.idriep,CE.ndetail,CE.idepexp,CE.quota,E.nphase,EY.idupb,EY.idacc  
                        from csa_importriep_epexp  CE 
                            join epexp E on  E.idepexp=CE.idepexp
                            join epexpyear EY on  E.idepexp=EY.idepexp
                        where {filter} order by CE.idriep, CE.ndetail
                    ", false
            );

            return tImportRiepEpExp.Select();

        }


        DataRow[] getImportRiep_Expense(object idcsa_import, object idriep) {
            int idRiep = CfgFn.GetNoNullInt32(idriep);
            if (idcsa_import_inited.Equals(idcsa_import)) {
                if (importriep_expense.ContainsKey(idRiep)) {
                    return importriep_expense[idRiep].ToArray();
                }

                return new DataRow[0];
            }

            string filter = QHS.AppAnd(
                QHS.CmpEq("CE.idcsa_import", idcsa_import),
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()),
                QHS.CmpEq("CE.idriep", idriep)
            );
            DataTable tImportRiepExpense = Conn.SQLRunner(
                $@"select CE.idriep,CE.ndetail,CE.idexp,CE.amount,E.nphase,EY.idupb,EY.idfin  
                        from csa_importriep_expense  CE 
                            join expense E on E.idexp=CE.idexp
                            join expenseyear EY on  E.idexp=EY.idexp
                        where {filter} order by CE.idriep, CE.ndetail
                    ", false
            );
            return tImportRiepExpense.Select();
        }

        private bool generaImpegniImportazioneCsa(BudgetFunction bf, DataRow curr, int nphase) {
            DataTable riep = curr.Table.DataSet.Tables["csa_importriep"];
            DataTable ver = curr.Table.DataSet.Tables["csa_importver"];
            object idcsa_import = curr["idcsa_import"];

            bool vecchiaGest = vecchiaGestione(idcsa_import);
            if (vecchiaGest) initPartitionDictionary(idcsa_import);
            bool nuovaGestione = !vecchiaGest;
            if (nuovaGestione) {
                //clearPartionDictionary();
                riep = Conn.readTable("csa_importriep_partitionview",
                    q.eq("idcsa_import", idcsa_import) & q.gt("amount", 0));
                ver = Conn.readTable("csa_importver_partitionview",
                    q.eq("idcsa_import", idcsa_import) &
                    (q.gt("amount", 0) | (q.lt("amount", 0) & q.eq("flagclawback", "S"))));
                foreach (DataRow r in riep.Rows) {
                    EP.setFlagAccountUsage(r["idacc"], CfgFn.GetNoNullInt32(r["flagaccountusage"]));
                    setIdManForUpb(r["idupb"], r["idman"]);
                    if (r["idepexp"] != DBNull.Value) {
                        idupbForEpExp[(int) r["idepexp"]] = r["idupb"];
                        nphaseForIdEpExp[(int) r["idepexp"]] = r["nphaseepexp"];
                    }
                }

                foreach (DataRow r in ver.Rows) {
                    EP.setFlagAccountUsage(r["idacc_cost"], CfgFn.GetNoNullInt32(r["flagaccountusage_cost"]));
                    setIdManForUpb(r["idupb"], r["idman"]);
                    if (r["idepexp"] != DBNull.Value) {
                        idupbForEpExp[(int) r["idepexp"]] = r["idupb"];
                        nphaseForIdEpExp[(int) r["idepexp"]] = r["nphaseepexp"];
                    }
                }
            }

            bool res = false;
            foreach (DataRow r in riep.Rows) {
                if (nphase == 1 && !preImpegniAbilitati(r)) continue;
                if (nphase == 2 && !impegniAbilitati(r)) continue;
                if (vecchiaGest) res = res | generaImpegniRiepilogo(bf, r, nphase);
                if (nuovaGestione) res = res | generaImpegniRiepilogoNuovaGestione(bf, r, nphase);
            }

            foreach (DataRow r in ver.Rows) {
                if (nphase == 1 && !preImpegniAbilitati(r)) continue;
                if (nphase == 2 && !impegniAbilitati(r)) continue;
                if (vecchiaGest) res = res | generaImpegniVersamenti(bf, r, nphase);
                if (nuovaGestione) res = res | generaImpegniVersamentiNuovaGestione(bf, r, nphase);
            }

            return res;
        }

        private bool generaAccertamentiImportazioneCsa(BudgetFunction bf, DataRow curr, int nphase) {
            object idcsa_import = curr["idcsa_import"];
            bool vecchiaGest = vecchiaGestione(idcsa_import);
            bool nuovaGestione = !vecchiaGest;
            DataTable riep = curr.Table.DataSet.Tables["csa_importriep"];
            DataTable ver = curr.Table.DataSet.Tables["csa_importver"];
            if (nuovaGestione) {
                riep = Conn.readTable("csa_importriep_partitionview",
                    q.eq("idcsa_import", idcsa_import) & q.lt("amount", 0));
                ver = Conn.readTable("csa_importver_partitionview",
                    q.eq("idcsa_import", idcsa_import));
                riep.TableName = "csa_importriep_partitionview";
                ver.TableName = "csa_importver_partitionview";
            }

            //ShowMessage(ver.Rows.Count.ToString());
            bool res = false;
            foreach (DataRow r in riep.Rows) {
                if (nphase == 1 && !preAccertamentiAbilitati(r)) continue;
                if (nphase == 2 && !accertamentiAbilitati(r)) continue;
                res = res | generaAccertamentiRiepilogo(bf, r, nphase, nuovaGestione);
            }

            foreach (DataRow r in ver.Rows) {
                if (nphase == 1 && !preAccertamentiAbilitati(r)) continue;

                if (nphase == 2 && !accertamentiAbilitati(r)) continue;

                res = res | generaAccertamentiVersamenti(bf, r, nphase, nuovaGestione);
            }

            return res;
        }


        class InfoImpegno {
            public object parIdExp;
            public decimal amount;
            public string idrelated;
            public object idupb;

            public InfoImpegno(object parId, decimal amount, string idrelated) {
                this.parIdExp = parId;
                this.amount = amount;
                this.idrelated = idrelated;
                this.idupb = DBNull.Value;
            }
        }

        /// <summary>
        /// Restituisce una serie di "parent idepexp, amount" per un insieme di impegni di budget da creare
        /// Se un impegno di budget parent non esiste , restituisce DBNull per la voce parent
        /// Se l'impegno di budget da creare è già presente su db come esterno, salta quella voce
        /// </summary>
        /// <param name="riepCsa"></param>
        /// <param name="nphase"></param>
        /// <returns></returns>
        private List<InfoImpegno> getAmountsForImpegniRiep(DataRow riepCsa, int nphase, bool nuovaGestione) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (riepCsa.Table.Columns.Contains("amount")) {
                colName = "amount";
            }

            decimal importo = CfgFn.GetNoNullDecimal(riepCsa[colName]);
            string idrelatedMain = BudgetFunction.GetIdForDocument(riepCsa);
            if (riepCsa["idepexp"] != DBNull.Value) {
                int linkedNlev = 0;
                if (nuovaGestione) {
                    linkedNlev = 1;
                }
                else {
                    object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(riepCsa["idepexp"])];
                    if (nPhase != null) {
                        linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                    }
                    else {
                        linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp",
                            QHS.CmpEq("idepexp", riepCsa["idepexp"]), "nphase"));
                    }
                }

                if (linkedNlev >= nphase) return importi; //empty array, esiste già l'impegno esterno
                //in questo caso rimanente : (linkedNlev == 1 && nphase == 2) 
                importi.Add(new InfoImpegno(riepCsa["idepexp"], importo, idrelatedMain));
                return importi; // completamente imputato al parent specificato
            }


            if (nuovaGestione) {
                object idepexp = nphase == 2 ? getIdEpExpByIdRelated(idrelatedMain, 1) : DBNull.Value;
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
                return importi;
            }

            //if (riepCsa["idcsa_contract"] == DBNull.Value) {
            //    importi.Add(new InfoImpegno(getIdEpExpByIdRelated(idrelatedMain, nphase - 1), importo, idrelatedMain));
            //    return importi;
            //}
            //Esamina il caso in cui c'è una tabella di associazione oppure nulla, ossia è tutto generato e non associato da configurazione
            ///TODO: leggere una volta per tutte tutta la tabella e poi accedere tramite idriep
            var exp = getImportRiep_EpExp(riepCsa["idcsa_import"], riepCsa["idriep"]);
            //Conn.RUN_SELECT("csa_importriep_epexp", "*", "ndetail,idepexp,quota",
            //QHS.AppAnd(QHS.CmpEq("idcsa_import", riepCsa["idcsa_import"]), QHS.CmpEq("idriep", riepCsa["idriep"])),
            //null,
            //false);
            if (exp.Length > 0) {
                decimal totaleperc_residuo = 0;
                foreach (DataRow rr in exp) totaleperc_residuo += CfgFn.GetNoNullDecimal(rr["quota"]);
                //MetaData.SumColumn(exp, "quota");
                decimal totale_residuo = importo;
                foreach (DataRow r in exp) {
                    string idrel = idrelatedMain + "§" + r["ndetail"];
                    decimal quotaCorrente = CfgFn.GetNoNullDecimal(r["quota"]);
                    decimal quotaDaConsiderare = quotaCorrente / totaleperc_residuo;
                    decimal quotaImporto =
                        CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(quotaDaConsiderare) * totale_residuo);
                    totale_residuo -= quotaImporto;
                    totaleperc_residuo -= quotaCorrente;

                    int linkedNlev = 0;
                    object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                    if (nPhase != null) {
                        linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                    }
                    else {
                        linkedNlev =
                            CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]),
                                "nphase"));
                    }

                    //int linkedNlev = CfgFn.GetNoNullInt32(r["nphase"]);
                    //CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                    if (linkedNlev >= nphase) continue; //impegno esistente, salta questa riga
                    //in questo caso rimanente : (linkedNlev == 1 && nphase == 2) 
                    importi.Add(new InfoImpegno(r["idepexp"], quotaImporto, idrel));
                    // quota imputata al parent specificato                    
                }

                return importi;
            }

            ///TODO: leggere una volta per tutte tutta la tabella e poi accedere tramite idriep
            var expenseRipa = getImportRiep_Expense(riepCsa["idcsa_import"], riepCsa["idriep"]);
            //Conn.RUN_SELECT("csa_importriep_expense", "*", "ndetail,idexp,amount",
            //QHS.AppAnd(QHS.CmpEq("idcsa_import", riepCsa["idcsa_import"]), QHS.CmpEq("idriep", riepCsa["idriep"])),
            //null,
            //false);
            if (expenseRipa.Length == 0) {
                importi.Add(new InfoImpegno(getIdEpExpByIdRelated(idrelatedMain, nphase - 1), importo, idrelatedMain));
                return importi;
            }

            //ripartisce l'EP come nel finanziario
            foreach (DataRow r in expenseRipa) {
                string idrel = idrelatedMain + "§" + r["ndetail"];
                decimal quotaImporto = CfgFn.GetNoNullDecimal(r["amount"]);
                InfoImpegno i = new InfoImpegno(DBNull.Value, quotaImporto, idrel);
                i.idupb = r["idupb"];
                //Conn.DO_READ_VALUE("expenseyear",QHS.AppAnd(
                //    QHS.CmpEq("idexp", r["idexp"]), QHS.CmpEq("ayear", Conn.GetEsercizio())), "idupb");
                importi.Add(i);
                // quota imputata al parent specificato                    
            }

            return importi;


        }

        private List<InfoImpegno> getAmountsForAccertamentiRiep(DataRow riepCsa, int nphase) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (riepCsa.Table.Columns.Contains("amount")) colName = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(riepCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(riepCsa);
            //ShowMessage(idrelatedMain);
            importi.Add(new InfoImpegno(getIdEpAccByIdRelated(idrelatedMain, nphase - 1), importo, idrelatedMain));
            return importi;
        }

        List<InfoImpegno> getAmountsForScrittureRiepRicavo(DataRow riepCsa, bool nuovaGestione) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (riepCsa.Table.Columns.Contains("amount")) colName = "amount";
            if (riepCsa.Table.Columns.Contains("quota")) colName = "quota";
            decimal importo = CfgFn.GetNoNullDecimal(riepCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(riepCsa);
            //if (nuovaGestione)idrelatedMain+="§" + riepCsa["ndetail"];
            object idepacc = getIdEpAccByIdRelated(idrelatedMain, 2);
            importi.Add(new InfoImpegno(idepacc, importo, nuovaGestione ? idrelatedMain : null));
            return importi;
        }


        List<InfoImpegno> getAmountsForScrittureRiep(DataRow riepCsa, object idupb, bool nuovaGestione) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (riepCsa.Table.Columns.Contains("amount")) colName = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(riepCsa[colName]);
            string idrelatedMain = BudgetFunction.GetIdForDocument(riepCsa);
            //if (nuovaGestione)idrelatedMain+="§" + riepCsa["ndetail"];

            //Questa parte va bene sia per la vecchia che nuova gestione
            if (riepCsa["idepexp"] != DBNull.Value) {
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(riepCsa["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp",
                        QHS.CmpEq("idepexp", riepCsa["idepexp"]), "nphase"));
                    nphaseForIdEpExp[CfgFn.GetNoNullInt32(riepCsa["idepexp"])] = linkedNlev;
                }

                //int linkedNlev =
                //    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", riepCsa["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(riepCsa["idepexp"], importo, idrelatedMain));
                    return importi; // completamente imputato all'impegno specificato
                }
            }

            object idepexp = getIdEpExpByIdRelated(idrelatedMain, 2);

            if (nuovaGestione) {
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
                return importi;
            }


            string filter = QHS.AppAnd(
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()), QHS.CmpEq("CE.idcsa_import", riepCsa["idcsa_import"]),
                QHS.CmpEq("CE.idriep", riepCsa["idriep"])
            );

            //string sql = "select CE.ndetail,CE.idepexp,CE.quota FROM csa_importriep_epexp CE " +
            //             " join epexpyear ey on CE.idepexp=ey.idepexp " +
            //             " where " + filter +
            //                 " order by CE.ndetail,CE.idepexp,CE.quota";


            object ndetail = DBNull.Value;
            if (riepCsa.Table.Columns.Contains("ndetail")) {
                ndetail = riepCsa["ndetail"];
            }

            //Esamina il caso in cui c'è una tabella di associazione oppure nulla, ossia è tutto generato e non associato da configurazione
            var exp = getImportRiep_EpExp(riepCsa["idcsa_import"], riepCsa["idriep"]);
            //Conn.SQLRunner(sql);
            if (exp.Length == 0 && ndetail == DBNull.Value) {
                //non c'è nè la ripartizione EP e nè quella finanziaria, restituisce un a riga semplice 
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
                return importi;
            }

            if (exp.Length == 0 && ndetail != DBNull.Value) {
                string idrel = idrelatedMain + "§" + riepCsa["ndetail"];
                object idepexpDetDet = getIdEpExpByIdRelated(idrel, 2);
                importi.Add(new InfoImpegno(idepexpDetDet, importo, idrel));
                return importi;
            }

            //c'è la rip. ep ed eventualmente anche quella finanziaria
            if (exp.Length == 1) {
                DataRow r = exp[0];
                string idrel = idrelatedMain + "§" + r["ndetail"];
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                }

                //int linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(r["idepexp"], importo, idrel));
                    return importi;
                }

                object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                importi.Add(new InfoImpegno(idepexpDet, importo, idrel));
                return importi;
            }

            if (ndetail != DBNull.Value) {
                //in questo caso c'è la doppia ripartizione, pretendo un match sul n. dettaglio, se lo trovo uso quella riga "secca"
                DataRow[] exactMatch = exp._Filter(r => r["ndetail"].Equals(ndetail)).ToArray();
                //.Select(QHC.CmpEq("ndetail", ndetail));
                if (exactMatch.Length > 0) {
                    DataRow r = exactMatch[0];
                    string idrel = idrelatedMain + "§" + r["ndetail"];
                    int linkedNlev = 0;
                    object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                    if (nPhase != null) {
                        linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                    }
                    else {
                        linkedNlev =
                            CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]),
                                "nphase"));
                    }

                    //int linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                    if (linkedNlev == 2) {
                        importi.Add(new InfoImpegno(r["idepexp"], importo, idrel));
                        return importi;
                    }

                    object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                    importi.Add(new InfoImpegno(idepexpDet, importo, idrel));
                    return importi;
                }

            }


            decimal totaleperc_residuo = 0;
            foreach (DataRow rr in exp) totaleperc_residuo += CfgFn.GetNoNullDecimal(rr["quota"]);
            //MetaData.SumColumn(exp, "quota");
            decimal totale_residuo = importo;

            foreach (DataRow r in exp) {
                decimal quotaCorrente = CfgFn.GetNoNullDecimal(r["quota"]);
                decimal quotaDaConsiderare = quotaCorrente / totaleperc_residuo;
                decimal quotaImporto = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(quotaDaConsiderare) * totale_residuo);
                totale_residuo -= quotaImporto;
                totaleperc_residuo -= quotaCorrente;

                string idrel = idrelatedMain + "§" + r["ndetail"];
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                }

                //int linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(r["idepexp"], quotaImporto, idrel));
                    continue;
                }

                object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                importi.Add(new InfoImpegno(idepexpDet, quotaImporto, idrel));
                // quota imputata al parent specificato                    
            }

            return importi;
        }

        /// <summary>
        /// Restituisce una serie di "parent idepexp, amount" per un insieme di impegni di budget da creare
        /// Se un impegno di budget parent non esiste , restituisce DBNull per la voce parent
        /// Se l'impegno di budget da creare è già presente su db come esterno, salta quella voce
        /// </summary>
        /// <param name="verCsa"></param>
        /// <param name="nphase"></param>
        /// <returns></returns>
        List<InfoImpegno> getAmountsForImpegniVersamenti(DataRow verCsa, int nphase, bool nuovaGestione) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (verCsa.Table.Columns.Contains("amount")) colName = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(verCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(verCsa);
            if (verCsa["idepexp"] != DBNull.Value) {
                int linkedNlev = 0;
                if (nuovaGestione) {
                    linkedNlev = 1;
                }
                else {
                    object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(verCsa["idepexp"])];
                    if (nPhase != null) {
                        linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                    }
                    else {
                        linkedNlev =
                            CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", verCsa["idepexp"]),
                                "nphase"));
                    }
                }

                //int linkedNlev = 
                //        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", verCsa["idepexp"]),"nphase"));
                if (linkedNlev >= nphase) return importi; //empty array, esiste già l'impegno esterno
                //in questo caso rimanente : (linkedNlev == 1 && nphase == 2) 
                //QueryCreator.MarkEvent("FOUND SIMPLE on ver " + verCsa["idver"]);
                importi.Add(new InfoImpegno(verCsa["idepexp"], importo, idrelatedMain));
                return importi; // completamente imputato al parent specificato
            }


            if (nuovaGestione) {
                object idepexp = nphase == 2 ? getIdEpExpByIdRelated(idrelatedMain, 1) : DBNull.Value;
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
                return importi;
            }


            string filter = QHS.AppAnd(
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()), QHS.CmpEq("CE.idcsa_import", verCsa["idcsa_import"]),
                QHS.CmpEq("CE.idver", verCsa["idver"])
            );

            //if (idupb != null && idupb != DBNull.Value) {
            //    filter = QHS.AppAnd(filter, QHS.CmpEq("EY.idupb", idupb));
            //}
            //Legge la ripartizione EP
            //string sql = "select CE.ndetail,CE.idepexp,CE.quota FROM csa_importver_epexp CE " +
            //             " join epexpyear ey on CE.idepexp=ey.idepexp " +
            //             " where " + filter +
            //             " order by CE.ndetail"; //,CE.idepexp,CE.quota
            //Esamina il caso in cui c'è una tabella di associazione oppure nulla, ossia è tutto generato e non associato da configurazione
            var exp = getImportVer_EpExp(verCsa["idcsa_import"], verCsa["idver"]); //Conn.SQLRunner(sql);

            if (exp.Length > 0) {
                decimal totaleperc_residuo = 0;
                foreach (DataRow rr in exp) totaleperc_residuo += CfgFn.GetNoNullDecimal(rr["quota"]);
                //MetaData.SumColumn(exp, "quota");
                decimal totale_residuo = importo;
                //QueryCreator.MarkEvent("FOUND on ver " + verCsa["idver"]+" phase "+nphase);
                foreach (DataRow r in exp) {
                    string idrel = idrelatedMain + "§" + r["ndetail"];

                    decimal quotaCorrente = CfgFn.GetNoNullDecimal(r["quota"]);
                    decimal quotaDaConsiderare = quotaCorrente / totaleperc_residuo;
                    decimal quotaImporto =
                        CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(quotaDaConsiderare) * totale_residuo);
                    totale_residuo -= quotaImporto;
                    totaleperc_residuo -= quotaCorrente;

                    int linkedNlev = CfgFn.GetNoNullInt32(r["nphase"]);
                    //CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                    if (linkedNlev >= nphase) continue; //impegno esistente, salta questa riga
                    //in questo caso rimanente : (linkedNlev == 1 && nphase == 2) 
                    importi.Add(new InfoImpegno(r["idepexp"], quotaImporto, idrel));
                    //QueryCreator.MarkEvent("ADDED on ver" + verCsa["idver"]+" phase "+nphase);
                    // quota imputata al parent specificato                    
                }

                return importi;
            }




            var expenseVersa = getImportVer_Expense(verCsa["idcsa_import"], verCsa["idver"]);
            //Conn.RUN_SELECT("csa_importver_expense", "ndetail,idexp,amount", null,//
            //QHS.AppAnd(QHS.CmpEq("idcsa_import", verCsa["idcsa_import"]), QHS.CmpEq("idver", verCsa["idver"])),
            //null,false);
            if (expenseVersa.Length > 0) {
                //ripartisce l'EP come nel finanziario
                foreach (DataRow r in expenseVersa) {
                    string idrel = idrelatedMain + "§" + r["ndetail"];
                    decimal quotaImporto = CfgFn.GetNoNullDecimal(r["amount"]);
                    InfoImpegno i = new InfoImpegno(DBNull.Value, quotaImporto, idrel);
                    i.idupb = r["idupb"];
                    //Conn.DO_READ_VALUE("expenseyear",
                    //    QHS.AppAnd(QHS.CmpEq("idexp", r["idexp"]), QHS.CmpEq("ayear", Conn.GetEsercizio())), "idupb");
                    importi.Add(i);
                    // quota imputata al parent specificato                    
                }

                return importi;
            }



            importi.Add(new InfoImpegno(getIdEpExpByIdRelated(idrelatedMain, nphase - 1), importo, idrelatedMain));
            return importi;


        }

        /// <summary>
        /// Restituisce una serie di "parent idepexp, amount" per un insieme di impegni di budget da creare
        /// Se un impegno di budget parent non esiste , restituisce DBNull per la voce parent
        /// Se l'impegno di budget da creare è già presente su db come esterno, salta quella voce
        /// </summary>
        /// <param name="verCsa"></param>
        /// <param name="nphase"></param>
        /// <returns></returns>
        List<InfoImpegno> getAmountsForAccertamentiVersamenti(DataRow verCsa, int nphase) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (verCsa.Table.Columns.Contains("amount")) colName = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(verCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(verCsa);
            //ShowMessage(idrelatedMain);
            importi.Add(new InfoImpegno(getIdEpAccByIdRelated(idrelatedMain, nphase - 1), importo, idrelatedMain));
            return importi;

        }


        List<InfoImpegno> getAmountsForScrittureVer(DataRow verCsa, object idupb, bool nuovaGestione) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (verCsa.Table.Columns.Contains("amount")) colName = "amount";
            if (verCsa.Table.Columns.Contains("quota")) colName = "quota";
            decimal importo = CfgFn.GetNoNullDecimal(verCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(verCsa);
            if (verCsa["idepexp"] != DBNull.Value) {
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(verCsa["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", verCsa["idepexp"]),
                            "nphase"));
                    nphaseForIdEpExp[CfgFn.GetNoNullInt32(verCsa["idepexp"])] = linkedNlev;
                }

                //int linkedNlev =
                //    CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", verCsa["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(verCsa["idepexp"], importo, idrelatedMain));
                    return importi; // completamente imputato all'impegno specificato
                }
            }

            object idepexp = getIdEpExpByIdRelated(idrelatedMain, 2);

            if (nuovaGestione) {
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
                return importi;
            }

            string filter = QHS.AppAnd(
                QHS.CmpEq("EY.ayear", Conn.GetEsercizio()), QHS.CmpEq("CE.idcsa_import", verCsa["idcsa_import"]),
                QHS.CmpEq("CE.idver", verCsa["idver"])
            );

            //Legge la ripartizione EP
            //string sql = "select CE.ndetail,CE.idepexp,CE.quota FROM csa_importver_epexp CE " +
            //             " join epexpyear ey on CE.idepexp=ey.idepexp " +
            //             " where " + filter + " order by CE.ndetail,CE.idepexp,CE.quota";

            //Esamina il caso in cui c'è una tabella di associazione oppure nulla, ossia è tutto generato e non associato da configurazione
            var exp = getImportVer_EpExp(verCsa["idcsa_import"], verCsa["idver"]); //Conn.SQLRunner(sql);
            object ndetail = DBNull.Value;
            if (verCsa.Table.Columns.Contains("ndetail")) {
                ndetail = verCsa["ndetail"];
            }

            if (exp.Length == 0 && ndetail == DBNull.Value) {
                //non c'è nè la ripartizione EP e nè quella finanziaria, restituisce un a riga semplice 
                importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain)); //
                return importi;
            }

            if (exp.Length == 0 && ndetail != DBNull.Value) {
                //c'è la ripartizione finanziaria ma NON quella EP, l'id-detail è quello della rip. finanziaria
                string idrel = idrelatedMain + "§" + ndetail;
                object idepexpDetDet =
                    getIdEpExpByIdRelated(idrel, 2); //prende l'eventuale idepexp esistente con l'id siffatto
                importi.Add(new InfoImpegno(idepexpDetDet, importo, idrel));
                return importi;
            }

            //c'è la rip. ep ed eventualmente anche quella finanziaria
            if (exp.Length == 1) {
                DataRow r = exp[0];
                string idrel = idrelatedMain + "§" + r["ndetail"];
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                }

                //int linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(r["idepexp"], importo, idrel));
                    return importi;
                }

                object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                importi.Add(new InfoImpegno(idepexpDet, importo, idrel));
                return importi;
            }

            if (ndetail != DBNull.Value) {
                //in questo caso c'è la doppia ripartizione, pretendo un match sul n. dettaglio, se lo trovo uso quella riga "secca"
                DataRow[] exactMatch = exp._Filter(r => r["ndetail"].Equals(ndetail)).ToArray();
                //exp.Select(QHC.CmpEq("ndetail", ndetail));
                if (exactMatch.Length > 0) {
                    DataRow r = exactMatch[0];
                    string idrel = idrelatedMain + "§" + r["ndetail"];
                    int linkedNlev = 0;
                    object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                    if (nPhase != null) {
                        linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                    }
                    else {
                        linkedNlev =
                            CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]),
                                "nphase"));
                    }

                    //int linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                    if (linkedNlev == 2) {
                        importi.Add(new InfoImpegno(r["idepexp"], importo, idrel));
                        return importi;
                    }

                    object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                    importi.Add(new InfoImpegno(idepexpDet, importo, idrel));
                    return importi;
                }
            }

            decimal totaleperc_residuo = 0;
            foreach (DataRow rr in exp) totaleperc_residuo += CfgFn.GetNoNullDecimal(rr["quota"]);
            //(MetaData.SumColumn(exp, "quota");
            decimal totale_residuo = importo;

            foreach (DataRow r in exp) {
                string idrel = idrelatedMain + "§" + r["ndetail"];
                decimal quotaCorrente = CfgFn.GetNoNullDecimal(r["quota"]);
                decimal quotaDaConsiderare = quotaCorrente / totaleperc_residuo;
                decimal quotaImporto = CfgFn.RoundValuta(CfgFn.GetNoNullDecimal(quotaDaConsiderare) * totale_residuo);
                totale_residuo -= quotaImporto;
                totaleperc_residuo -= quotaCorrente;
                int linkedNlev = 0;
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(r["idepexp"])];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                }

                //int linkedNlev =  CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", r["idepexp"]), "nphase"));
                if (linkedNlev == 2) {
                    importi.Add(new InfoImpegno(r["idepexp"], quotaImporto, idrel));
                    continue;
                }

                object idepexpDet = getIdEpExpByIdRelated(idrel, 2);
                importi.Add(new InfoImpegno(idepexpDet, quotaImporto, idrel));
                // quota imputata al parent specificato                    
            }

            return importi;
        }


        List<InfoImpegno> getAmountsForScrittureVerRicavo(DataRow verCsa) {
            List<InfoImpegno> importi = new List<InfoImpegno>();
            string colName = "importo";
            if (verCsa.Table.Columns.Contains("amount")) colName = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(verCsa[colName]);
            if (importo < 0) importo = -importo;
            string idrelatedMain = BudgetFunction.GetIdForDocument(verCsa);
            //MetaFactory.factory.getSingleton<IMessageShower>().Show(idrelatedMain);
            object idepexp = getIdEpAccByIdRelated(idrelatedMain, 2);
            importi.Add(new InfoImpegno(idepexp, importo, idrelatedMain));
            return importi;
        }

        Hashtable idupbForEpExp = new Hashtable();
        Hashtable idupbForEpAcc = new Hashtable();

        public object getUpbForEpExp(object idepexp, object idupb, DataTable epexpyear) {
            if (idepexp == null || idepexp == DBNull.Value) return idupb;
            if (idupbForEpExp.ContainsKey(CfgFn.GetNoNullInt32(idepexp))) {
                return idupbForEpExp[CfgFn.GetNoNullInt32(idepexp)];
            }

            if (epexpyear != null) {
                DataRow[] offline = epexpyear.Select(QHC.CmpEq("idepexp", idepexp));
                if (offline.Length > 0) return offline[0]["idupb"];
            }

            object u = Conn.DO_READ_VALUE("epexpyear",
                QHS.AppAnd(QHS.CmpEq("idepexp", idepexp), QHS.CmpEq("ayear", Conn.GetEsercizio())),
                "idupb");
            if (u != null && u != DBNull.Value) {
                idupbForEpExp[CfgFn.GetNoNullInt32(idepexp)] = u;
                return u;
            }

            return idupb;
        }

        public object getUpbForEpAcc(object idepacc, object idupb) {
            if (idepacc == null || idepacc == DBNull.Value) return idupb;
            if (CfgFn.GetNoNullInt32(idepacc) >= 990000000) return idupb;
            if (idupbForEpAcc.ContainsKey(CfgFn.GetNoNullInt32(idepacc))) {
                return idupbForEpAcc[CfgFn.GetNoNullInt32(idepacc)];
            }

            object u = Conn.DO_READ_VALUE("epaccyear",
                QHS.AppAnd(QHS.CmpEq("idepacc", idepacc), QHS.CmpEq("ayear", Conn.GetEsercizio())),
                "idupb");
            if (u != null && u != DBNull.Value) {
                idupbForEpAcc[CfgFn.GetNoNullInt32(idepacc)] = u;
                return u;
            }

            return idupb;
        }

        private bool generaImpegniRiepilogoNuovaGestione(BudgetFunction bf, DataRow curr, int nphase) {

            //curr è riga di csa_importriep_partitionview
            // legge idupb impostato sulla riga
            object idupb = curr["idupb"];
            // quando sulla riga  in elaborazione non esiste un preimpegno di budget singolo
            // nè una ripartizione in preimpegni di budget, ma esiste solo un impegno finanziario singolo, deve leggere l'idupb dall'impegno finanziario
            // (situazione descritta nel task 10449)
            // Leggo eventuale ripartizione in preimpegni di budget       
            if (idupb == DBNull.Value) {
                idupb = "0001";
            }

            object idaccCost = curr["idacc"];
            if (!EP.isCosto(idaccCost)) return false;

            decimal importo = CfgFn.GetNoNullDecimal(curr["amount"]);
            if (importo < 0) return false;
            DataTable csaImport;
            if (DS.Tables.Contains("csa_import")) {
                csaImport = DS.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Riep. " +
                         curr["idriep"] + " Import. " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0');
            if (curr.Table.Columns.Contains("ndetail")) {
                doc += "/" + curr["ndetail"];
            }

            List<InfoImpegno> listaInfo = getAmountsForImpegniRiep(curr, nphase, true);
            foreach (InfoImpegno i in listaInfo) {

                object idaccmotive = getAccMotiveForSiope(curr["idsor_siope"], idaccCost);
                object idreg = curr["idreg"];
                if (idreg == DBNull.Value) idreg = _rConfig["idreg_csa"];
                DataRow currEpExp = bf.addEpExp(idreg, getIdMan(idupb), i.amount,
                    doc, adate, idaccCost, idupb, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addImpegnoToDict(currEpExp, i.idrelated);
                idupbForEpExp[(int) currEpExp["idepexp"]] = idupb;
            }

            return true;
        }

        private bool generaImpegniRiepilogo(BudgetFunction bf, DataRow curr, int nphase) {
            // legge idupb impostato sulla riga
            object idupb = curr["idupb"];
            // quando sulla riga  in elaborazione non esiste un preimpegno di budget singolo
            // nè una ripartizione in preimpegni di budget, ma esiste solo un impegno finanziario singolo, deve leggere l'idupb dall'impegno finanziario
            // (situazione descritta nel task 10449)
            // Leggo eventuale ripartizione in preimpegni di budget       
            if (idupb == DBNull.Value) {

                var exp = getImportRiep_EpExp(curr["idcsa_import"], curr["idriep"]);
                //Conn.RUN_SELECT("csa_importriep_epexp", "*", null,
                //QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]), QHS.CmpEq("idriep", curr["idriep"])),
                //null,false);
                if ((curr["idepexp"] == DBNull.Value) && (exp.Length == 0)) {
                    if ((idupb == DBNull.Value) && (curr["idexp"] != DBNull.Value)) {
                        // Legge idupb da impegno finanziario, cercandolo nell'esercizio corrente, assumendo che tale imputazione esista
                        idupb = Conn.DO_READ_VALUE("expenseyear", QHS.AppAnd(QHS.CmpEq("idexp", curr["idexp"]),
                            QHS.CmpEq("ayear", esercizio)), "idupb");
                        if (idupb == DBNull.Value) {
                            ShowMessage(
                                "Il movimento finanziario configurato nella riga di Riepilogo" +
                                curr["idriep"].ToString() +
                                " non esiste nell'esercizio " + esercizio.ToString(), "Attenzione");
                            return false;
                        }
                    }
                    else {
                        idupb = "0001";
                    }
                }
            }

            object idaccCost = curr["idacc"];
            if (!EP.isCosto(idaccCost)) return false;

            decimal importo = CfgFn.GetNoNullDecimal(curr["importo"]);
            if (importo < 0) return false;
            DataTable csaImport;
            if (curr.Table.DataSet.Tables.Contains("csa_import")) {
                csaImport = curr.Table.DataSet.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Riep. " +
                         curr["idriep"] + " Import. " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0');

            List<InfoImpegno> listaInfo = getAmountsForImpegniRiep(curr, nphase, false);
            foreach (InfoImpegno i in listaInfo) {
                object curridUPB = i.idupb;
                if (curridUPB == DBNull.Value) curridUPB = idupb;
                object currUPB = getUpbForEpExp(i.parIdExp, curridUPB, bf?.D.Tables["epexpyear"]);
                object idaccmotive = getAccMotiveForSiope(curr["idsor_siope"], idaccCost);

                DataRow currEpExp = bf.addEpExp(_rConfig["idreg_csa"], getIdMan(currUPB), i.amount,
                    doc, adate, idaccCost, currUPB, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addImpegnoToDict(currEpExp, i.idrelated);
                idupbForEpExp[(int) currEpExp["idepexp"]] = currUPB;
            }

            if (listaInfo.Count == 0 && nphase == 2) {
                ShowMessage($"Impegno di budget non trovato per riepilogo n. {curr["idriep"]}", "Errore");
            }

            return true;
        }

        private bool generaAccertamentiRiepilogo(BudgetFunction bf, DataRow curr, int nphase, bool nuovaGestione) {

            object idupb = curr["idupb"];
            if (idupb == DBNull.Value) {
                idupb = "0001";
            }

            object idaccRevenue = _rConfig["idacc_revenue_gross_csa"];
            if (!EP.isRicavo(idaccRevenue)) return false;
            string colname = "importo";
            if (nuovaGestione) colname = "amount";
            decimal importo = CfgFn.GetNoNullDecimal(curr[colname]);
            if (importo > 0) return false;

            DataTable csaImport;
            if (DS.Tables.Contains("csa_import")) {
                csaImport = DS.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Riep. n." +
                         curr["idriep"] + " Import. CSA " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0');
            if (nuovaGestione) doc += "/" + curr["ndetail"];

            List<InfoImpegno> listaInfo = getAmountsForAccertamentiRiep(curr, nphase);
            foreach (InfoImpegno i in listaInfo) {
                object currUPB = getUpbForEpAcc(i.parIdExp, idupb);
                object idsiopeincome_csa = _rConfig["idsiopeincome_csa"];
                object idaccmotive = getAccMotiveForSiope(idsiopeincome_csa, idaccRevenue);
                object idreg = DBNull.Value;
                if (nuovaGestione) idreg = curr["idreg"];
                if (idreg == DBNull.Value) idreg = _rConfig["idreg_csa"];
                DataRow currEpAcc = bf.addEpAcc(idreg, getIdMan(currUPB), i.amount,
                    doc, adate, idaccRevenue, currUPB, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addAccertamentoToDict(currEpAcc, i.idrelated);
                idupbForEpAcc[(int) currEpAcc["idepacc"]] = currUPB;
            }

            if (listaInfo.Count == 0 && nphase == 2) {
                ShowMessage($"Accertamento di budget non trovato per riepilogo n. {curr["idriep"]}", "Errore");
            }

            return true;
        }

        private bool generaImpegniVersamentiNuovaGestione(BudgetFunction bf, DataRow curr, int nphase) {

            bool recupero = curr["flagclawback"].ToString().ToUpper() == "S";
            decimal amount = CfgFn.GetNoNullDecimal(curr["amount"]);
            bool enableImpegni = false;
            object idreg = DBNull.Value;

            //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
            if (recupero == false && EP.isCosto(curr["idacc_cost"]) && amount > 0) {
                enableImpegni = true;
                idreg = curr["idreg_agency"];
            }

            // Versamento recuperi  COSTO   A  debito vs percipiente
            if (recupero == true && amount < 0 && EP.isCosto(curr["idacc_cost"])) {
                enableImpegni = true;
                idreg = curr["idreg"];
                if (idreg == DBNull.Value) idreg = _rConfig["idreg_csa"];
            }

            if (!enableImpegni) {
                //QueryCreator.MarkEvent("Disabled on ver " + curr["idver"]);
                return false;
            }

            // legge idupb impostato sulla riga
            object idupb = curr["idupb"];


            object idaccCost = curr["idacc_cost"];
            if (!EP.isCosto(idaccCost)) return false;

            object idepexp = curr["idepexp"];
            int linkedNlev = idepexp == DBNull.Value ? 0 : 1;

            object parIdEpExp = DBNull.Value;
            if (linkedNlev == (nphase - 1)) {
                parIdEpExp = idepexp;
            }

            DataTable csaImport;
            if (DS.Tables.Contains("csa_import")) {
                csaImport = DS.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Versam. " +
                         curr["idver"] + " Import. " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0') + "/" + curr["ndetail"];
            object description = doc + " - Voce: " + curr["vocecsa"].ToString();
            List<InfoImpegno> listaInfo = getAmountsForImpegniVersamenti(curr, nphase, true);
            foreach (InfoImpegno i in listaInfo) {
                object idsor_siope = curr["idsor_siope_cost"];
                object idaccmotive = getAccMotiveForSiope(idsor_siope, idaccCost);
                DataRow currEpExp = bf.addEpExp(idreg, getIdMan(idupb), i.amount,
                    description, adate, idaccCost, idupb, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addImpegnoToDict(currEpExp, i.idrelated);
                idupbForEpExp[(int) currEpExp["idepexp"]] = idupb;
            }

            return true;
        }

        private bool generaImpegniVersamenti(BudgetFunction bf, DataRow curr, int nphase) {

            bool recupero = curr["flagclawback"].ToString().ToUpper() == "S";
            decimal amount = CfgFn.GetNoNullDecimal(curr["importo"]);
            bool enableImpegni = false;
            object idreg = DBNull.Value;
            //CONTRIBUTI con importo POSITIVO: costo a debito con idacc_cost ove COSTO = idacc_cost DEBITO = ISNULL(_debit , _expense )
            if (recupero == false && EP.isCosto(curr["idacc_cost"]) &&
                (curr["idacc_debit"] != DBNull.Value || curr["idacc_expense"] != DBNull.Value)
                && amount > 0) {
                enableImpegni = true;
                idreg = curr["idreg_agency"];
            }

            // Versamento recuperi  COSTO   A  debito vs percipiente
            if (recupero == true && amount < 0 && EP.isCosto(curr["idacc_cost"])) {
                enableImpegni = true;
                idreg = _rConfig["idreg_csa"];
            }

            if (!enableImpegni) {
                //QueryCreator.MarkEvent("Disabled on ver " + curr["idver"]);
                return false;
            }

            // legge idupb impostato sulla riga
            object idupb = curr["idupb"];
            // quando sulla riga  in elaborazione non esiste un preimpegno di budget singolo
            // nè una ripartizione in preimpegni di budget, ma esiste solo un impegno finanziario singolo, deve leggere l'idupb dall'impegno finanziario
            // (situazione descritta nel task 10449)
            // Leggo eventuale ripartizione in preimpegni di budget
            if (idupb == DBNull.Value) {
                var exp = getImportVer_EpExp(curr["idcsa_import"], curr["idver"]);
                //Conn.RUN_SELECT("csa_importver_epexp", "*", null,
                //QHS.AppAnd(QHS.CmpEq("idcsa_import", curr["idcsa_import"]), QHS.CmpEq("idver", curr["idver"])), null,
                //false);
                if ((curr["idepexp"] == DBNull.Value) && (exp.Length == 0)) {
                    if ((idupb == DBNull.Value) && (curr["idexp_cost"] != DBNull.Value)) {
                        // Legge idupb da impegno finanziario, cercandolo nell'esercizio corrente, assumendo che tale imputazione esista
                        idupb = Conn.DO_READ_VALUE("expenseyear", QHS.AppAnd(QHS.CmpEq("idexp", curr["idexp_cost"]),
                            QHS.CmpEq("ayear", esercizio)), "idupb");
                        if (idupb == DBNull.Value) {
                            ShowMessage(
                                "Il movimento finanziario configurato nella riga di Versamento " +
                                curr["idver"].ToString() +
                                " non esiste nell'esercizio " + esercizio.ToString(), "Attenzione");
                            return false;
                        }
                    }
                    else {
                        idupb = "0001";
                    }
                }
            }

            object idaccCost = curr["idacc_cost"];
            if (!EP.isCosto(idaccCost)) return false;

            object idepexp = curr["idepexp"];
            int linkedNlev = 0;
            if (idepexp != DBNull.Value) {
                object nPhase = nphaseForIdEpExp[CfgFn.GetNoNullInt32(idepexp)];
                if (nPhase != null) {
                    linkedNlev = CfgFn.GetNoNullInt32(nPhase);
                }
                else {
                    linkedNlev =
                        CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", idepexp), "nphase"));
                }

                //linkedNlev = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", idepexp), "nphase"));
            }

            if (linkedNlev == 2) return false;
            object parIdEpExp = DBNull.Value;
            if (linkedNlev == (nphase - 1)) {
                parIdEpExp = idepexp;
            }

            DataTable csaImport;
            if (curr.Table.DataSet.Tables.Contains("csa_import")) {
                csaImport = curr.Table.DataSet.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Versam. " +
                         curr["idver"] + " Import. " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0');
            object description = doc + " - Voce: " + curr["vocecsa"].ToString();
            List<InfoImpegno> listaInfo = getAmountsForImpegniVersamenti(curr, nphase, false);
            foreach (InfoImpegno i in listaInfo) {
                object curridUPB = i.idupb;
                if (curridUPB == DBNull.Value) curridUPB = idupb;
                object currUPB = getUpbForEpExp(i.parIdExp, curridUPB, bf?.D.Tables["epexpyear"]);
                object idsor_siope = curr["idsor_siope_cost"];
                object idaccmotive = getAccMotiveForSiope(idsor_siope, idaccCost);
                DataRow currEpExp = bf.addEpExp(idreg, getIdMan(currUPB), i.amount,
                    description, adate, idaccCost, currUPB, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addImpegnoToDict(currEpExp, i.idrelated);
            }

            if (listaInfo.Count == 0 && nphase == 2) {
                ShowMessage($"Impegno di budget non trovato per versamento n. {curr["idver"]}", "Errore");
            }

            return true;
        }

        private bool generaAccertamentiVersamenti(BudgetFunction bf, DataRow curr, int nphase, bool nuovaGestione) {
            bool recupero = curr["flagclawback"].ToString().ToUpper() == "S";
            string colname = "importo";
            if (nuovaGestione) colname = "amount";
            decimal amount = CfgFn.GetNoNullDecimal(curr[colname]);
            bool enableAccertamenti = false;
            object idreg = DBNull.Value;
            object idaccmotive = DBNull.Value;
            // Contributi negativi   credito vs erario A  RICAVO 
            if (nuovaGestione) {
                if (recupero == false && (curr["idacc_cost"] != DBNull.Value)
                                      && amount < 0 && EP.isRicavo(curr["idacc_revenue"])
                                      && curr["idacc_agency_credit"] != DBNull.Value) {

                    enableAccertamenti = true;
                    idreg = curr["idreg_agency"];
                }
            }
            else {
                if (recupero == false && (curr["idcsa_contracttax"] != DBNull.Value ||
                                          curr["idcsa_contractkinddata"] != DBNull.Value
                                      ) /*(curr["idfin_cost"] != DBNull.Value || curr["idexp_cost"] != DBNull.Value)*/
                                      && amount < 0 && EP.isRicavo(curr["idacc_revenue"])
                                      && curr["idacc_agency_credit"] != DBNull.Value) {

                    enableAccertamenti = true;
                    idreg = curr["idreg_agency"];
                }
            }

            //Versamento recuperi   credito vs percipiente A  RICAVO 
            if (recupero == true && EP.isRicavo(curr["idacc_revenue"]) && amount > 0) {
                enableAccertamenti = true;
                idreg = _rConfig["idreg_csa"];
            }

            if (!enableAccertamenti) return false;

            object idupb = curr["idupb"];
            if (idupb == DBNull.Value) {
                idupb = "0001";
            }

            object idaccRevenue = curr["idacc_revenue"];
            if (!EP.isRicavo(idaccRevenue)) return false;
            object idsor_siope_income = curr["idsor_siope_income"];
            DataTable csaImport;
            if (DS.Tables.Contains("csa_import")) {
                csaImport = DS.Tables["csa_import"];
            }
            else {
                csaImport = Conn.RUN_SELECT("csa_import", "*", null, QHS.CmpEq("idcsa_import", curr["idcsa_import"]),
                    null, false);
            }

            object adate = csaImport.Rows[0]["adate"];
            object yimport = csaImport.Rows[0]["yimport"];
            object nimport = csaImport.Rows[0]["nimport"];
            object doc = "Versam. n." +
                         curr["idver"] + " Import. CSA " +
                         yimport + "/" +
                         nimport.ToString().PadLeft(2, '0');
            object description = doc + " - Voce: " + curr["vocecsa"].ToString();
            List<InfoImpegno> listaInfo = getAmountsForAccertamentiVersamenti(curr, nphase);
            foreach (InfoImpegno i in listaInfo) {
                object currUPB = getUpbForEpAcc(i.parIdExp, idupb);

                idaccmotive = getAccMotiveForSiope(idsor_siope_income, idaccRevenue);

                DataRow currEpAcc = bf.addEpAcc(idreg, getIdMan(currUPB), i.amount,
                    description, adate, idaccRevenue, currUPB, i.idrelated, doc, adate,
                    DBNull.Value, DBNull.Value, nphase, i.parIdExp, idaccmotive);
                addAccertamentoToDict(currEpAcc, i.idrelated);
                idupbForEpAcc[(int) currEpAcc["idepacc"]] = currUPB;
            }

            if (listaInfo.Count == 0 && nphase == 2) {
                ShowMessage($"Accertamento di budget non trovato per versamento n. {curr["idver"]}", "Errore");
            }

            return true;
        }

        Hashtable idManForUpb = new Hashtable();

        void setIdManForUpb(object idupb, object idman) {
            idManForUpb[idupb.ToString()] = idman;
        }

        object getIdMan(object idupb) {
            if (idupb == DBNull.Value || idupb == null) return DBNull.Value;
            if (idManForUpb.ContainsKey(idupb.ToString())) return idManForUpb[idupb.ToString()];

            if (DS.Tables.Contains("upb")) {
                DataRow[] upb = DS.Tables["upb"].Select(QHC.CmpEq("idupb", idupb));
                if (upb.Length > 0) {
                    idManForUpb[idupb.ToString()] = upb[0]["idman"];
                    return upb[0]["idman"];
                }

            }

            object idman = Conn.DO_READ_VALUE("upb", QHS.CmpEq("idupb", idupb), "idman");
            idManForUpb[idupb.ToString()] = idman;
            if (idman == null) return DBNull.Value;
            return idman;
        }

        private readonly Dictionary<int, DataRow> _listaImpegni = new Dictionary<int, DataRow>();
        private readonly Dictionary<int, DataRow> _listaAccertamenti = new Dictionary<int, DataRow>();
        private readonly Dictionary<string, DataRow> _listaImpegniByIdRelated = new Dictionary<string, DataRow>();
        private readonly Dictionary<string, DataRow> _listaPreimpegniByIdRelated = new Dictionary<string, DataRow>();
        private readonly Dictionary<string, DataRow> _listaAccertamentiByIdRelated = new Dictionary<string, DataRow>();

        private readonly Dictionary<string, DataRow> _listaPreaccertamentiByIdRelated =
            new Dictionary<string, DataRow>();

        void addAccertamentoToDict(DataRow r, string idrel) {
            if (r == null) return;
            if (r["nphase"].ToString() == "1") {
                _listaPreaccertamentiByIdRelated[idrel] = r;
            }
            else {
                _listaAccertamentiByIdRelated[idrel] = r;
            }


        }

        void removeImpegnoFromDict(int nphase, string idrel) {
            if (nphase == 1) {
                if (_listaPreimpegniByIdRelated.ContainsKey(idrel)) _listaPreimpegniByIdRelated.Remove(idrel);
            }

            if (nphase == 2) {
                if (_listaImpegniByIdRelated.ContainsKey(idrel)) _listaImpegniByIdRelated.Remove(idrel);
            }
        }

        void removeAccertamentoFromDict(int nphase, string idrel) {
            if (nphase == 1) {
                if (_listaPreaccertamentiByIdRelated.ContainsKey(idrel)) _listaPreaccertamentiByIdRelated.Remove(idrel);
            }

            if (nphase == 2) {
                if (_listaAccertamentiByIdRelated.ContainsKey(idrel)) _listaAccertamentiByIdRelated.Remove(idrel);
            }
        }

        void addImpegnoToDict(DataRow r, string idrel) {
            if (r == null) {
                return;
            }

            if (r["nphase"].ToString() == "1") {
                _listaPreimpegniByIdRelated[idrel] = r;
            }
            else {
                _listaImpegniByIdRelated[idrel] = r;
            }

            nphaseForIdEpExp[(int) r["idepexp"]] = CfgFn.GetNoNullInt32(r["nphase"]);

        }

        Dictionary<int, bool> _listaAccertamentiDiffProrata = new Dictionary<int, bool>();
        Dictionary<int, bool> _listaImpegniDiffProrata = new Dictionary<int, bool>();
        
        void clearAllDictionary() {
            _listaImpegni.Clear();
            _listaAccertamenti.Clear();
            _listaAccertamentiDiffProrata.Clear();
            _listaAccertamentiByIdRelated.Clear();
            _listaPreaccertamentiByIdRelated.Clear();
            _listaImpegniByIdRelated.Clear();
            _listaImpegniDiffProrata.Clear();
            _listaPreimpegniByIdRelated.Clear();
            existContractEpExp.Clear();
            existContractTaxEpExp.Clear();
            preimpegniAccorpati.Clear();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="idrelated"></param>
        /// <param name="nphase"></param>
        /// <param name="idepexp">id dell'impegno di budget, ove già noto</param>
        /// <returns></returns>
        object getIdEpExpByIdRelated(string idrelated, int nphase) {
            //object idepexp = null;

            //Se deve generare tutte le fasi, tipicamente quando è la prima volta che genera qualcosa, 
            //  non cerca una fase precedente
            if (nphase == 0) return DBNull.Value;

            ////se deve generare solo gli impegni e c'è un movimento collegato l'impegno si intende essere quello
            //if (nphase == 2 && idepexp != null) return idepexp;

            ////se deve generare solo gli impegni e c'è un impegno assegnato l'impegno si intende essere quello parent di quello dato
            //if (nphase == 1 && idepexp != null) {
            //    object par = Conn.DO_READ_VALUE("epexp", QHS.CmpEq("idepexp", idepexp), "paridepexp");
            //    if (par != null && par != DBNull.Value) return par;
            //}

            if ((nphase == 1) && _listaPreimpegniByIdRelated.ContainsKey(idrelated)) {
                DataRow r = _listaPreimpegniByIdRelated[idrelated];
                if (r.Table.TableName != "epexp") return DBNull.Value;
                return r["idepexp"];
            }

            if ((nphase == 2) && _listaImpegniByIdRelated.ContainsKey(idrelated)) {
                DataRow r = _listaImpegniByIdRelated[idrelated];
                if (r.Table.TableName != "epexp") return DBNull.Value;
                return r["idepexp"];
            }

            if (nphase == 1 && childExcluded != null && idrelated.StartsWith(childExcluded)) {
                // è certo per costruzione che non esiste il preimpegno cercato su db, è stato già ricercato a monte 
                // come discendente di childExcluded
                return DBNull.Value;
            }

            return Conn.DO_READ_VALUE("epexp",
                       QHS.AppAnd(QHS.CmpEq("idrelated", idrelated), QHS.CmpEq("nphase", nphase)), "idepexp") ??
                   DBNull.Value;
        }




        object getIdEpAccByIdRelated(string idrelated, int nphase) {
            if (nphase == 0) return DBNull.Value;
            if ((nphase == 1) && _listaPreaccertamentiByIdRelated.ContainsKey(idrelated)) {
                DataRow r = _listaPreaccertamentiByIdRelated[idrelated];
                if (r.Table.TableName != "epacc") return DBNull.Value;
                return r["idepacc"];
            }

            if ((nphase == 2) && _listaAccertamentiByIdRelated.ContainsKey(idrelated)) {
                DataRow r = _listaAccertamentiByIdRelated[idrelated];
                if (r.Table.TableName != "epacc") return DBNull.Value;
                return r["idepacc"];
            }

            if (nphase == 1 && childExcluded != null && idrelated.StartsWith(childExcluded)) {
                // è certo per costruzione che non esiste il preimpegno cercato su db, è stato già ricercato a monte 
                // come discendente di childExcluded
                return DBNull.Value;
            }

            return Conn.DO_READ_VALUE("epacc",
                       QHS.AppAnd(QHS.CmpEq("idrelated", idrelated), QHS.CmpEq("nphase", nphase)), "idepacc") ??
                   DBNull.Value;
        }

        void clearHashImpegniByIdRelated() {
            _listaPreimpegniByIdRelated.Clear();
            _listaImpegniByIdRelated.Clear();
            _listaPreaccertamentiByIdRelated.Clear();
            _listaAccertamentiByIdRelated.Clear();
        }

        void standardPreSave() {
            clearHashImpegniByIdRelated();
        }

        void updateCausaleCostoFatturaAcquistoCollegata(DataRow mainMandate) {
			//Prende tutti i dettagli fattura collegati al dettaglio ordine
			//DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
			//	QHS.AppAnd(QHS.CmpEq("idmankind", mainMandate["idmankind"]), QHS.CmpEq("yman", mainMandate["yman"]),
			//		QHS.CmpEq("nman", mainMandate["nman"])), null, false);
			foreach (DataRow md in DS.Tables["mandatedetail"]._Filter(q.keyCmp(mainMandate))) {
                if (rateoOFatturaARicevere(md)) continue;
                //task 10014, successivamente 10416
                int annoDettaglio = CfgFn.GetNoNullInt32(md["yman"]);
                object oDataInizio = md["start"];
                if (oDataInizio != DBNull.Value) {
                    annoDettaglio = ((DateTime) oDataInizio).Year;
                }

                object idupb = md["idupb"];
                object idupb_iva = md["idupb_iva"];
                if (annoDettaglio < minimoAnnoImpegniDiBudget) continue;
                //Prende tutti i dettagli fattura collegati al dettaglio ordine
                //DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                //    QHS.AppAnd(QHS.CmpEq("idmankind", md["idmankind"]), QHS.CmpEq("yman", md["yman"]),
                //        QHS.CmpEq("nman", md["nman"]), QHS.CmpEq("manrownum", md["rownum"])), null, false);
                if (DS.Tables["invoicedetail"] == null) return;
                //foreach (DataRow rInvDet in invDetail.Rows) {
                foreach (DataRow rInvDet in DS.Tables["invoicedetail"]._Filter(q.eq("idmankind", md["idmankind"]) & q.eq("yman", md["yman"]) & q.eq("nman", md["nman"]) & q.eq("manrownum", md["rownum"]))) {
                    object idaccmotiveInvDet = rInvDet["idaccmotive"];
                    object idupb_inv = rInvDet["idupb"];
                    object idupb_iva_inv = rInvDet["idupb_iva"];

                    //aggiorna la causale  del dettaglio fattura                   
                    object idaccmotive = md["idaccmotive"];
                    object idsor_siope = md["idsor_siope"];
                    object idlist = md["idlist"];
                    if (idaccmotive == DBNull.Value) continue;

                    if (idaccmotive.ToString() != idaccmotiveInvDet.ToString()
                        || idupb_inv.ToString() != idupb.ToString()
                        || idupb_iva_inv.ToString() != idupb_iva.ToString()
                    ) {
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idaccmotive", "idsor_siope", "idlist", "idupb", "idupb_iva"},
                            new[] {
                                QHS.quote(idaccmotive), QHS.quote(idsor_siope), QHS.quote(idlist),
                                QHS.quote(md["idupb"]), QHS.quote(md["idupb_iva"])
                            }, 5);
                        doChange(rInvDet, "idaccmotive", idaccmotive);
                        doChange(rInvDet, "idsor_siope", idsor_siope);
                        doChange(rInvDet, "idlist", idlist);
                        doChange(rInvDet, "idupb", idupb);
                        doChange(rInvDet, "idupb_iva", idupb_iva);
                        checkLastError("aggiornando le scritture");

                        if (EP.attivo) {
                            //Aggiorna la scrittura di costo relativa al dettaglio fattura considerato
                            DataRow[] rEntriesOld = EP.GetAccMotiveDetailsYear(idaccmotiveInvDet, rInvDet["yinv"]);
                            object oldIdAcc = DBNull.Value;
                            if (rEntriesOld.Length > 0) {
                                oldIdAcc = rEntriesOld[0]["idacc"];
                            }

                            DataRow[] rEntriesNew = EP.GetAccMotiveDetailsYear(idaccmotive, rInvDet["yinv"]);
                            object newIdAcc = DBNull.Value;
                            if (rEntriesNew.Length > 0) {
                                newIdAcc = rEntriesNew[0]["idacc"];
                            }
                            else {
                                ShowMessage(
                                    $"La causale del dettaglio {md["detaildescription"]} non è configurata nell'anno.",
                                    "Errore");
                                continue;
                            }

                            //if (newIdAcc != DBNull.Value && oldIdAcc.ToString() != newIdAcc.ToString()) {
                            //Conn.DO_UPDATE("entrydetail",
                            //    QHS.AppAnd(
                            //        QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                            //        , QHS.CmpEq("idacc", oldIdAcc)
                            //    ),
                            //    new[] {"idacc"},
                            //    new[] {QHS.quote(newIdAcc)}, 1);
                            //checkLastError("aggiornando le scritture");

                            //Conn.DO_UPDATE("entrydetail",
                            //    QHS.AppAnd(
                            //        QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                            //        , QHS.CmpEq("idaccmotive", idaccmotiveInvDet)
                            //    ),
                            //    new[] {"idaccmotive"},
                            //    new[] {QHS.quote(idaccmotive)}, 1);
                            //checkLastError("aggiornando le scritture");
                            //}
                            //Se nel CP è cambiato l'upb, lo aggiorna anche nella scritture

                            //Conn.DO_UPDATE("entrydetail",
                            //    QHS.AppAnd(
                            //        QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet)),
                            //        QHS.CmpEq("idupb", idupb_inv), QHS.CmpEq("idupb_iva", idupb_iva_inv)
                            //    ),
                            //    new[] { "idupb", "idupb_iva" },
                            //    new[] { QHS.quote(idupb), QHS.quote(idupb_iva) }, 2);
                            if (idupb_inv.ToString() != idupb.ToString() || idupb_iva_inv.ToString() != idupb_iva.ToString()
                                || (newIdAcc != DBNull.Value && oldIdAcc.ToString() != newIdAcc.ToString())) {

                                string msg = "E' stato modificato l'UPB o la Casuale EP. Rigenerare le scritture EP della fattura collegata al Contratto Passivo.";
                                var shower = MetaFactory.factory.getSingleton<IMessageShower>();
                                shower.Show(null, msg, "AVVISO IMPORTANTE", MessageBoxButtons.OK);

                            }
                        }
                    }
                }
            }
        }

        void updateCausaleCostoFatturaAcquistoCollegataAProfessionale(DataRow mainProfService) {
            DataRow[] ProfService = DS.Tables["profservice"]._Filter(q.keyCmp(mainProfService));

            foreach (DataRow pf in ProfService) {

                int annoPrestazione = CfgFn.GetNoNullInt32(pf["ycon"]);
                if (annoPrestazione < minimoAnnoImpegniDiBudget) continue;
                //Prende tutti i dettagli fattura collegati al dettaglio ordine
                DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                    QHS.AppAnd(QHS.CmpEq("ycon", pf["ycon"]),
                        QHS.CmpEq("ncon", pf["ncon"])), null, false);

                foreach (DataRow rInvDet in invDetail.Rows) {
                    object idaccmotiveInvDet = rInvDet["idaccmotive"];
                    if (idaccmotiveInvDet == DBNull.Value) continue;
                    //aggiorna la causale  del dettaglio fattura   e la classificazione Siope                
                    object idaccmotive = pf["idaccmotive"];
                    object idsor_siope = pf["idsor_siope"];

                    if (idaccmotive != DBNull.Value && idaccmotive.ToString() != idaccmotiveInvDet.ToString()) {
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idaccmotive", "idsor_siope"},
                            new[] {QHS.quote(idaccmotive), QHS.quote(idsor_siope)}, 2);
                        checkLastError("aggiornando la fattura");

                        if (EP.attivo) {
                            //Aggiorna la scrittura di costo relativa al dettaglio fattura considerato
                            DataRow[] rEntriesOld = EP.GetAccMotiveDetails(idaccmotiveInvDet);
                            object oldIdAcc = DBNull.Value;
                            if (rEntriesOld.Length > 0) {
                                oldIdAcc = rEntriesOld[0]["idacc"];
                            }

                            DataRow[] rEntriesNew = EP.GetAccMotiveDetails(idaccmotive);
                            object newIdAcc = DBNull.Value;
                            if (rEntriesNew.Length > 0) {
                                newIdAcc = rEntriesNew[0]["idacc"];
                            }

                            //if (newIdAcc != DBNull.Value && oldIdAcc.ToString() != newIdAcc.ToString()) {
                            Conn.DO_UPDATE("entrydetail",
                                QHS.AppAnd(
                                    QHS.CmpEq("yentry", rInvDet["yinv"]),
                                    QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                                    , QHS.CmpEq("idacc", oldIdAcc)
                                ),
                                new[] {"idacc"},
                                new[] {QHS.quote(newIdAcc)}, 1);
                            checkLastError("aggiornando le scritture");

                            Conn.DO_UPDATE("entrydetail",
                                QHS.AppAnd(
                                    QHS.CmpEq("yentry", rInvDet["yinv"]),
                                    QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                                    //,QHS.CmpEq("idacc", oldIdAcc)
                                ),
                                new[] {"idaccmotive"},
                                new[] {QHS.quote(idaccmotive)}, 1);
                            checkLastError("aggiornando le scritture");
                            //}
                        }
                    }
                }
            }
        }


        void updateCausaleRicavoFatturaVenditaCollegata(DataRow mainEstimate) {
            foreach (DataRow md in DS.Tables["estimatedetail"]._Filter(q.keyCmp(mainEstimate))) {
                if (rateoOFatturaARicevere(md)) continue;
                //task 10014, successivamente 10416 
                int annoDettaglio = CfgFn.GetNoNullInt32(md["yestim"]);
                object oDataInizio = md["start"];
                object idupb = md["idupb"];
                object idupb_iva = md["idupb_iva"];

                if (oDataInizio != DBNull.Value) {
                    annoDettaglio = ((DateTime) oDataInizio).Year;
                }

                if (annoDettaglio < minimoAnnoImpegniDiBudget) continue;

                //Prende tutti i dettagli fattura collegati al dettaglio contratto 
                //DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                //    QHS.AppAnd(QHS.CmpEq("idestimkind", md["idestimkind"]), QHS.CmpEq("yestim", md["yestim"]),
                //        QHS.CmpEq("nestim", md["nestim"]), QHS.CmpEq("estimrownum", md["rownum"])), null, false);
                if (DS.Tables["invoicedetail"] == null) return;
                //foreach (DataRow rInvDet in invDetail.Rows) {
                foreach (DataRow rInvDet in DS.Tables["invoicedetail"]._Filter(q.eq("idestimkind", md["idestimkind"]) & q.eq("yestim", md["yestim"]) & q.eq("nestim", md["nestim"]) &q.eq("estimrownum", md["rownum"]))) {
                    object idaccmotiveInvDet = rInvDet["idaccmotive"];
                    object idupb_inv = rInvDet["idupb"];
                    object idupb_iva_inv = rInvDet["idupb_iva"];

                    //aggiorna la causale  del dettaglio fattura                   
                    object idaccmotive = md["idaccmotive"];
                    object idsor_siope = md["idsor_siope"];
                    object idlist = md["idlist"];

                    if (idaccmotive.ToString() != idaccmotiveInvDet.ToString()
                        || idupb_inv.ToString() != idupb.ToString()
                        || idupb_iva_inv.ToString() != idupb_iva.ToString()
                    ) {
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idaccmotive", "idsor_siope", "idlist", "idupb", "idupb_iva"},
                            new[] {
                                QHS.quote(idaccmotive), QHS.quote(idsor_siope), QHS.quote(idlist),
                                QHS.quote(md["idupb"]), QHS.quote(md["idupb_iva"])
                            }, 5);
                        doChange(rInvDet, "idaccmotive", idaccmotive);
                        doChange(rInvDet, "idsor_siope", idsor_siope);
                        doChange(rInvDet, "idlist", idlist);
                        doChange(rInvDet, "idupb", idupb);
                        doChange(rInvDet, "idupb_iva", idupb_iva);
                        checkLastError("aggiornando le scritture");

                        if (EP.attivo) {
                            //Aggiorna la scrittura di costo relativa al dettaglio fattura considerato
                            DataRow[] rEntriesOld = EP.GetAccMotiveDetailsYear(idaccmotiveInvDet, rInvDet["yinv"]);
                            object oldIdAcc = DBNull.Value;
                            if (rEntriesOld.Length > 0) {
                                oldIdAcc = rEntriesOld[0]["idacc"];
                            }

                            DataRow[] rEntriesNew = EP.GetAccMotiveDetailsYear(idaccmotive, rInvDet["yinv"]);
                            object newIdAcc = DBNull.Value;
                            if (rEntriesNew.Length > 0) {
                                newIdAcc = rEntriesNew[0]["idacc"];
                            }

                            //if (newIdAcc != DBNull.Value){
                            //Conn.DO_UPDATE("entrydetail",
                            //    QHS.AppAnd(
                            //        QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                            //        , QHS.CmpEq("idacc", oldIdAcc)
                            //    ),
                            //    new[] { "idacc" },
                            //    new[] { QHS.quote(newIdAcc) }, 1);
                            //checkLastError("aggiornando le scritture");

                            //}
                            //Conn.DO_UPDATE("entrydetail",
                            //    QHS.AppAnd(
                            //        QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //        QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet))
                            //        , QHS.CmpEq("idaccmotive", idaccmotiveInvDet)
                            //    ),
                            //    new[] { "idaccmotive" },
                            //    new[] { QHS.quote(idaccmotive) }, 1);
                            //checkLastError("aggiornando le scritture");
                            //}
                            //else {
                            //    ShowMessage(
                            //        $"Conto non trovato per l'aggiornamento della scrittura EP della fattura, collegata al Contratto Attivo.",
                            //        "Errore");
                            //}
                            //Se nel CP è cambiato l'upb, lo aggiorna anche nella scritture
                            if  (idupb_inv.ToString() != idupb.ToString() || idupb_iva_inv.ToString() != idupb_iva.ToString()
                                || (newIdAcc != DBNull.Value && oldIdAcc.ToString() != newIdAcc.ToString() ) ) {
                            //    Conn.DO_UPDATE("entrydetail",
                            //        QHS.AppAnd(
                            //            QHS.CmpEq("yentry", rInvDet["yinv"]),
                            //            QHS.CmpEq("idrelated", EP_functions.GetIdForDocument(rInvDet)),
                            //            QHS.CmpEq("idupb", idupb_inv), QHS.CmpEq("idupb_iva", idupb_iva_inv)
                            //        ),
                            //        new[] { "idupb", "idupb_iva" },
                            //        new[] { QHS.quote(idupb), QHS.quote(idupb_iva) }, 2);
                            
                                string msg = "E' stato modificato l'UPB o la Casuale EP. Rigenerare le scritture EP della fattura collegata al Contratto Attivo.";
                                    var shower = MetaFactory.factory.getSingleton<IMessageShower>();
                                shower.Show(null, msg, "AVVISO IMPORTANTE", MessageBoxButtons.OK);

                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Assegna gli idepexp degli impegni di budget dopo aver generato gli impegni di budget
        /// </summary>
        void aggiornaIdEpExpAccantonamento() {

            DataRow curr = getCurrentRow();
            //var idrel = BudgetFunction.GetIdForDocument(curr);
            //object idepexp = getIdEpExpByIdRelated(idrel, 2);

            foreach (int key in _listaImpegni.Keys) {
                if (_listaImpegni[key].RowState == DataRowState.Detached) {
                    continue;
                }
                object idepexp = _listaImpegni[key]["idepexp"];
                if (idepexp == DBNull.Value) return;

                Conn.DO_UPDATE("provision", QHS.CmpKey(curr),
                    new[] {"idepexp"},
                    new[] {QHS.quote(idepexp)}, 1);
                checkLastError("aggiornando il fondo di accantonamento");

                doChange(curr, "idepexp", idepexp);
            }

        }


        /// <summary>
        /// Assegna gli idepexp degli impegni di budget dopo aver generato gli impegni di budget
        /// </summary>
        void aggiornaIdEpExpDettagliOrdine() {

            DataRow curr = getCurrentRow();
            foreach (int key in _listaImpegni.Keys) {
                if (_listaImpegni[key].RowState == DataRowState.Detached) {
                    continue;
                }

                object idepexp = _listaImpegni[key]["idepexp"];
                DataRow[] mandet = DS.Tables["mandatedetail"]
                    .Select(QHC.AppAnd(QHC.CmpKey(curr), QHC.CmpEq("rownum", key)));
                if (mandet.Length == 0 || mandet[0]["idepexp"].ToString() != idepexp.ToString()) {
                    Conn.DO_UPDATE("mandatedetail",
                        QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
                        new[] {"idepexp"},
                        new[] {QHS.quote(idepexp)}, 1);
                    checkLastError("aggiornando il c.passivo");
                }
                //effettua anche la modifica in memoria

                if (mandet.Length == 0) continue;
                DataRow md = mandet[0];
                if (md.RowState == DataRowState.Unchanged && md["idepexp"].ToString() == idepexp.ToString()) {
                    continue;
                }

                doChange(md, "idepexp", idepexp);

                //task 10014, successivamente 10416
                int annoDettaglio = CfgFn.GetNoNullInt32(md["yman"]);
                object oDataInizio = md["start"];
                if (oDataInizio != DBNull.Value) {
                    annoDettaglio = ((DateTime) oDataInizio).Year;
                }

                if (annoDettaglio >= minimoAnnoImpegniDiBudget) {
                    DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                        QHS.AppAnd(QHS.CmpEq("idmankind", md["idmankind"]), QHS.CmpEq("yman", md["yman"]),
                            QHS.CmpEq("nman", md["nman"]), QHS.CmpEq("manrownum", md["rownum"])), null, false);

                    foreach (DataRow rInvDet in invDetail.Rows) {
                        //aggiorna l'impegno di budget del dettaglio fattura
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idepexp"},
                            new[] {QHS.quote(idepexp)}, 1);
                        checkLastError("aggiornando le scritture");
                    }
                }
            }
        }

        /// <summary>
        /// Assegna gli idepacc dei dettagli del contratto passivo di budget dopo aver generato gli accertamenti di budget
        /// quando viene impostata sul dettaglio annullato na causale di annullo di ricavo
        /// </summary>
        void aggiornaIdEpAccDettagliOrdine() {

            DataRow curr = getCurrentRow();
            foreach (int key in _listaAccertamenti.Keys) {
                if (_listaAccertamenti[key].RowState == DataRowState.Detached) {
                    continue;
                }

                object idepacc = _listaAccertamenti[key]["idepacc"];
                DataRow[] mandet = DS.Tables["mandatedetail"]
                    .Select(QHC.AppAnd(QHC.CmpKey(curr), QHC.CmpEq("rownum", key)));
                if (mandet.Length == 0 || mandet[0]["idepacc"].ToString() != idepacc.ToString()) {
                    Conn.DO_UPDATE("mandatedetail",
                        QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
                        new[] {"idepacc"},
                        new[] {QHS.quote(idepacc)}, 1);
                    checkLastError("aggiornando il c.passivo");
                }
                //effettua anche la modifica in memoria

                if (mandet.Length == 0) continue;
                DataRow md = mandet[0];
                if (md.RowState == DataRowState.Unchanged && md["idepacc"].ToString() == idepacc.ToString()) {
                    continue;
                }

                doChange(md, "idepacc", idepacc);
            }
        }

        /// <summary>
        /// Assegna gli idepexp dei dettagli del contratto attivo dopo aver generato gli impegni di budget
        /// quando viene impostata sul dettaglio annullato na causale di annullo di costo
        /// </summary>
        //void aggiornaIdEpexpDettagliContrattoAttivo() {

        //	DataRow curr = getCurrentRow();
        //	foreach (int key in _listaImpegni.Keys) {
        //		if (_listaImpegni[key].RowState == DataRowState.Detached) {
        //			continue;
        //		}

        //		object idepexp = _listaImpegni[key]["idepexp"];
        //		DataRow[] estimdet = DS.Tables["estimatedetail"]
        //			.Select(QHC.AppAnd(QHC.CmpKey(curr), QHC.CmpEq("rownum", key)));
        //		if (estimdet.Length == 0 || estimdet[0]["idepexp"].ToString() != idepexp.ToString()) {
        //			Conn.DO_UPDATE("estimatedetail",
        //				QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
        //				new[] {"idepexp"},
        //				new[] {QHS.quote(idepexp)}, 1);
        //			checkLastError("aggiornando il c.attivo");
        //		}
        //		//effettua anche la modifica in memoria

        //		if (estimdet.Length == 0) continue;
        //		DataRow md = estimdet[0];
        //		if (md.RowState == DataRowState.Unchanged && md["idepexp"].ToString() == idepexp.ToString()) {
        //			continue;
        //		}

        //		doChange(md, "idepexp", idepexp);
        //	}
        //}

        /// <summary>
        /// Assegna gli idepexp degli impegni di budget dopo aver generato gli impegni di budget
        /// </summary>
        void aggiornaIdEpExpDettagliFatturaParcella() {

            DataRow curr = getCurrentRow();
            foreach (int key in _listaImpegni.Keys) {
                if (_listaImpegni[key].RowState == DataRowState.Detached) {
                    continue;
                }

                int annoParcella = CfgFn.GetNoNullInt32(curr["ycon"]);

                if (annoParcella >= minimoAnnoImpegniDiBudget) {
                    DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                        QHS.AppAnd(QHS.CmpEq("ycon", curr["ycon"]), QHS.CmpEq("ncon", curr["ncon"])), null, false);

                    foreach (DataRow rInvDet in invDetail.Rows) {
                        //aggiorna l'impegno di budget del dettaglio fattura
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idepexp"},
                            new[] {QHS.quote(_listaImpegni[key]["idepexp"])}, 1);
                        checkLastError("aggiornando la fattura");
                    }
                }
            }
        }


        public string GetFilterForDocument(string idrelated, out string tablename) {
            tablename = null;
            if (idrelated == null) return null;
            object[] obj1 = BudgetFunction.decodeID(idrelated);
            if (obj1 == null) return null;
            if (obj1[0] == null) return null;
            tablename = obj1[0].ToString();
            string myTable = tablename;
            if (tablename == "csa_import.debit") {
                tablename = "csa_import";
            }

            switch (myTable) {
                case "assetgrant":
                    return CreateFilter(QHS, obj1, "ygrant", "idasset", "idpiece");
                case "assetgrantdetail":
                    return CreateFilter(QHS, obj1, "ydetail", "idasset", "idpiece");
                case "invoicedetail":
                    return CreateFilter(QHS, obj1, "idinvkind", "yinv", "ninv", "rownum");
                case "estimatedetail":
                    return CreateFilter(QHS, obj1, "idestimkind", "yestim", "nestim", "rownum");
                case "mandatedetail":
                    return CreateFilter(QHS, obj1, "idmankind", "yman", "nman", "rownum");
            }

            return null;
        }

        static string CreateFilter(QueryHelper Q, object[] O, params string[] field) {
            string filter = "";
            for (int i = 0; i < field.Length; i++) {
                string fieldname = field[i];
                filter = Q.AppAnd(filter, Q.CmpEq(fieldname, O[i + 1]));
            }

            return filter;
        }

        void aggiornaIdEpAccDettagliRisconti() {
            DataRow curr = getCurrentRow();
            foreach (string idrel in _listaImpegniByIdRelated.Keys) {
                string table;
                string filter = GetFilterForDocument(idrel, out table);
                if (table != null) {
                    Conn.DO_UPDATE(table,
                        filter,
                        new[] {"idepacc"},
                        new[] {QHS.quote(_listaImpegniByIdRelated[idrel]["idepacc"])}, 1);
                    checkLastError("aggiornando i risconti");
                }

            }

        }

        void aggiornaIdEpAccDettagliContrattoAttivo() {

            DataRow curr = getCurrentRow();
            foreach (int key in _listaAccertamenti.Keys) {
                if (_listaAccertamenti[key].RowState == DataRowState.Detached) {
                    continue;
                }

                object idepacc = _listaAccertamenti[key]["idepacc"];
                DataRow[] estimdet = DS.Tables["estimatedetail"]
                    .Select(QHC.AppAnd(QHC.CmpKey(curr), QHC.CmpEq("rownum", key)));
                if (estimdet.Length == 0 || estimdet[0]["idepacc"].ToString() != idepacc.ToString()) {
                    Conn.DO_UPDATE("estimatedetail",
                        QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
                        new[] {"idepacc"},
                        new[] {QHS.quote(idepacc)}, 1);
                    checkLastError("aggiornando il contratto attivo");
                }

                //effettua anche la modifica in memoria
                if (estimdet.Length == 0) continue;
                DataRow ed = estimdet[0];
                if (ed.RowState == DataRowState.Unchanged && ed["idepacc"].ToString() == idepacc.ToString()) {
                    continue;
                }

                doChange(ed, "idepacc", idepacc);

                int annoDettaglio = CfgFn.GetNoNullInt32(curr["yestim"]);
                object oDataInizio = ed["start"];
                if (oDataInizio != DBNull.Value) {
                    annoDettaglio = ((DateTime) oDataInizio).Year;
                }

                //task 10014, successivamente 10416
                if (annoDettaglio >= minimoAnnoImpegniDiBudget) {
                    DataTable invDetail = Conn.RUN_SELECT("invoicedetail", "*", null,
                        QHS.AppAnd(QHS.CmpEq("idestimkind", ed["idestimkind"]), QHS.CmpEq("yestim", ed["yestim"]),
                            QHS.CmpEq("nestim", ed["nestim"]), QHS.CmpEq("estimrownum", ed["rownum"])), null, false);

                    foreach (DataRow rInvDet in invDetail.Rows) {
                        //aggiorna l'accertamento di budget del dettaglio fattura
                        Conn.DO_UPDATE("invoicedetail",
                            QHS.CmpKey(rInvDet),
                            new[] {"idepacc"},
                            new[] {QHS.quote(idepacc)}, 1);
                    }
                }
            }
        }



        /// <summary>
        /// Assegna gli idepexp degli impegni di budget dopo aver generato gli impegni di budget
        /// </summary>
        void invoicePostSave() {
            DataRow curr = getCurrentRow();
            foreach (int key in _listaAccertamenti.Keys) {
                if (_listaAccertamenti[key].RowState == DataRowState.Detached) {
                    continue;
                }

                if (_listaAccertamentiDiffProrata.ContainsKey(key)) continue;
                Conn.DO_UPDATE("invoicedetail",
                    QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
                    new[] {"idepacc"},
                    new[] {QHS.quote(_listaAccertamenti[key]["idepacc"])}, 1);
                checkLastError("aggiornando la fattura");

                //effettua anche la modifica in memoria
                DataRow[] invdet = DS.Tables["invoicedetail"].Select(QHC.CmpEq("rownum", key));
                if (invdet.Length == 0) continue;
                doChange(invdet[0], "idepacc", _listaAccertamenti[key]["idepacc"]);
            }

            foreach (int key in _listaImpegni.Keys) {
                if (_listaImpegni[key].RowState == DataRowState.Detached) {
                    continue;
                }

                if (_listaImpegniDiffProrata.ContainsKey(key)) continue;
                Conn.DO_UPDATE("invoicedetail",
                    QHS.AppAnd(QHS.CmpKey(curr), QHS.CmpEq("rownum", key)),
                    new[] {"idepexp"},
                    new[] {QHS.quote(_listaImpegni[key]["idepexp"])}, 1);
                checkLastError("aggiornando la fattura");

                //effettua anche la modifica in memoria
                DataRow[] invdet = DS.Tables["invoicedetail"].Select(QHC.CmpEq("rownum", key));
                if (invdet.Length == 0) continue;
                doChange(invdet[0], "idepexp", _listaImpegni[key]["idepexp"]);
            }

        }




        private void editEpExp(int nphase) {
            DataRow curr = getCurrentRow();
            if (curr == null) return;


            BudgetFunction bf = new BudgetFunction(Disp)
                {metaNameForPosting = metaTableForPosting, autoIgnore = autoIgnore, silent = silentPosting};
            string idrelated = BudgetFunction.GetIdForDocument(curr);
            string table = cicloAttivo() ? "epacc" : "epexp";
            bool doppio = doppioMovimento(curr.Table.TableName) ||
                          (curr.Table.TableName == "csa_importriep") ||
                          (curr.Table.TableName == "csa_importver");
            bool someFound = bf.EditRelatedEpMovLike(table, meta, idrelated, nphase, doppio);

            if (doppio) {
                if (cicloAttivo()) {
                    bf.EditRelatedEpMovLike("epexp", meta, idrelated, nphase,
                        someFound); //se ha mostrato già qualcosa opera in modalità silent
                }
                else {
                    bf.EditRelatedEpMovLike("epacc", meta, idrelated, nphase,
                        someFound); //se ha mostrato già qualcosa opera in modalità silent
                }
            }
        }

        /// <summary>
        /// Prende l'idepexp della richiesta d'ordine ove presente
        /// </summary>
        /// <param name="mandate"></param>
        /// <param name="rManDetail"></param>
        /// <returns></returns>
        private object getParentIdEpExp(DataRow mandate, DataRow rManDetail) {
            if (rManDetail["idepexp_pre"] != DBNull.Value) return rManDetail["idepexp_pre"];
            foreach (var field in new[] {"idmankind_origin", "yman_origin", "nman_origin"}) {
                if (mandate[field] == DBNull.Value) return DBNull.Value;
            }

            if (rManDetail["rownum_origin"] == DBNull.Value) return DBNull.Value;

            return Conn.DO_READ_VALUE("mandatedetail", QHS.AppAnd(QHS.CmpEq("idmankind", mandate["idmankind_origin"]),
                           QHS.CmpEq("yman", mandate["yman_origin"]),
                           QHS.CmpEq("nman", mandate["nman_origin"]),
                           QHS.CmpEq("rownum", rManDetail["rownum_origin"])
                       ),
                       "idepexp") ?? DBNull.Value;
        }




        object getIdAccMotiveDebitCredit(object idaccmotive, object idaccmotiveCrg, object dateCrg) {
            if (idaccmotiveCrg == DBNull.Value) return idaccmotive;
            if (dateCrg == DBNull.Value) return idaccmotiveCrg;
            var d = (DateTime) dateCrg;
            return d.Year <= esercizio ? idaccmotiveCrg : idaccmotive;
        }

        /// <summary>
        /// 
        /// 
        /// </summary>
        /// <param name="details"></param>
        /// <returns></returns>
        //DateTime getADate(DataTable details) {
        //    foreach (DataRow r in details.Select()) {
        //        if (r["start"] != DBNull.Value) {
        //            DateTime start = (DateTime) r["start"];
        //            if (start.Year == esercizio) return start;
        //        }

        //        if (r["stop"] != DBNull.Value) {
        //            DateTime stop = (DateTime) r["stop"];
        //            if (stop.Year == esercizio) return stop;
        //        }

        //    }

        //    return (DateTime) meta.GetSys("datacontabile");
        //}

        //La scrittura sui ratei va fatta comunque prima di capire se i costi hanno superato  i ricavi, ossia bisogna portare i ratei attivi a costo
        // Infatti questa scrittura è fatta nell'anno della chiusura, mentre l'utile/perdita sarà valutato l'anno successivo
        DataTable ottieniRateiApertiProgettiInChiusura(object idupb) {
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);

            string query =
                "select  -sum(ed.amount) as accruals ,year(U.stop) as yearstop, year(U.start) as yearstart,ed.idupb, ed.idacc as idacc_accruals,  " +
                "EU.idacc_deferredcost, 	EU.idaccmotive_deferredcost, EU.idacc_revenue,EU.idaccmotive_revenue,U.idepupbkind,U.title,U.codeupb ," +
                "EU.idacc_cost,EU.idaccmotive_cost,EU.idacc_accruals, EU.idaccmotive_accruals,ed.idepacc " + //ed.idepexp, commentato con task 11624
                " from entrydetail ed " +
                " join entry e (nolock) on e.yentry=ed.yentry and e.nentry=ed.nentry " +
                " join account A on ED.idacc=A.idacc " +
                " join UPB U on ED.idupb=U.idupb " +
                " join epupbkindyear EU on EU.idepupbkind = U.idepupbkind " +
                " WHERE " +
                " ED.yentry= " + strYear + //scritture di quest'anno
                " AND E.identrykind not in (8,11,12) " +
                " AND ED.idacc=EU.idacc_accruals " +
                " and EU.ayear =" + strYear + // prende la configurazione tipo UPB di quest'anno
                " AND " + QHS.CmpEq("ED.idupb", idupb) +
                " AND year(U.stop) = " + strYear + // UPB in scadenza quest'anno
                " AND EU.adjustmentkind='C'  " +
                " group by ed.idupb, ed.idacc, EU.idacc_cost,EU.idaccmotive_cost," +
                " EU.idacc_deferredcost, EU.idaccmotive_deferredcost, EU.idacc_revenue,EU.idaccmotive_revenue,ed.idepacc," +
                " EU.idacc_accruals, EU.idacc_deferredcost,EU.idaccmotive_accruals,year(U.stop),year(U.start),U.idepupbkind,U.title,U.codeupb   " +
                " having " +
                " -sum(ed.amount) <> 0"; // RATEO DIVERSO DA ZERO; // ed.idepacc,ed.idepexp,
            ; // ed.idepacc,ed.idepexp,
            DataTable t = Conn.SQLRunner(query, false, 600);
            return t;
        }


        private DataTable ottieniProgettiInChiusuraNoRateiAperti(object idupb) {
            int currAyear = esercizio;
            string strYear = QHS.quote(currAyear);
            string query =
                "select U.idupb,   U.codeupb, " +
                "-sum(case when A.flagaccountusage & (64+131072) <> 0 then ED.amount else 0 end) as cost," +
                "sum(case when A.flagaccountusage & 128 <> 0 then ED.amount else 0 end) as revenue," +
                "sum(case when A.flagaccountusage & 2048 <> 0 then ED.amount else 0 end) as reserve," +
                "-sum(case when A.idacc = EU.idacc_accruals then ED.amount else 0 end) as accruals," +
                "EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals," +
                "EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
                "year(U.stop) as yearstop, year(U.start) as yearstart,   EU.adjustmentkind,U.idepupbkind,U.codeupb,U.title " +
                "from entrydetail ed (nolock) " +
                " join entry e (nolock) on e.yentry=ed.yentry and e.nentry=ed.nentry " +
                " join UPB UPB_associati (nolock)  on ed.idupb = UPB_associati.idupb " +
                " join UPB U (nolock)  on U.idupb=ISNULL(UPB_associati.idupb_capofila,UPB_associati.idupb) " +
                "join epupbkindyear EU (nolock)  on EU.idepupbkind = U.idepupbkind " +
                "join account A (nolock) on A.idacc = ed.idacc " +
                " where (A.flagaccountusage & 524288 = 0 ) and " + // Escludi da calcolo Commessa completata . Task 15404
                QHS.AppAnd(QHS.NullOrLe("year(U.start)", currAyear),
                    QHS.CmpEq("year(U.stop)", currAyear), QHS.CmpEq("EU.ayear", currAyear),
                    QHS.FieldNotIn("e.identrykind", new object[] {8, 11, 12}),
                    QHS.CmpEq("EU.adjustmentkind", "C"), QHS.CmpEq("ED.yentry", currAyear),
                    QHS.CmpEq("ED.idupb", idupb)) +
                " group by U.idupb,EU.idacc_cost, EU.idacc_revenue, 	EU.idacc_deferredcost,EU.idacc_accruals, " +
                " EU.idaccmotive_cost, EU.idaccmotive_revenue, 	EU.idaccmotive_deferredcost,EU.idaccmotive_accruals," +
                " EU.adjustmentkind,year(U.stop),year(U.start),U.idepupbkind,U.codeupb,U.title  " +
                " having " +
                " sum(case when A.flagaccountusage & (64+131072) <> 0 then ED.amount else 0 end)  < " + // COSTI < RICAVI
                " sum(case when A.flagaccountusage & 128 <> 0 then ED.amount else 0 end) and " +
                " -sum(case when A.idacc = EU.idacc_accruals then ED.amount else 0 end) = 0"; // RATEO PARI A ZERO


            DataTable t = Conn.SQLRunner(query, false, 600);
            return t;
        }

        Dictionary<string, DataRow> hAmmortamentiFuturi = new Dictionary<string, DataRow>();

        private void OttieniAmmmortamentiFuturiUPB() {
            DataTable tAmmortamentiFuturi = new DataTable();

            DataSet Out = Conn.CallSP("calcola_ammortamenti_futuri_cespiti",
                new Object[2] {
                    esercizio,
                    Conn.GetSys("datacontabile")
                }, false, 600
            );

            if (Out == null) return;
            if (Out.Tables.Count == 0) return;

            tAmmortamentiFuturi = Out.Tables[0];

            // Lancio sp calcolo ammortamenti futuri
            foreach (DataRow r in tAmmortamentiFuturi.Rows) {
                hAmmortamentiFuturi[r["idupb"].ToString()] = r;
            }

        }



        public bool generaScrittureCommessaCompletata(DataRow curr, BudgetFunction bf) {
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object doc = $"Assestamento commessa completata {esercizio} UPB {curr["codeupb"]}";

            DateTime dec31 = new DateTime(esercizio, 12, 31);
            DateTime jan01 = new DateTime(1 + esercizio, 1, 1);
            var mainidrel = BudgetFunction.GetIdForDocument(curr);
            DataRow mainEntry =
                EP.SetEntry(doc, dec31, DBNull.Value, DBNull.Value, EP_functions.GetIdForDocument(curr));
            //CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);
            mainEntry["identrykind"] = 8;


            bool risconta_ammortamenti_futuri = _rConfig["risconta_ammortamenti_futuri"].ToString().ToUpper() == "S";
            string campoRicavo = "idacc_revenue";
            string campoCosto = "idacc_cost";
            string campoRateoAttivo = "idacc_accruals";
            string campoRiscontoPassivo = "idacc_deferredcost";

            string campoCausaleRicavo = "idaccmotive_revenue";
            string campoCausaleCosto = "idaccmotive_cost";
            string campoCausaleRateoAttivo = "idaccmotive_accruals";
            string campoCausaleRiscontoPassivo = "idaccmotive_deferredcost";

            bool annoFine = (CfgFn.GetNoNullInt32(curr["yearstop"]) == esercizio);
            string idepcontext = "MAN"; //proviamo
            if (annoFine) {
                //var idrel = BudgetFunction.GetIdForDocument(curr);

                #region anno fine

                if (risconta_ammortamenti_futuri) {
                    OttieniAmmmortamentiFuturiUPB();
                    DataTable tEntryDetailSourceNoRatei = ottieniProgettiInChiusuraNoRateiAperti(curr["idupb"]);
                    foreach (DataRow rDettaglioUPB in tEntryDetailSourceNoRatei.Rows) {
                        decimal rateo = CfgFn.GetNoNullDecimal(rDettaglioUPB["accruals"]);
                        if (rateo != 0) continue;

                        // Se siamo nelle condizioni (Ricavi > Costi) e siamo im presenza di ammortamenti futuri cespiti

                        // Questo metodo vale solo per UPB in chiusura (in corso d''anno) a commessa completata ed effettua un calcolo opzionale.
                        // Se vi sono ammortamenti futuri genera risconti sulla base di questi ultimi.
                        // Questo vale SOLO per UPB i cui RICAVI sono superiori ai COSTI. 
                        // Se si decide di non effettuare questi risconti ,  gli UPB in questione 
                        // genereranno utile o perdita .

                        //genera scrittura RICAVI A RISCONTI PASSIVI
                        string idupb = curr["idupb"].ToString();
                        decimal costi = CfgFn.GetNoNullDecimal(rDettaglioUPB["cost"]);
                        decimal ricavi = CfgFn.GetNoNullDecimal(rDettaglioUPB["revenue"]);
                        if ((ricavi - costi) <= 0) continue;
                        DataRow RAmmortamentiFuturi = hAmmortamentiFuturi[idupb];
                        decimal importo_ammortamenti =
                            CfgFn.GetNoNullDecimal(RAmmortamentiFuturi["amm_futuricespiti"]); // importo positivo
                        if (importo_ammortamenti == 0) continue;
                        decimal importo_risconto = 0;
                        if ((ricavi - costi) <= importo_ammortamenti) importo_risconto = ricavi;
                        else importo_risconto = importo_ammortamenti;


                        if (importo_risconto == 0) continue;
                        DataTable tRicaviNonRipartiti = ottieniRicaviUPB(idupb, false, false, false); //amount / idacc / idreg
                        tRicaviNonRipartiti.TableName = "entrydetail";
                        ricaviAZero.Clear();
                        foreach (DataRow r in tRicaviNonRipartiti.Select()) {
                            var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                            if (amount == 0) {
                                string key = getHash(r, new[] { "idacc", "idreg", "idaccmotive" });
                                ricaviAZero.Add(key, r);
                                continue;
                            }

                        }

                        DataTable tRicavi = ottieniRicaviUPB(idupb, false, false,true); //amount / idacc / idreg
                        tRicavi.TableName = "entrydetail";
                        ripartisciSommaInBaseATabella(importo_risconto, tRicavi);
                        foreach (DataRow r in tRicavi.Select()) {
                            var idacc = r["idacc"];
                            var idaccmotive = r["idaccmotive"];
                            var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                            var idreg = r["idreg"];
                            if (amount == 0) continue;
                            string key = getHash(r, new[] { "idacc", "idreg", "idaccmotive" });
                            if (ricaviAZero.ContainsKey(key)) continue;
                            string idrel = BudgetFunction.ComposeObjects(new[]
                                {BudgetFunction.GetIdForDocument(curr), idreg, idacc});

                            if (idacc == DBNull.Value) {
                                ShowMessage($"Campo Ricavo non trovato per upb  {curr["codeupb"]} {curr["title"]} ",
                                    "Errore");
                                return false;
                            }

                            if (curr[campoRiscontoPassivo] == DBNull.Value) {
                                ShowMessage(
                                    $"Campo Risconto Passivo non trovato per upb {curr["codeupb"]} {curr["title"]} ",
                                    "Errore");
                                return false;
                            }

                            //genera scrittura RICAVI A RISCONTI PASSIVI
                            EP.EffettuaScritturaImpegnoBudget(idepcontext, amount,
                                idacc, idreg,
                                curr["idupb"],
                                DBNull.Value, DBNull.Value,
                                r, idaccmotive, null, getIdEpAccByIdRelated(idrel, 2), idrel,
                                "Risconto su ammortamenti futuri cespiti");

                            EP.EffettuaScritturaImpegnoBudget(idepcontext, -amount,
                                curr[campoRiscontoPassivo], DBNull.Value,
                                curr["idupb"],
                                DBNull.Value, DBNull.Value,
                                null, curr[campoCausaleRiscontoPassivo], null, getIdEpAccByIdRelated(idrel, 2), idrel,
                                "Risconto su ammortamenti futuri cespiti");

                        }
                    }

                }

                // RATEI APERTI
                DataTable tEntryDetailSourceRatei = ottieniRateiApertiProgettiInChiusura(curr["idupb"]);

                foreach (DataRow rRateo in tEntryDetailSourceRatei.Rows) {
                    decimal rateo = CfgFn.GetNoNullDecimal(rRateo["accruals"]);
                    if (rateo == 0) continue;
                    if (rateo != 0) {
                        if (curr[campoCosto] == DBNull.Value) {
                            ShowMessage($"Conto di costo non trovato per UPB {curr["codeupb"]} {curr["title"]} ",
                                "Errore");
                            return false;
                        }

                        if (curr[campoRateoAttivo] == DBNull.Value) {
                            ShowMessage($"Conto di Rateo Attivo non trovato per UPB {curr["codeupb"]} {curr["title"]} ",
                                "Errore");
                            return false;
                        }

                        //genera scrittura COSTO A RATEO ATTIVO  

                        EP.EffettuaScritturaImpegnoBudget(idepcontext, rateo,
                            curr[campoCosto], DBNull.Value,
                            curr["idupb"],
                            DBNull.Value, DBNull.Value,
                            null, curr[campoCausaleCosto], getIdEpExpByIdRelated(mainidrel, 2), null, mainidrel);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext, -rateo,
                            curr[campoRateoAttivo], DBNull.Value,
                            curr["idupb"],
                            DBNull.Value, DBNull.Value,
                            null, curr[campoCausaleRateoAttivo], null, null, /*rRateo["idepacc"]*/ mainidrel);
                    }
                }

                #endregion

            }
            else {

                #region altri anni

                decimal costi = CfgFn.GetNoNullDecimal(curr["cost"]);
                decimal ricavi = CfgFn.GetNoNullDecimal(curr["revenue"]);
                decimal riserve = CfgFn.GetNoNullDecimal(curr["reserve"]);
                //deve considerare anche le riserve
                //poi confrontare costi con ricavi+riserve 
                // la scrittura eventuale deve essere fatta sulla parte (ricavi+riserve)- costi ove positivo

                // Se costi sono compresi tra ricavi e ricavi+ riserve : non faccio nulla
                if (costi >= ricavi && costi <= ricavi + riserve) return false;

                if (costi > ricavi + riserve) {
                    //costi > ricavi+riserve
                    //      e in questo caso utilizzo il conto di default per i ricavi del tipo upb (come da task..)
                    // task 7515 Se costi superano ricavi +riserve, devono essere  create delle scritture:
                    //      RATEO ATTIVO a RICAVO
                    //  per la parte di costo che supera ricavi +riserve
                    //  Il conto di ricavo sarà un conto predefinito per quel progetto, 
                    //                  idem il rateo ma il rateo attivo ove assente prendere il rateo di config
                    decimal importo_rateo = costi - (ricavi + riserve);

                    //DataTable tCosti = ottieniCostiUPB(curr["idupb"]); //amount / idacc / idreg
                    //ripartisciSommaInBaseATabella(importo_rateo, tCosti);

                    //foreach (DataRow r in tCosti.Select()) {
                    var idacc = curr[campoRateoAttivo]; // r["idacc"];
                    //var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                    //var idreg = r["idreg"];
                    //string idrel = BudgetFunction.ComposeObjects(new[] { BudgetFunction.GetIdForDocument(curr), idreg });

                    //if (curr[campoCausaleRicavo] == DBNull.Value) {
                    //    ShowMessage(null, $"Causale Ricavo non trovata per UPB {curr["codeupb"]} {curr["title"]} ",
                    //        "Errore");
                    //    return false;
                    //}
                    if (curr[campoRicavo] == DBNull.Value) {
                        ShowMessage($"Campo Ricavo non trovato per upb  {curr["codeupb"]} {curr["title"]}",
                            "Errore");
                        return false;
                    }

                    //if (curr[campoCausaleRateoAttivo] == DBNull.Value) {
                    //    ShowMessage(null, $"Causale RateoAttivo non trovata per UPB {curr["codeupb"]} {curr["title"]} ",
                    //        "Errore");
                    //    return false;
                    //}
                    if (curr[campoRateoAttivo] == DBNull.Value) {
                        ShowMessage($"Campo Rateo Attivo non trovato per upb  {curr["codeupb"]} {curr["title"]} ",
                            "Errore");
                        return false;
                    }

                    //genera scrittura RATEO ATTIVO A RICAVI
                    EP.EffettuaScritturaImpegnoBudget(idepcontext, -importo_rateo,
                        curr[campoRicavo], DBNull.Value,
                        curr["idupb"],
                        DBNull.Value, DBNull.Value,
                        null, curr[campoCausaleRicavo], null, getIdEpAccByIdRelated(mainidrel, 2), mainidrel);

                    EP.EffettuaScritturaImpegnoBudget(idepcontext, importo_rateo,
                        curr[campoRateoAttivo], DBNull.Value,
                        curr["idupb"],
                        DBNull.Value, DBNull.Value,
                        null, curr[campoCausaleRateoAttivo], null, getIdEpAccByIdRelated(mainidrel, 2), mainidrel);

                    //}
                }
                else {
                    //se i costi sono inferiori ai ricavi
                    decimal importo_risconto = ricavi - costi;
                    //genera scrittura RICAVI A RISCONTI PASSIVI
                    // in questo caso vanno utilizzati i conti di ricavo, in proporzione
                    //  invece come conto di risconto passivo, quello dell'upb
                    // task 7515 Se i ricavi superano i costi, devono essere create delle scritture 
                    //  RICAVO a RISCONTO PASSIVO
                    //  Il conto di RISCONTO PASSIVO va preso dal tipo UPB o, ove non configurato, da CONFIG
                    //  ripartiti proporzionalmente in base ai ricavi dell'anno
                    //  Ossia detto RIS = somma ricavi dell'anno - somma costi dell'anno, ed Rt la somma dei ricavi dell'anno,
                    //    i vari importi da riscontare ripartiti per ricavo saranno pari a RIS *(ricavo / Rt)


                    DataTable tRicaviNonRipartiti = ottieniRicaviUPB(curr["idupb"], false, false, false); //amount / idacc / idreg
                    tRicaviNonRipartiti.TableName = "entrydetail";
                    ricaviAZero.Clear();
                    foreach (DataRow r in tRicaviNonRipartiti.Select()) {
                        var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                        if (amount == 0) {
                            string key = getHash(r, new[] { "idacc", "idreg", "idaccmotive" });
                            ricaviAZero.Add(key, r);
                            continue;
                        }

                    }


                    DataTable tRicavi = ottieniRicaviUPB(curr["idupb"], false, false,true); //amount / idacc / idreg
                    tRicavi.TableName = "entrydetail";
                    ripartisciSommaInBaseATabella(importo_risconto, tRicavi);
                    
                    foreach (DataRow r in tRicavi.Select()) {
                        var idacc = r["idacc"];
                        var idaccmotive = r["idaccmotive"];
                        var amount = CfgFn.GetNoNullDecimal(r["amount"]);
                        var idreg = r["idreg"];
                        if (amount == 0) continue;
                        // costruisco chiave su conto, anagrafica, causale per riconoscere le terne su cui l'importo 
                        // è zero e non si deve creare il dettaglio
                        string key = getHash(r, new[] { "idacc", "idreg", "idaccmotive" });
                        if (ricaviAZero.ContainsKey(key)) continue;
                        string idrel = BudgetFunction.ComposeObjects(new[]
                            {BudgetFunction.GetIdForDocument(curr), idreg, idacc});

                        if (idacc == DBNull.Value) {
                            ShowMessage($"Campo Ricavo non trovato per upb  {curr["codeupb"]} {curr["title"]} ",
                                "Errore");
                            return false;
                        }

                        if (curr[campoRiscontoPassivo] == DBNull.Value) {
                            ShowMessage(
                                $"Campo Risconto Passivo non trovato per upb {curr["codeupb"]} {curr["title"]} ",
                                "Errore");
                            return false;
                        }

                        //genera scrittura RICAVI A RISCONTI PASSIVI
                        EP.EffettuaScritturaImpegnoBudget(idepcontext, amount,
                            idacc, idreg,
                            curr["idupb"],
                            DBNull.Value, DBNull.Value,
                            r, idaccmotive, null, getIdEpAccByIdRelated(idrel, 2), idrel);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext, -amount,
                            curr[campoRiscontoPassivo], idreg, //DBNull.Value,
                            curr["idupb"],
                            DBNull.Value, DBNull.Value,
                            null, curr[campoCausaleRiscontoPassivo], null, getIdEpAccByIdRelated(idrel, 2), idrel);

                    }
                }

                #endregion

            }

            EP.RemoveEmptyDetails();

            return true;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="curr"></param>
        /// <param name="bf"></param>
        /// <returns></returns>
        private bool generaScrittureContrattoPassivo(DataRow curr, BudgetFunction bf) {


            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            DataTable manDet;
            if (DS.Tables.Contains("mandatedetail")) {
                manDet = DS.Tables["mandatedetail"];
            }
            else {
                manDet = Conn.RUN_SELECT("mandatedetail", "*", null, QHS.CmpKey(curr), null, false);
            }

            int ndetails = manDet.Rows.Count;
            bool epexists = EP.MainEntryExists();
            if ((epexists == false) && (ndetails == 0)) return false; //No details- no use for EP

            object doc;
            if (curr["doc"] != DBNull.Value) {
                doc = curr["doc"];
            }
            else {
                doc = "C.P. " + curr["idmankind"] + ' ' + curr["yman"].ToString().Substring(2, 2) + "/" + curr["nman"];
            }

            DateTime mainDate;

            int yman = CfgFn.GetNoNullInt32(curr["yman"]);

            mainDate = (DateTime) curr["adate"];

            DataRow mainEntry = EP.SetEntry(curr["description"], mainDate, doc, curr["docdate"],
                EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);


            string idepcontext = "MAN";

            object idaccRegistry = DBNull.Value;
            if (curr["idreg"] != DBNull.Value) {
                idaccRegistry = EP.GetSupplierAccountForRegistry(curr["idaccmotivedebit"], curr["idreg"]);
            }

            if (curr["idreg"] != DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                ShowMessage("Non è stato configurato il conto di debito opportuno nel contratto " + doc, "Errore");
                return false;
            }

            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);
            string filterdetails;
            string filterMainCurrent = QHC.CmpKey(curr);
            DateTime primoGennaio = new DateTime(esercizio, 1, 1);
            DateTime trentunoDic = new DateTime(esercizio, 12, 31);

            string nomeDebito = nomeCPassivo(curr);
            //Cicla sui dettagli  (annullati e non) ai fini della scrittura di apertura, COSTO A DEBITO
            foreach (DataRow rmandet in manDet.Select(filterMainCurrent)) {
                if (!isManKindEpEnabled(rmandet["idmankind"])) continue;

                bool considera = movimentoCreazioneDettaglioContrattoDaGenerare_2(rmandet, curr) ||
                                 variazioneAnnulloOAResiduoDaGenerare_5(rmandet, curr) ||
                                 movimentoDiTipoVariazione_1(rmandet, curr);
                if (!considera) continue;

                DateTime currDate = mainDate;

                string rifDetail = "Contratto Passivo " + curr["idmankind"] + ' ' +
                                   curr["yman"].ToString().Substring(2, 2) + "/" + curr["nman"] + " dett. " +
                                   rmandet["rownum"].ToString() + "- ";

                DataRow nextRow = getNextRow(rmandet);
                DataRow firstRow = getFirstRow(rmandet);
                DataRow prevRow = getPrevRow(rmandet);
                DataRow lastRow = getLastRow(rmandet);

                DateTime originalDate = (DateTime) (firstRow["start"] == DBNull.Value ? mainDate : firstRow["start"]);
                int yearStartImpegno = originalDate.Year;

                var idrelatedCreazione =
                    EP_functions
                        .GetIdForDocument(lastRow); //la creazione è fatta sull'ultimo dettaglio ma con i dati del primo
                var idrelatedCorrente = EP_functions.GetIdForDocument(rmandet);

                if (rmandet["start"] != DBNull.Value) {
                    currDate = (DateTime) rmandet["start"];
                }

                object idregToUse = curr["idreg"];
                if (rmandet["idreg"] != DBNull.Value) idregToUse = rmandet["idreg"];

                object idAccMotiveDebit = getIdAccMotiveDebitCredit(curr["idaccmotivedebit"],
                    curr["idaccmotivedebit_crg"], curr["idaccmotivedebit_datacrg"]);

                idaccRegistry = EP.GetSupplierAccountForRegistry(idAccMotiveDebit, idregToUse);

                if (curr["idreg"] == DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                    ShowMessage("Non è stato configurato il conto di debito opportuno nel contratto " + doc +
                                " dettaglio " + rmandet["detaildescription"], "Errore");
                    return false;
                }

                if (rmandet["idupb"] == DBNull.Value) {
                    ShowMessage(
                        $"Attenzione, il dettaglio {rmandet["detaildescription"]} non ha l'indicazione dell'UPB",
                        "Errore");
                    return false;
                }

                object idaccmotiveOriginal = firstRow["idaccmotive"]; //la causale è quella del dettaglio originale
                if (idaccmotiveOriginal == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {firstRow["detaildescription"]} non ha la causale!",
                        "Errore");
                    continue;
                }


                //object idepexpDebito = lastRow["idepexp"]; //era restimdet, ma come accertamento prendiamo sempre l'ultimo della catena, retrocompatibilmente
                //object idepexpCosto = lastRow["idepexp"]; //era restimdet, ma come accertamento prendiamo sempre l'ultimo della catena



                //object idepacc = lastRow["idepacc"]; //come accertamento credo sempre l'ultimo, prima prendeva il corrente

                object idepexpCosto = DBNull.Value;
                if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepexpCosto = _listaImpegni[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepexp"];
                }

                if (idepexpCosto == DBNull.Value) idepexpCosto = lastRow["idepexp"];

                object idepexpDebito = DBNull.Value;
                if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepexpDebito = _listaImpegni[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepexp"];
                }

                if (idepexpDebito == DBNull.Value) idepexpDebito = lastRow["idepexp"];


                //if (idepexp == DBNull.Value && esercizio > 2015 && UsaImpegniDiBudget) {
                //    ShowMessage("Non è stato generato l'impegno di budget per il dettaglio " +
                //                    rmandet["detaildescription"]);
                //    return false;
                //}
                //Sul dettaglio annullato nello stesso anno non genera scritture  se gli impegni sono abilitati, in caso di sostituzione  (*)
                if (impegniAbilitati(curr) && idepexpCosto == DBNull.Value && lastRow["stop"] != DBNull.Value) {
                    if (((DateTime) lastRow["stop"]).Year == esercizio && yearStartImpegno == esercizio)
                        continue; //currDate.Year
                }

                bool generaCostoADebito = false;

                if (nextRow == null && yearStartImpegno == esercizio)
                    generaCostoADebito = true; //normale scrittura di apertura credito

                //Per dettagli dell'anno non annullati va bene se rigenera una scrittura

                //double rImponibile = CfgFn.GetNoNullDouble(rmandet["taxable"]);

                ////double iva = CfgFn.GetNoNullDouble(Restimdet["tax"]);//
                //double quantitaConfezioni = CfgFn.GetNoNullDouble(rmandet["npackage"]);
                //double imponibile = CfgFn.RoundValuta(rImponibile * quantitaConfezioni * tassocambio);
                //decimal sconto = CfgFn.GetNoNullDecimal(CfgFn.RoundValuta(
                //	rImponibile * quantitaConfezioni * tassocambio *
                //	CfgFn.GetNoNullDouble(rmandet["discount"])));
                //decimal importoCosto = CfgFn.GetNoNullDecimal(imponibile);

                //importoCosto -= sconto;
                //sconto = 0;
                var importocostoCorrente = getTotaleImponibile(curr, rmandet);

                var rowToConsider =
                    firstRow; //considera non la riga corrente ma l'ultima riga del primo anno per l'importo scrittura, tutto questo solo sull'ultima riga
                while (getNextRow(rowToConsider) != null) {
                    var nextR = getNextRow(rowToConsider);
                    var startR = (DateTime) nextR["start"];
                    if (startR.Year != esercizio) break;
                    rowToConsider = nextR;
                }

                decimal importoCostoOriginale = getTotaleImponibile(curr, rowToConsider);

                DataRow[] rEntries1 = EP.GetAccMotiveDetails(idaccmotiveOriginal);


                //Nuovo campo che ove presente rappresenta l'importo del NUOVO dettaglio ossia quello che rimane in vita
                //if (rmandet["startamount"] != DBNull.Value) {
                //	importocosto = CfgFn.GetNoNullDecimal(rmandet["startamount"]);
                //}


                if (rEntries1.Length != 1) {
                    ShowMessage(
                        $"La causale di costo del dettaglio {rmandet["detaildescription"]} non è ben configurata.",
                        "Errore");
                    return false;
                }

                DataRow re = rEntries1[0];
                if (importocostoCorrente == 0) continue;


                if (generaCostoADebito) {
                    DataRow subMain = EP.setCurrDate(originalDate);
                    CopySecurity(curr, subMain);
                    EP.clearSubDetails(subMain);

                    //Effettua la scrittura costo a debito
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        importoCostoOriginale,
                        re["idacc"], idregToUse, rmandet["idupb"], rmandet["competencystart"], //COSTO
                        rmandet["competencystop"],
                        rmandet, idaccmotiveOriginal, rmandet["idcostpartition"], idepexpCosto, DBNull.Value,
                        idrelatedCreazione,
                        rifDetail + rmandet["detaildescription"]);

                    EP.EffettuaScritturaImpegnoBudget(idepcontext,
                        importoCostoOriginale, //importocosto + valore_iva - sconto,
                        idaccRegistry, idregToUse, rmandet["idupb"], rmandet["competencystart"], //DEBITO
                        rmandet["competencystop"],
                        //rmandet, idaccmotiveMainDebit, idepexp, DBNull.Value, idrelated, rmandet["detaildescription"]);
                        rmandet, idaccmotiveOriginal, idepexpDebito, DBNull.Value, idrelatedCreazione,
                        nomeDebito + " dett. " + rmandet["rownum"].ToString());
                }


                if (rmandet["stop"] != DBNull.Value && yearStartImpegno == esercizio) { //currDate.year
                    ////Nuovo campo per importo annullo
                    //if (rmandet["annulmentamount"] != DBNull.Value) {
                    //	importocosto = CfgFn.GetNoNullDecimal(rmandet["annulmentamount"]);
                    //}
                    if (nextRow != null) {
                        //per l'annullamento facciamo la scrittura con importo differenza, però sull'impegno di budget dell'altro dettaglio
                        importocostoCorrente -= getTotaleImponibile(curr, nextRow);
                    }

                    //SE annullato nello stesso anno effettua la scrittura inversa (DEBITO A COSTO), in data dell'annullamento, ecco perchè sopra aveva saltato il dettaglio (*)
                    //&& rmandet["idaccmotiveannulment"] == DBNull.Value
                    DateTime stop = (DateTime) rmandet["stop"];
                    if (stop.Year == esercizio) {
                        DataRow subMain2 = EP.setCurrDate(stop);
                        CopySecurity(curr, subMain2);
                        EP.clearSubDetails(subMain2);


                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            -importocostoCorrente,
                            re["idacc"], idregToUse, rmandet["idupb"], rmandet["competencystart"], //COSTO
                            rmandet["competencystop"],
                            rmandet, idaccmotiveOriginal, rmandet["idcostpartition"], idepexpCosto, DBNull.Value,
                            idrelatedCreazione,
                            rifDetail + rmandet["detaildescription"]);

                        EP.EffettuaScritturaImpegnoBudget(idepcontext,
                            -importocostoCorrente, //importocosto + valore_iva - sconto,
                            idaccRegistry, idregToUse, rmandet["idupb"], rmandet["competencystart"], //DEBITO
                            rmandet["competencystop"],
                            //rmandet, idaccmotiveMainDebit, idepexp, DBNull.Value, idrelated, rmandet["detaildescription"]);
                            rmandet, idaccmotiveOriginal, idepexpDebito, DBNull.Value, idrelatedCreazione,
                            nomeDebito + " dett. " + rmandet["rownum"].ToString());
                    }

                }

                if (EP.saldo != 0) {
                    ShowMessage("Si è verificata una squadratura sul dettaglio " +
                                rmandet["detaildescription"]);
                }




            }

            //Esamina ora tutti gli annullamenti
            //idepcontext = "ESTIM";
            //idacc_registry = EP.GetAccountForCustomer();

            //if (idacc_registry == null || idacc_registry == DBNull.Value) {
            //    ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
            //    return;
            //}

            filterdetails = QHC.AppAnd(filterMainCurrent, QHC.CmpGe("stop", primoGennaio),
                QHC.CmpLe("stop", trentunoDic));
            string idepcontextAnnull = "FATACQVAR";
            //Considera gli annulli, ma solo quelli in anni successivi. Per quelli nello stesso anno l'ha già fatta nel ciclo precedente.
            foreach (var rAnnul in manDet.Select(filterdetails)) {
                DataRow nextRow = getNextRow(rAnnul);
                DataRow firstRow = getFirstRow(rAnnul);
                DataRow prevRow = getPrevRow(rAnnul);
                DataRow lastRow = getLastRow(rAnnul);


                DateTime currDate = (DateTime) rAnnul["stop"];
                DataRow subMain = EP.setCurrDate(currDate);
                CopySecurity(curr, subMain);
                EP.clearSubDetails(subMain);

                bool generaScrittura = isManKindEpEnabled(rAnnul["idmankind"]); //per i non collegabili, sempre
                if (fatturaARicevereOEmettere(rAnnul)) generaScrittura = true;
                if (nextRow == null && rateo(rAnnul)) generaScrittura = true; //annullo semplice
                bool variazionePerRateo = movimentoDiTipoVariazionePerRateo(rAnnul, curr);
                if (variazionePerRateo) generaScrittura = true;
                if (!generaScrittura) continue;


                DateTime originalDate = (DateTime) (firstRow["start"] == DBNull.Value ? mainDate : firstRow["start"]);
                int yearStartImpegno = originalDate.Year;
                if (yearStartImpegno == esercizio) {
                    continue; //nessuna scrittura per dettagli nati quest'anno, l'ha già fatta sopra
                }



                var idAccMotiveDebit = getIdAccMotiveDebitCredit(curr["idaccmotivedebit"], curr["idaccmotivedebit_crg"],
                    curr["idaccmotivedebit_datacrg"]);

                object idepexpCosto = DBNull.Value; //rAnnul["idepexp"]
                if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(rAnnul["rownum"]))) {
                    idepexpCosto = _listaImpegni[CfgFn.GetNoNullInt32(rAnnul["rownum"])]["idepexp"];
                }

                if (idepexpCosto == DBNull.Value) {
                    idepexpCosto = rAnnul["idepexp"];
                }


                object idepexpDebito = DBNull.Value; //rAnnul["idepexp"]
                if (_listaImpegni.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepexpDebito = _listaImpegni[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepexp"];
                }

                if (idepexpDebito == DBNull.Value) {
                    idepexpDebito = lastRow["idepexp"];
                }



                object idepacc = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(rAnnul["rownum"]))) {
                    idepacc = _listaAccertamenti[CfgFn.GetNoNullInt32(rAnnul["rownum"])]["idepacc"];
                }

                if (idepexpCosto == DBNull.Value) {
                    idepacc = rAnnul["idepacc"];
                }


                //if (impegniAbilitati(curr) && idepexp == DBNull.Value && idepacc == DBNull.Value &&
                //    rAnnul["stop"] != DBNull.Value) {
                //	if (((DateTime) rAnnul["stop"]).Year == esercizio && currDate.Year == esercizio) continue;
                //}

                var idrelatedCurr = EP_functions.GetIdForDocument(rAnnul);
                var idrelatedLast = EP_functions.GetIdForDocument(lastRow);

                var idregToUse = curr["idreg"];
                if (curr["idreg"] == DBNull.Value) {
                    idregToUse = rAnnul["idreg"];
                }

                idaccRegistry = EP.GetSupplierAccountForRegistry(idAccMotiveDebit, idregToUse);

                if (rateoOFatturaARicevere(rAnnul)) {
                    idaccRegistry = rateo(rAnnul) ? _idrateo_passivo : _idaccInvoicetoreceive;
                }

                if (curr["idreg"] == DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                    ShowMessage("Non è stato configurato il conto di debito/credito opportuno", "Errore");
                    return false;
                }

                string rifDetail = "C.P. " + curr["idmankind"] + ' ' + curr["yman"].ToString().Substring(2, 2) + "/" +
                                   curr["nman"] + rAnnul["rownum"].ToString() + "- ";

                decimal importoAnnullo = getTotaleImponibile(curr, rAnnul);
                decimal importoDebito = importoAnnullo;

                if (nextRow != null) {
                    importoAnnullo -= getTotaleImponibile(curr, nextRow);
                    importoDebito = rateoOFatturaARicevere(rAnnul) ? -importoAnnullo : importoAnnullo;
                }

                ////task 15604 al tel. con Cinzia, mi dice che questo importo è pari al totale dettaglio
                if (fatturaARicevereOEmettere(rAnnul) && nextRow == null && importoAnnullo != 0) {
                    //	decimal importoRateo = CfgFn.GetNoNullDecimal(
                    //		Conn.readValue("entrydetail", getFilterDetailForRateo(lastRow, "idepexp", idepexpCosto)  //q.eq("idepexp", idepexpCosto) & 
                    //									  & q.eq("idacc", _idaccInvoicetoreceive),
                    //			"sum(amount)"));
                    //	if (importoRateo == 0) {
                    //		ShowMessage(
                    //			$"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come fattura da ricevere",
                    //		"Errore");
                    //		return false;
                    //	}
                    //	importoAnnullo = -importoRateo;
                    importoDebito = -importoAnnullo;
                }

                if (rateo(rAnnul) && nextRow == null && importoAnnullo != 0) {
                    decimal importoRateo = -CfgFn.GetNoNullDecimal(
                        Conn.readValue("entrydetail",
                            q.gt("amount", 0) & getFilterDetailForRateo(lastRow, "idepexp",
                                                  idepexpDebito) //q.eq("idepexp", idepexpDebito) 
                                              & q.eq("idacc", _idrateo_passivo),
                            "sum(amount)"));
                    if (importoRateo == 0) {
                        ShowMessage(
                            $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come rateo",
                            "Errore");
                        return false;
                    }

                    importoAnnullo = -importoRateo;
                    importoDebito = -importoAnnullo;
                }

                if (variazionePerRateo) {
                    decimal importoRateo = -CfgFn.GetNoNullDecimal(
                        Conn.readValue("entrydetail",
                            q.gt("amount", 0) & getFilterDetailForRateo(lastRow, "idepexp",
                                                  idepexpDebito) //q.eq("idepexp", idepexpDebito) 
                                              & q.eq("idacc", _idrateo_passivo),
                            "sum(amount)"));
                    if (importoRateo == 0) {
                        ShowMessage(
                            $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come rateo",
                            "Errore");
                        return false;
                    }

                    importoAnnullo = -importoRateo;
                    importoDebito = -importoAnnullo;
                }

                //if (rAnnul["annulmentamount"] != DBNull.Value) {
                //	importoAnnullo = CfgFn.GetNoNullDecimal(rAnnul["annulmentamount"]);
                //}

                //decimal quotaPagata = quotaPagataDettaglioContrattoPassivo(rAnnul);

                var idaccmotiveAnnul = rAnnul["idaccmotiveannulment"];
                if (idaccmotiveAnnul == DBNull.Value) {
                    if (yman < esercizio) {
                        ShowMessage(
                            $"Attenzione, il dettaglio n° {rAnnul["rownum"]}  {rAnnul["detaildescription"]} non ha la causale di annullo!",
                            "Errore");
                        return false;
                    }

                    continue; //ha già operato nel ciclo principale    

                }


                DataRow[] rEntriesAnnull = EP.GetAccMotiveDetails(idaccmotiveAnnul);
                if (rEntriesAnnull.Length != 1) {
                    ShowMessage(
                        $"La causale di annullo del dettaglio il dettaglio n° {rAnnul["rownum"]}  {rAnnul["detaildescription"]} non è ben configurata.",
                        "Errore");
                    return false;
                }

                object idContoAnnullo = rEntriesAnnull[0]["idacc"];

                decimal importoannullo = CfgFn.GetNoNullDecimal(importoAnnullo);
                //Effettua scrittura DEBITO  A COSTO/RICAVO
                if (EP.isCosto(idContoAnnullo)) {
                    //Rimosso messaggio e ripristinato comportamento precedente a seguito di task 15300
                    //ShowMessage( $"La causale di annullo del dettaglio {rAnnul["detaildescription"]} non non può essere di costo.","Errore");

                    //Se conto di costo non deve invertire, ci pensa già il contesto a rendere l'importo opposto
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextAnnull,
                        importoannullo,
                        idContoAnnullo,
                        idregToUse, rAnnul["idupb"],
                        rAnnul["competencystart"], rAnnul["competencystop"],
                        rAnnul, idaccmotiveAnnul, rAnnul["idcostpartition"], idepexpCosto, DBNull.Value, idrelatedCurr,
                        rifDetail + rAnnul["detaildescription"]);
                }
                else {
                    var idepaccRicavo = getIdEpAccByIdRelated(idrelatedCurr, 2);
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextAnnull,
                        importoAnnullo,
                        idContoAnnullo,
                        idregToUse, rAnnul["idupb"],
                        rAnnul["competencystart"], rAnnul["competencystop"],
                        rAnnul, idaccmotiveAnnul, DBNull.Value, DBNull.Value, idepaccRicavo, idrelatedCurr,
                        rifDetail + rAnnul["detaildescription"]);
                }

                //Scrittura sul debito, ma sull'impegno dell'ultimo dettaglio
                EP.EffettuaScritturaImpegnoBudget(idepcontextAnnull,
                    importoDebito, //importocosto + valore_iva - sconto,
                    idaccRegistry,
                    idregToUse, rAnnul["idupb"],
                    rAnnul["competencystart"], rAnnul["competencystop"],
                    //rAnnul, idaccmotiveMainDebit2, idepexp, idepacc, idrelated);
                    rAnnul, idaccmotiveAnnul, idepexpDebito, DBNull.Value, idrelatedLast,
                    nomeDebito + " n°" + rAnnul["rownum"].ToString());


                if (EP.saldo != 0) {
                    ShowMessage("Si è verificata una squadratura sul dettaglio n° " +  rAnnul["rownum"]
                    + rAnnul["detaildescription"] +
                                " (annullamento)");
                }

            }

            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }

        decimal quotaIncassataDettaglioContrattoAttivo(DataRow rDet) {
            if (rDet["idinc_taxable"] == DBNull.Value) return 0;
            decimal amountDettaglio =
                CfgFn.GetNoNullDecimal(Conn.readValue("estimatedetailview", q.keyCmp(rDet), "taxable_euro"));
            int idinc = CfgFn.GetNoNullInt32(rDet["idinc_taxable"]);
            decimal accertato = CfgFn.GetNoNullDecimal(Conn.readValue("estimatedetailview",
                q.eq("idinc_taxable", idinc) & q.isNull("stop"), "sum(taxable_euro"));
            decimal incassato = CfgFn.GetNoNullDecimal(Conn.DO_SYS_CMD(
                $@"SELECT SUM(et.curramount) from incomelink elink 
			join incomelast ela on elink.idchild=ela.idinc
			join incometotal et on et.idinc=ela.idinc
			where elink.idparent= {idinc}"));
            return CfgFn.RoundValuta((accertato / incassato) * amountDettaglio);
        }

        decimal quotaPagataDettaglioContrattoPassivo(DataRow rDet) {
            if (rDet["idexp_taxable"] == DBNull.Value) return 0;
            decimal amountDettaglio =
                CfgFn.GetNoNullDecimal(Conn.readValue("mandatedetailview", q.keyCmp(rDet), "taxable_euro"));
            int idexp = CfgFn.GetNoNullInt32(rDet["idexp_taxable"]);
            decimal impegnato = CfgFn.GetNoNullDecimal(Conn.readValue("mandatedetailview",
                q.eq("idexp_taxable", idexp) & q.isNull("stop"), "sum(taxable_euro"));
            decimal pagato = CfgFn.GetNoNullDecimal(Conn.DO_SYS_CMD(
                $@"SELECT SUM(et.curramount) from expenselink elink 
						join expenselast ela on elink.idchild=ela.idexp
						join expensetotal et on et.idexp=ela.idexp
						where elink.idparent= {idexp}"));
            return CfgFn.RoundValuta((impegnato / pagato) * amountDettaglio);
        }

        private bool generaScrittureRisconti(DataRow curr, BudgetFunction bf) {
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            string kind = curr["kind"].ToString().ToUpper(); //D / U
            string tipo_doc = kind == "D" ? "Costituzione Risconto/Riserva cesp." : "Utilizzo Risconti/Riserve cesp.fin.";
            object doc = $"{tipo_doc}";
            string tipo_description = kind == "D" ? "Costituzione risconto/Riserva su cespiti" : "Utilizzo Risconti/Riserve su cespiti finanziati";
            object description = $"{tipo_description} {curr["yload"]}";
            DataTable assetgrantload = DS.Tables["assetgrantload"];
            if (CfgFn.GetNoNullInt32(curr["yload"]) != esercizio) {
                if (!silent) ShowMessage("Questa {tipo} non fa parte di questo esercizio.", "Errore");
                return false;
            }

            object idaccmotive_RiscPassivo = Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", Conn.GetEsercizio()),
                "idaccmotive_grantdeferredcost");
            object idaccRiscPassivo = getIdAccFromMotive(idaccmotive_RiscPassivo, DBNull.Value);
            if (idaccRiscPassivo == DBNull.Value || idaccmotive_RiscPassivo == null) {
                ShowMessage(
                    $"Non è stato definito il conto di risconto passivo per i risconti dei contributi conto impianti del {Conn.GetEsercizio()}"
                    , "Errore");
                return false;
            }
            //Conto associato al risultato economico precedente
            object idacc_previous_economic_result = Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", Conn.GetEsercizio()),
                "idacc_previous_economic_result");
            object idaccmotive_RiscRicavo = Conn.DO_READ_VALUE("config", QHS.CmpEq("ayear", Conn.GetEsercizio()),
                "idaccmotive_grantrevenue");
            object idaccRiscRicavo = getIdAccFromMotive(idaccmotive_RiscRicavo, DBNull.Value);
            if (idaccRiscRicavo == DBNull.Value || idaccmotive_RiscRicavo == null) {
                ShowMessage(
                    $"Non è stato definito il conto di ricavo per i risconti dei contributi conto impianti del {Conn.GetEsercizio()}"
                    , "Errore");
                return false;
            }

            string oggetto = kind == "D"
                ? $"Contributi anno {Conn.GetEsercizio()}"
                : $"Applicazione risconti anno {Conn.GetEsercizio()}";


            string filterMainCurrent = QHC.CmpKey(curr);
            string idrelated = BudgetFunction.GetIdForDocument(curr).ToLower();

            DataTable assetgrant = Conn.RUN_SELECT("assetgrant", "*", null, QHS.CmpKey(curr), null, false);
            DataTable assetgrantdetail = Conn.RUN_SELECT("assetgrantdetail", "*", null, QHS.CmpKey(curr), null, false);
            object dataAccertamenti = curr["adate"];

            DataRow mainEntry = EP.SetEntry(description, dataAccertamenti, doc, dataAccertamenti,
                EP_functions.GetIdForDocument(curr));
            //CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);

            object idaccRegistry = DBNull.Value;

            foreach (DataRow rGrant in assetgrant.Rows) {
                var idrel = BudgetFunction.GetIdForDocument(rGrant);
                string idepcontext = "MAN";
                string descrCespite = getDescrCespite(rGrant["idasset"], rGrant["idpiece"]);
                object idaccmotive = rGrant["idaccmotive"];
                if (idaccmotive == DBNull.Value) {
                    object descr = rGrant["description"];
                    ShowMessage(
                        $"La definizione del contributo {descr} del  {descrCespite} non ha una causale associata",
                        "Errore");
                    return false;
                }

                object idupb = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrant, "idasset", "idpiece"), "idupb");
                if (idupb == null || idupb == DBNull.Value) {
                    ShowMessage($"Il {descrCespite} non ha una UPB associata", "Errore");
                    return false;
                }

                decimal amount = CfgFn.GetNoNullDecimal(rGrant["amount"]);
                var idacc = getIdAccFromMotive(idaccmotive, idupb);
                if (idacc == null || idacc == DBNull.Value) {
                    ShowMessage(
                        $"Causale non configurata bene per il contributo {rGrant["description"]} del  {descrCespite}",
                        "Errore");
                    return false;
                }

                object idregToUse = DBNull.Value;
                object idepacc = rGrant["idepacc"];
                if (idepacc == DBNull.Value) idepacc = getIdEpAccByIdRelated(idrel, 2);
                object flag_financesource = rGrant["flag_financesource"];
                object flag_entryprofitreservedone = rGrant["flag_entryprofitreservedone"];
                // flag_financesource
                //C : Contributo agli investimenti finanziato da terzi
                //U: Utili di esercizi precedenti(l'utile fa le veci del finanziamento )
                if (flag_financesource == DBNull.Value || (flag_financesource.ToString() == "C")) {
                    //APERTURA DEL RISCONTO
                    //RICAVO    A     RISCONTO
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        amount, idacc, idregToUse, idupb, DBNull.Value, DBNull.Value,
                        null, idaccmotive, DBNull.Value, DBNull.Value, idepacc, idrel,
                        $"Contributo {rGrant["description"]} del {descrCespite}");

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        -amount, idaccRiscPassivo, idregToUse, idupb, DBNull.Value, DBNull.Value,
                        null, idaccmotive_RiscPassivo, DBNull.Value, DBNull.Value, idepacc, idrel,
                        $"Contributo {rGrant["description"]} del {descrCespite}");
                }
				else {
                    // flag_financesource vale U
                    if (flag_entryprofitreservedone.ToString() == "N") {
                        //La scrittura manuale di costituzione delle riserve non è stata fatta
                        if (idacc_previous_economic_result == DBNull.Value || idacc_previous_economic_result == null) {
                            ShowMessage(
                                $"Non è stato definito il Conto associato al risultato economico precedente del {Conn.GetEsercizio()}"
                                , "Errore");
                            return false;
                        }
                        // RISULTATI ESERCIZI PRECEDENTI a RISERVA FUTURI AMMORTAMENTI
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            amount, idacc_previous_economic_result, idregToUse, idupb, DBNull.Value, DBNull.Value,
                            null, null, DBNull.Value/*causale*/, DBNull.Value, DBNull.Value/*idepacc*/, idrel,
                            $"Utili di eserc. prec. {rGrant["description"]} del {descrCespite}");

                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            -amount, idacc, idregToUse, idupb, DBNull.Value, DBNull.Value,
                            null, idaccmotive, DBNull.Value, DBNull.Value, DBNull.Value/*idepacc*/, idrel,
                            $"Utili di eserc. prec. {rGrant["description"]} del {descrCespite}");

                    }
                }
            }

            foreach (DataRow rGrantDet in assetgrantdetail.Rows) {
                string idepcontext = "ESTIM";
                var idrel = BudgetFunction.GetIdForDocument(rGrantDet);
                string descrCespite = getDescrCespite(rGrantDet["idasset"], rGrantDet["idpiece"]);
                object idaccmotive = idaccmotive_RiscRicavo; // config.idaccmotive_grantrevenue
                var idaccTouse = idaccRiscRicavo;
                object idupb = Conn.DO_READ_VALUE("assetview", QHS.MCmp(rGrantDet, "idasset", "idpiece"), "idupb");
                if (idupb == null || idupb == DBNull.Value) {
                    ShowMessage($"Il {descrCespite} non ha una UPB associata", "Errore");
                    return false;
                }

                int ygrant = CfgFn.GetNoNullInt32(Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "ygrant"));

                if (idaccmotive == DBNull.Value || ygrant == Conn.GetEsercizio()) {
                    idaccmotive = Conn.DO_READ_VALUE("assetgrant", QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"),
                        "idaccmotive");
                    idaccTouse = getIdAccFromMotive(idaccmotive, idupb);
                }
                object assetgrant_idaccmotive = Conn.DO_READ_VALUE("assetgrant", QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"),     "idaccmotive");
                var assetgrant_idacc = getIdAccFromMotive(idaccmotive, idupb);

                object descrGrant = Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "description");

                decimal amount = CfgFn.GetNoNullDecimal(rGrantDet["amount"]);

                object idregToUse = DBNull.Value;
                object idepacc = rGrantDet["idepacc"];
                if (idepacc == DBNull.Value) idepacc = getIdEpAccByIdRelated(idrel, 2);

                if (idaccTouse == null || idaccTouse == DBNull.Value) {
                    ShowMessage($"Causale non configurata bene per il contributo {descrGrant} del  {descrCespite}",
                        "Errore");
                    return false;
                }
                object flag_financesource = Conn.DO_READ_VALUE("assetgrant",
                    QHS.MCmp(rGrantDet, "idgrant", "idasset", "idpiece"), "flag_financesource");
                // flag_financesource
                //C : Contributo agli investimenti finanziato da terzi
                //U: Utili di esercizi precedenti(l'utile fa le veci del finanziamento )
                if (flag_financesource == DBNull.Value || (flag_financesource.ToString() == "C")) {
                    //COSNSUMO DEL RISCONTO
                    //RISCONTO    A     RICAVO
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                    amount, idaccTouse, idregToUse, idupb, DBNull.Value, DBNull.Value,
                    null, idaccmotive, DBNull.Value, DBNull.Value, idepacc, idrel,
                    $"Risconto {descrGrant} del {descrCespite}");

                    // idaccmotive_RiscPassivo letto da config.idaccmotive_grantdeferredcost
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        -amount, idaccRiscPassivo, idregToUse, idupb, DBNull.Value, DBNull.Value,
                        null, idaccmotive_RiscPassivo, DBNull.Value, DBNull.Value, idepacc, idrel,
                        $"Risconto {descrGrant} del {descrCespite}");
                }
                else {
                        //La scrittura manuale di costituzione delle riserve non è stata fatta
                        if (idacc_previous_economic_result == DBNull.Value || idacc_previous_economic_result == null) {
                            ShowMessage(
                                $"Non è stato definito il Conto associato al risultato economico precedente del {Conn.GetEsercizio()}"
                                , "Errore");
                            return false;
                        }
                        //RISERVA FUTURI AMMORTAMENTI a RISULTATI ESERCIZI PRECEDENTI
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        amount, idacc_previous_economic_result, idregToUse, idupb, DBNull.Value, DBNull.Value,
                        null, null/*causale*/, DBNull.Value, DBNull.Value, DBNull.Value/*idepacc*/, idrel,
                        $"Risconto {descrGrant} del {descrCespite}");

                        // idaccmotive_RiscPassivo letto da config.idaccmotive_grantdeferredcost
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            -amount, assetgrant_idacc, idregToUse, idupb, DBNull.Value, DBNull.Value,
                            null, assetgrant_idaccmotive, DBNull.Value, DBNull.Value, DBNull.Value/*idepacc*/, idrel,
                            $"Risconto {descrGrant} del {descrCespite}");
                }
            }

                EP.RemoveEmptyDetails();
                if (EP.D.Tables["entry"].Rows.Count == 0) {
                    if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                    return false;
                }

                return true;
            
        }

        DataTable tInventorySortingAmortizationYear;

        object getIdAccMotiveGerarchico(object idinventoryamortization, object idinv, string field) {
            int ayear = esercizio;
            if (tInventorySortingAmortizationYear == null) {
                tInventorySortingAmortizationYear = Conn.CreateTableByName("inventorysortingamortizationyear", "*");
            }

            string filter = QHC.AppAnd(QHC.CmpEq("idinventoryamortization", idinventoryamortization),
                QHC.CmpEq("idinv", idinv), QHC.CmpEq("ayear", ayear));


            if (tInventorySortingAmortizationYear.Select(filter).Length > 0) {
                DataRow rClass = tInventorySortingAmortizationYear.Select(filter)[0];
                return rClass[field];
            }

            string filterSQL = QHS.AppAnd(QHS.CmpEq("idinventoryamortization", idinventoryamortization),
                QHS.CmpEq("idinv", idinv), QHS.CmpEq("ayear", ayear));

            DataAccess.RUN_SELECT_INTO_TABLE(Conn, tInventorySortingAmortizationYear, null, filterSQL, null, true);
            if (tInventorySortingAmortizationYear.Select(filter).Length > 0) {
                DataRow rClass = tInventorySortingAmortizationYear.Select(filter)[0];
                return rClass[field];
            }

            object paridinv = Conn.DO_READ_VALUE("inventorytree",
                QHS.CmpEq("idinv", idinv), "paridinv");
            if (paridinv == null || paridinv == DBNull.Value) return null;

            return getIdAccMotiveGerarchico(idinventoryamortization, paridinv, field);

        }

        private object ottieniIdAccMotiveAmm(object tipoAmm, object idasset, object idpiece, string field) {
            string fAsset = QHS.AppAnd(QHS.CmpEq("idasset", idasset), QHS.CmpEq("idpiece", idpiece));
            object idinv = Conn.DO_READ_VALUE("assetview", fAsset, "idinv");
            if (idinv == null || idinv == DBNull.Value) {
                ShowMessage("Classificazione inventariale mancante al cespite n. " + idasset + " / " + idpiece,
                    "Errore");
                return null;
            }

            return getIdAccMotiveGerarchico(tipoAmm, idinv, field);

        }

        DataTable tInventoryAmortization = null;

        private DataRow ottieniRowTipoAmm(object idinventoryamortization) {
            if (idinventoryamortization == DBNull.Value) {
                return null;
            }

            if (tInventoryAmortization == null)
                tInventoryAmortization = Conn.RUN_SELECT("inventoryamortization", "*", null, null, null, false);
            string filter = QHC.CmpEq("idinventoryamortization", idinventoryamortization);
            string filterSQL = QHS.CmpEq("idinventoryamortization", idinventoryamortization);
            if (tInventoryAmortization.Select(filter).Length > 0) {
                return tInventoryAmortization.Select(filter)[0];
            }

            return null;
        }

        DataTable assetloadmotive = null;

        private bool isCaricoDaTrasferimento(object idmot) {
            if (idmot == DBNull.Value) {
                return false;
            }

            if (assetloadmotive == null)
                assetloadmotive = Conn.RUN_SELECT("assetloadmotive", "*", null, null, null, false);
            string filter = QHC.CmpEq("idmot", idmot);
            if (assetloadmotive.Select(filter).Length > 0) {
                DataRow r = assetloadmotive.Select(filter)[0];
                return (CfgFn.GetNoNullInt32(r["flag"]) & 2) != 0;
            }

            return false;
        }

        private object calcolaIdAccMotiveCausaleCarico(object idmot) {
            if (idmot == DBNull.Value) {
                return null;
            }

            if (assetloadmotive == null)
                assetloadmotive = Conn.RUN_SELECT("assetloadmotive", "*", null, null, null, false);
            string filter = QHC.CmpEq("idmot", idmot);
            if (assetloadmotive.Select(filter).Length > 0) {
                DataRow r = assetloadmotive.Select(filter)[0];
                return r["idaccmotive"];
            }

            return null;
        }

        DataTable assetunloadmotive = null;

        private object calcolaIdAccMotiveCausaleScarico(object idmot) {
            if (idmot == DBNull.Value) {
                return null;
            }

            if (assetunloadmotive == null)
                assetunloadmotive = Conn.RUN_SELECT("assetunloadmotive", "*", null, null, null, false);
            string filter = QHC.CmpEq("idmot", idmot);
            if (assetunloadmotive.Select(filter).Length > 0) {
                DataRow r = assetunloadmotive.Select(filter)[0];
                return r["idaccmotive"];
            }

            return null;
        }

        DataTable tInventoryTree = null;

        private object calcolaIdAccMotiveCaricoCespite(object idinv) {
            if (idinv == DBNull.Value) {
                return null;
            }

            if (tInventoryTree == null)
                tInventoryTree = Conn.CreateTableByName("inventorytree",
                    "idinv,idaccmotivediscount,idaccmotiveunload,idaccmotiveload,idaccmotivetransfer");
            string filter = QHC.CmpEq("idinv", idinv);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotiveload"];
            }

            string filtersql = QHS.CmpEq("idinv", idinv);
            DataAccess.RUN_SELECT_INTO_TABLE(Conn, tInventoryTree, null, filtersql, null, true);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotiveload"];
            }

            return null;
        }

        private object calcolaIdAccMotiveTrasferimentoCespite(object idinv) {
            if (idinv == DBNull.Value) {
                return null;
            }

            if (tInventoryTree == null)
                tInventoryTree = Conn.CreateTableByName("inventorytree",
                    "idinv,idaccmotivediscount,idaccmotiveunload,idaccmotiveload,idaccmotivetransfer");
            string filter = QHC.CmpEq("idinv", idinv);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotivetransfer"];
            }

            string filtersql = QHS.CmpEq("idinv", idinv);
            DataAccess.RUN_SELECT_INTO_TABLE(Conn, tInventoryTree, null, filtersql, null, true);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotivetransfer"];
            }

            return null;
        }

        private decimal calcolaImportoOriginaleCespite(DataRow rCespite) {
            string[] ParamName = new string[4] {"@idasset", "@idpiece", "@flagiva", "@totale"};
            SqlDbType[] tipi = new SqlDbType[4] {SqlDbType.Int, SqlDbType.Int, SqlDbType.Char, SqlDbType.Decimal};
            int[] len = new int[4] {0, 0, 1, 0};
            ParameterDirection[] dir = new ParameterDirection[4] {
                ParameterDirection.Input, ParameterDirection.Input,
                ParameterDirection.Input, ParameterDirection.Output
            };
            object[] valori = new object[4] {rCespite["idasset"], rCespite["idpiece"], "S", null};
            bool res = Conn.CallSPParameter("get_originalassetvalue", ParamName, tipi, len, dir, ref valori, true, -1);
            if (res) return CfgFn.GetNoNullDecimal(valori[3]);
            QueryCreator.ShowError(null, "Errore chiamando get_originalassetvalue.", Conn.LastError);
            return 0;
        }

        private decimal calcolaImportoInizialeCespite(DataRow rCespite) {
            string[] ParamName = new string[3] {"@idasset", "@idpiece", "@initialamount"};
            SqlDbType[] tipi = new SqlDbType[3] {SqlDbType.Int, SqlDbType.Int, SqlDbType.Decimal};
            int[] len = new int[3] {0, 0, 0};
            ParameterDirection[] dir = new ParameterDirection[3] {
                ParameterDirection.Input, ParameterDirection.Input,
                ParameterDirection.Output
            };
            object[] valori = new object[3] {rCespite["idasset"], rCespite["idpiece"], null};
            bool res = Conn.CallSPParameter("get_initialamount", ParamName, tipi, len, dir, ref valori, true, -1);
            if (res) return CfgFn.GetNoNullDecimal(valori[2]);
            QueryCreator.ShowError(null, "Errore chiamando get_initialamount", Conn.LastError);
            return 0;
        }


        private decimal calcolaTotAccessoriPossedutiScaricati(DataRow rCespite) {
            string filter = QHS.AppAnd(QHS.CmpEq("idasset", rCespite["idasset"]),
                QHS.CmpEq("idpiece", rCespite["idpiece"]));
            string query = "SELECT a.subtractions FROM assetview_current a "
                           + " WHERE " + filter;

            object importo = DataAccess.DO_SYS_CMD(Conn, query, true);
            return CfgFn.GetNoNullDecimal(importo);
        }

        private decimal calcolaimportoSvalutazioni(DataRow rCespite) {
            string filter = QHS.AppAnd(QHS.BitClear("i.flag", 3), QHS.CmpEq("idasset", rCespite["idasset"]),
                QHS.CmpEq("idpiece", rCespite["idpiece"]));
            string query = "SELECT a.amount FROM assetamortizationunloadview a "
                           + " JOIN inventoryamortization i ON i.idinventoryamortization = a.inventoryamortization "
                           + " WHERE " + filter;

            object importo = DataAccess.DO_SYS_CMD(Conn, query, true);
            return CfgFn.GetNoNullDecimal(importo);
        }

        private object calcolaCausaleEpScaricoCespite(object idinv) {
            if (idinv == DBNull.Value) {
                return null;
            }

            if (tInventoryTree == null)
                tInventoryTree = Conn.CreateTableByName("inventorytree",
                    "idinv,idaccmotiveunload,idaccmotiveload,idaccmotivediscount,idaccmotivetransfer");
            string filter = QHC.CmpEq("idinv", idinv);
            string filterSQL = QHS.CmpEq("idinv", idinv);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotiveunload"];
            }

            Conn.RUN_SELECT_INTO_TABLE(tInventoryTree, null, filterSQL, null, true);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotiveunload"];
            }

            return null;
        }

        private object calcolaIdAccMotiveScontoCespite(object idinv) {
            if (idinv == DBNull.Value) {
                return null;
            }

            if (tInventoryTree == null)
                tInventoryTree = Conn.CreateTableByName("inventorytree",
                    "idinv,idaccmotiveunload,idaccmotiveload,idaccmotivediscount,idaccmotivetransfer");
            string filter = QHC.CmpEq("idinv", idinv);
            string filterSQL = QHS.CmpEq("idinv", idinv);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotivediscount"];
            }

            Conn.RUN_SELECT_INTO_TABLE(tInventoryTree, null, filterSQL, null, true);
            if (tInventoryTree.Select(filter).Length > 0) {
                DataRow r = tInventoryTree.Select(filter)[0];
                return r["idaccmotivediscount"];
            }

            return null;
        }

        bool generaScrittureBuonoScarico(DataRow curr, BudgetFunction bf) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            object idreg = curr["idreg"];

            int yassetunload = CfgFn.GetNoNullInt32(curr["yassetunload"]);
            if (yassetunload != esercizio) {
                //if (!silent) {
                ShowMessage("Il buono non appartiene all'esercizio corrente", "Avviso");
                //}

                return false;
            }

            DataTable assetamortizationunloadview;
            if (DS.Tables.Contains("assetamortizationunloadview")) {
                assetamortizationunloadview = DS.Tables["assetamortizationunloadview"];
            }
            else {
                assetamortizationunloadview = Conn.RUN_SELECT("assetamortizationunloadview", "*", null,
                    QHS.CmpEq("idassetunload", curr["idassetunload"]), null, false);
            }

            DataTable assetpieceview;
            if (DS.Tables.Contains("assetpieceview")) {
                assetpieceview = DS.Tables["assetpieceview"];
            }
            else {
                assetpieceview = Conn.RUN_SELECT("assetpieceview", "*", null,
                    QHS.CmpEq("idassetunload", curr["idassetunload"]), null, false);
            }

            //filtra a monte solo i carichi effettuati con una causale non di reddito,salta quelli senza causale di carico
            DataTable assetamortizationrisconti = Conn.RUN_SELECT("assetamortizationrisconti", "*", null,
                QHS.AppAnd(QHS.CmpEq("idassetunload", curr["idassetunload"]),
                    QHS.IsNotNull("idaccmotive"),
                    QHS.BitSet("flagaccountusage", 3)), null, false);
            assetamortizationrisconti.TableName = "assetamortization";

            object doc = "Buono Scarico " +
                         curr["idassetunloadkind"].ToString() + "/" +
                         curr["yassetunload"].ToString().Substring(2, 2) + "/" +
                         curr["nassetunload"].ToString().PadLeft(6, '0');


            object descr = (curr["description"] != DBNull.Value) ? curr["description"] : ".";
            DataRow rr = EP.SetEntry(descr, curr["adate"], doc, curr["adate"], EP_functions.GetIdForDocument(curr));

            EP.ClearDetails(rr);



            string idepcontext = "";
            object idaccmotiveReddito = getIdAccMotiveRiscontoReddito();
            DataRow[] rEntriesReddito = EP.GetAccMotiveDetails(idaccmotiveReddito);


            if (assetamortizationrisconti.Rows.Count > 0) {
                if (rEntriesReddito.Length != 1) {
                    DataRow rAm = assetamortizationrisconti.Rows[0];
                    string rAmStr = $"cespite di inventario {rAm["ninventory"]} {rAm["inventory"]} ";
                    if (!silent)
                        ShowMessage(
                            "Causale di reddito  non configurata bene per i risconti su donazione (in config).\r\n" +
                            "E' presente un ammortamento sul " + rAmStr);
                    return false;
                }

                object idaccReddito = rEntriesReddito[0]["idacc"];
                DataRow RAccountReddito = EP.getRowIdAcc(idaccReddito);
                foreach (DataRow rAssAmm in assetamortizationrisconti.Rows) {
                    decimal importoAmm = -CfgFn.GetNoNullDecimal(rAssAmm["amount"]);
                    if (importoAmm == 0) continue;
                    if (rAssAmm["idassetunload"] == DBNull.Value) continue;
                    object tipoAmm = rAssAmm["idinventoryamortization"];
                    DataRow rInvAmm = ottieniRowTipoAmm(tipoAmm);
                    bool isAmmortamento = (CfgFn.GetNoNullByte(rInvAmm["flag"]) & 8) != 0;
                    idepcontext = (isAmmortamento) ? "AMMORTA" : "SVALUTA";
                    object idasset = rAssAmm["idasset"];
                    object idpiece = rAssAmm["idpiece"];
                    object idupb = rAssAmm["idupb"];
                    object inventoryamortization = rAssAmm["inventoryamortization"];
                    object idaccmotiveRisconto = rAssAmm["idaccmotive"];
                    object idaccRisconto = rAssAmm["idacc"];
                    string parte3 = idpiece.ToString() == "1" ? " " : $" n. parte {idpiece} ";
                    if (idaccRisconto == DBNull.Value) {
                        if (!silent)
                            ShowMessage(
                                $"Causale di carico {curr["idaccmotive"]} del bene {curr["ninventory"]} dell'inventario {curr["inventory"]}  {parte3} non configurata bene.",
                                "Errore");
                        return false;
                    }

                    var idrel = BudgetFunction.GetIdForDocument(rAssAmm);
                    var idepaccReddito = getIdEpAccByIdRelated(idrel, 2);
                    //due scritture, una sul risconto passivo l'altra su un conto/causale di reddito da config
                    EP.EffettuaScritturaImpegnoBudget(idepcontext, -importoAmm, idaccReddito, idreg, idupb, null,
                        idaccmotiveReddito,
                        null, idepaccReddito, idrel, rAssAmm["description"]);

                    string idrelatedEpExp = BudgetFunction.ComposeObjects(
                        new object[] {"assetload", rAssAmm["idassetload"], rAssAmm["nassetacquire"]});
                    object idepexp = getIdEpExpByIdRelated(idrelatedEpExp, 2);

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoAmm, idaccRisconto, idreg, idupb, 
                        null, null, rAssAmm, 
                        idaccmotiveRisconto, rAssAmm["idcostpartition"], idepexp, null, idrel, 
                        $"Risconto cespite {rAssAmm["inventory"]} {rAssAmm["ninventory"]} {parte3} {rAssAmm["description"]}");


                }
            }


            foreach (DataRow rAssAmm in assetamortizationunloadview.Rows) {
                decimal importoAmm = -CfgFn.GetNoNullDecimal(rAssAmm["amount"]);
                if (importoAmm == 0) continue;
                if (rAssAmm["idassetunload"] == DBNull.Value) continue;
                object tipoAmm = rAssAmm["idinventoryamortization"];
                DataRow rInvAmm = ottieniRowTipoAmm(tipoAmm);
                bool isAmmortamento = (CfgFn.GetNoNullByte(rInvAmm["flag"]) & 8) != 0;
                idepcontext = (isAmmortamento) ? "AMMORTA" : "SVALUTA";
                object idasset = rAssAmm["idasset"];
                object idpiece = rAssAmm["idpiece"];
                object idupb = rAssAmm["idupb"];
                string parte2 = idpiece.ToString() == "1" ? " " : $" n. parte {idpiece} ";
                object inventoryamortization = rAssAmm["inventoryamortization"];
                object idaccmotive = ottieniIdAccMotiveAmm(tipoAmm, idasset, idpiece, "idaccmotive");
                if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                    string textVar = (isAmmortamento) ? "dell'ammortamento " : "della svalutazione ";
                    ShowMessage(
                        "La causale E/P " + textVar + inventoryamortization.ToString() + " non è stata configurata!" +
                        "\nInserire la configurazione sulla classificazione inventariale del cespite ammortizzato" +
                        "\n(menu: Cespiti > Classificazione inventariale).",
                        "Errore");
                    return false;
                }

                DataRow[] ContiSpesa = EP.GetAccMotiveDetails(idaccmotive.ToString());
                var idrel = BudgetFunction.GetIdForDocument(rAssAmm);
                foreach (DataRow r in ContiSpesa) {
                    object idacc = r["idacc"];
                    //EP.EffettuaScrittura(idepcontext, importoAmm, idacc, idreg, idupb, null, null, rAssAmm, idaccmotive);
                    string what = ((isAmmortamento) ? "ammortamento " : "svalutazione ") +
                                  inventoryamortization.ToString() + " " + rAssAmm["inventory".ToString()] + " " +
                                  rAssAmm["ninventory"] + parte2
                                  + rAssAmm["description"];
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoAmm, idacc, idreg, idupb, 
                        null, null, rAssAmm,
                        idaccmotive, rAssAmm["idcostpartition"],
                        EP.isCosto(idacc) ? getIdEpExpByIdRelated(idrel, 2) : null,
                        null, idrel, what);
                }
            }

            foreach (DataRow rAsset in assetpieceview.Rows) {
                var idrel = BudgetFunction.GetIdForDocument(rAsset);
                if (rAsset["idassetunload"] == DBNull.Value) continue;
                idepcontext = "SCARICO";
                object idupb = rAsset["idupb"];
                string parte = rAsset["idpiece"].ToString() == "1" ? " " : $" n. parte {rAsset["idpiece"]} ";

                // Devo applicare la causale di scarico, devo solo calcolare l'importo del bene da scaricare
                // perché ci possono essere delle svalutazioni associati (solo se sono svalutazioni perché se sono
                // ammortamenti non ci sono problemi)
                decimal importoIniziale = calcolaImportoInizialeCespite(rAsset);
                decimal importoAccessPossedutiScaricati = calcolaTotAccessoriPossedutiScaricati(rAsset);
                decimal importoSvalutazioni = calcolaimportoSvalutazioni(rAsset);
                // Faccio la somma algebrica, sottraendo già in partenza le svalutazioni
                decimal importoAttuale = importoIniziale - importoAccessPossedutiScaricati + importoSvalutazioni;

                object idaccAssetLoadTrasferimento = calcolaIdAccMotiveTrasferimentoCespite(rAsset["idinv"]);

                decimal valoreStorico = CfgFn.GetNoNullDecimal(rAsset["historicalvalue"]);
                decimal importoOriginale = CfgFn.GetNoNullDecimal(rAsset["cost"]);
                decimal ammPregressi = 0;
                if (valoreStorico > importoOriginale && idaccAssetLoadTrasferimento != null &&
                    idaccAssetLoadTrasferimento != DBNull.Value) {
                    ammPregressi = valoreStorico - importoOriginale;
                    DataRow[] ContiTrasferimento = EP.GetAccMotiveDetails(idaccAssetLoadTrasferimento);
                    if (!ContiTrasferimento._HasRows()) {
                        ShowMessage("Causale di trasferimento non configurata bene per il Cespite n." +
                                    rAsset["idasset"] + " / " + rAsset["idpiece"]);
                        return false;
                    }

                    var idrelatedEpExp = BudgetFunction.GetIdForDocument(curr) + "§" + rAsset["idasset"] + "§" +
                                         rAsset["idpiece"];
                    foreach (DataRow conto in ContiTrasferimento) {
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, ammPregressi, conto["idacc"],
                            idreg, idupb,
                            null, null, null, idaccAssetLoadTrasferimento, rAsset["idcostpartition"], null, null,
                            idrelatedEpExp + "§transfer",
                            $"Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}");
                    }
                }


                // devo integrare la scrittura sui cespiti con le eventuali svalutazioni trovate
                DataTable tAmmortamento = new DataTable();
                string query =
                    "SELECT a.amount, a.idinventoryamortization,a.idasset,a.idpiece, a.inventoryamortization,a.idsor1,a.idsor2,a.idsor3, a.idcostpartition " +
                    " ,inventory,ninventory, a.description , isnull(a.idassetunload, "+ rAsset["idassetunload"]+ " ) as idassetunload, a.namortization " +
                    " FROM assetamortizationunloadview a "
                    + " JOIN inventoryamortization i ON i.idinventoryamortization = a.idinventoryamortization "
                    + " WHERE " + QHS.AppAnd(QHS.MCmp(rAsset, new string[] {"idasset", "idpiece"}),
                        QHS.BitSet("i.flag", 3));
                tAmmortamento = Conn.SQLRunner(query);

                decimal totammortamenti = 0;
                tAmmortamento.TableName = "assetamortizationunloadview";
                foreach (DataRow rAmm in tAmmortamento.Rows) {
                    decimal importoAmm = -CfgFn.GetNoNullDecimal(rAmm["amount"]);
                    if (importoAmm == 0) continue;

                    totammortamenti += importoAmm;
                    object tipoAmm = rAmm["idinventoryamortization"];
                    object idasset = rAmm["idasset"];
                    object idpiece = rAmm["idpiece"];
                    object inventoryamortization = rAmm["inventoryamortization"];
                    object idaccmotiveunload = ottieniIdAccMotiveAmm(tipoAmm, idasset, idpiece, "idaccmotiveunload");

                    if ((idaccmotiveunload == null) || (idaccmotiveunload == DBNull.Value)) {
                        string textVar = "dell'ammortamento ";
                        ShowMessage("Cespite n." + rAsset["idasset"] + " / " + rAsset["idpiece"] +
                                    "\nLa causale E/P " + textVar + inventoryamortization.ToString() + " non è stata configurata!" +
                                    "\nInserire la configurazione sulla classificazione inventariale del cespite ammortizzato" +
                                    "\n(menu: Cespiti > Classificazione inventariale).",
                            "Errore");
                        return false;                        
                    }

                    string parte1 = idpiece.ToString() == "1" ? " " : $" n. parte {idpiece} ";
                    string what = "ammortamento " +
                                  inventoryamortization.ToString() + " " + rAmm["inventory".ToString()] + " " +
                                  rAmm["ninventory"] + parte1
                                  + rAmm["description"];

                    DataRow[] ContiAmm = EP.GetAccMotiveDetails(idaccmotiveunload);
                    var idrelAmm = BudgetFunction.GetIdForDocument(rAmm);
                    foreach (DataRow rr3 in ContiAmm) {
                        object idaccamm = rr3["idacc"];

						// Se il cespite è stato ammortizzato ad esempio per 20
						//(chiusura fondo)
						//Fondo amm.        20 DARE
						//Immobilizzazione  20 AVERE
						//se la deve vedere da solo in base al tipo conto ed al contesto
						//if (EP.isImmobilizzazione(idaccamm)) {
						
                        if (!EP.isCosto(idaccamm)) {
                            EP.EffettuaScritturaIdRelated(idepcontext, importoAmm, idaccamm, idreg, idupb, null,
							    idaccmotiveunload, idrelAmm, what);
                        }
                        else {
                            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoAmm, idaccamm, idreg, idupb, rAmm,
                                null, null, idaccmotiveunload, rAmm["idcostpartition"], null, null, idrelAmm, what);
						}

						//}

					}
                }

                object idaccmotive = calcolaCausaleEpScaricoCespite(rAsset["idinv"]);

                decimal importoattualelordo = importoAttuale;
                importoAttuale -= totammortamenti;
                if (importoAttuale != 0) {
                    if ((idaccmotive == null) || (idaccmotive == DBNull.Value)) {
                        ShowMessage("Non è stata specificata la causale per la class. inventariale del cespite n." +
                                    rAsset["idasset"] + "/" + rAsset["idpiece"], "Errore");
                        return false;
                    }

                    DataRow[] ContiSpesa = EP.GetAccMotiveDetails(idaccmotive);
                    foreach (DataRow r in ContiSpesa) {
                        object idacc = r["idacc"];
                        if (!EP.isCosto(idacc)) {
                            EP.EffettuaScritturaIdRelated(idepcontext, importoAttuale, idacc, idreg, idupb, rAsset,
                                idaccmotive, idrel,
                                $"Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}");
                        }
                        else {

                            var idrelatedEpExp = BudgetFunction.GetIdForDocument(curr) + "§" + rAsset["idasset"] + "§" +
                                                 rAsset["idpiece"];
                            idrelatedEpExp += EP.isImmobilizzazione(idacc) ? "" : "§costo"; //era "§immob": "§costo"
                            object idepexp = EP.isImmobilizzazione(idacc)
                                ? DBNull.Value
                                : getIdEpExpByIdRelated(idrelatedEpExp, 2);
                            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoAttuale, idacc, idreg, idupb,
                                    null, null, 
                                    rAsset, idaccmotive, rAsset["idcostpartition"],
                                    idepexp, null, idrelatedEpExp,
                                    $"Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}");
                        }
                    }

                    //Scarico cespite di bene con Risconto passivo su donazioni
                    DataTable tAssetRisc = Conn.RUN_SELECT("assetrisconti", "*", null, QHS.AppAnd(
                        QHS.CmpEq("idasset", rAsset["idasset"]), QHS.CmpEq("idpiece", rAsset["idpiece"]),
                        QHS.IsNotNull("idaccmotive"),
                        QHS.BitSet("flagaccountusage", 3)), null, false);
                    object idaccRisconto = null;
                    if (tAssetRisc.Rows.Count > 0) {
                        idaccRisconto = tAssetRisc.Rows[0]["idacc"];
                    }

                    //In DARE ho il risconto passivo(aperto in avere quando ho effettuato il buono di carico causale donazione vincolata) 
                    //per un valore pari alla differenza tra il valore dell'immobilizzazione e il suo fondo ammortamento 
                    //in AVERE il ricavo

                    #region risconto passivo

                    if ((idaccRisconto != DBNull.Value) && (idaccRisconto != null)) {
                        DataRow assetRisc = tAssetRisc.Rows[0];

                        if (rEntriesReddito.Length != 1) {
                            string rAmStr = $"cespite di inventario {rAsset["ninventory"]} {rAsset["inventory"]} ";
                            if (!silent)
                                ShowMessage(
                                    "Causale di reddito  non configurata bene per i risconti su donazione (in config).\r\n" +
                                    "Deve essere scaricato il " + rAmStr);
                            return false;
                        }

                        string idrelatedEpExp = BudgetFunction.ComposeObjects(
                            new object[] {"assetload", assetRisc["idassetload"], assetRisc["nassetacquire"]});
                        object idepexp = getIdEpExpByIdRelated(idrelatedEpExp, 2);
                        // la parte costo dello scarico del risconto va sull'impegno di budget nato in fase di carico cespite
                        //    11062 Scarico cespite di bene con Risconto passivo su donazioni
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, -importoAttuale, idaccRisconto, idreg, idupb,
                            null, null,
                            rAsset,
                            idaccmotive, rAsset["idcostpartition"], idepexp, null, idrel,
                            $"Risconto Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}");


                        // Deve collegarsi all'accertamento di budget generato allo stesso modo di come fa l'ammortamento
                        object idaccReddito = rEntriesReddito[0]["idacc"];
                        DataRow RAccountReddito = EP.getRowIdAcc(idaccReddito);
                        var idrelacc = BudgetFunction.ComposeObjects(new[] {
                            BudgetFunction.GetIdForDocument(curr),
                            rAsset["idasset"], rAsset["idpiece"]
                        });
                        var idepaccReddito = getIdEpAccByIdRelated(idrelacc, 2);
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoAttuale, idaccReddito, idreg, idupb,
                            null, null, rAsset,
                            idaccmotive, rAsset["idcostpartition"], null, idepaccReddito, idrelacc,
                            $"Risconto Scarico cespite {rAsset["inventory"]} {rAsset["ninventory"]} {parte}");

                    }

                    #endregion


                }


            }

            EP.RemoveEmptyDetails();

            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }


        private bool generaScrittureBuonoCarico(DataRow curr, BudgetFunction bf) {
            if (curr.RowState == DataRowState.Deleted) {
                //Should delete the related entries 
                return false;
            }

            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }

            DataTable assetacquireview;
            if (DS.Tables.Contains("assetacquireview")) {
                assetacquireview = DS.Tables["assetacquireview"];
            }
            else {
                assetacquireview = Conn.RUN_SELECT("assetacquireview", "*", null,
                    QHS.CmpEq("idassetload", curr["idassetload"]), null, false);
            }

            int ndetails = assetacquireview.Rows.Count;

            bool epexists = EP.MainEntryExists();
            if ((epexists == false) && (ndetails == 0)) return false; //No details- no use for EP



            object doc = "Buono Carico " +
                         curr["idassetloadkind"].ToString() + "/" +
                         curr["yassetload"].ToString().Substring(2, 2) + "/" +
                         curr["nassetload"].ToString().PadLeft(6, '0');

            int yload = CfgFn.GetNoNullInt32(curr["yassetload"]);
            if (yload != esercizio) {
                if (!silent) {
                    ShowMessage("Il buono non appartiene all'esercizio corrente", "Avviso", false);
                }

                return false;
            }

            object descr = (curr["description"] != DBNull.Value) ? curr["description"] : ".";
            DataRow mainEntry = EP.SetEntry(descr, curr["adate"],
                doc, curr["adate"], EP_functions.GetIdForDocument(curr));
            //CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);

            //bool isAmmortamento = false;
            string idepcontext = "CARICO";

            foreach (DataRow rAssetAcquire in assetacquireview.Select()) {
                if (rAssetAcquire["idassetload"] == DBNull.Value) continue;
                string idrelated = BudgetFunction.GetIdForDocument(rAssetAcquire); //rAsset

                // Devo applicare la causale di carico, devo solo calcolare l'importo del bene da caricare
                // Verifico che la causale di carico abbia una causale EP impostata.
                // In caso contrario salto questo carico nella generazione scritture
                object assetloadMotive = rAssetAcquire["idmot"];

                //nel caso di carichi da trasferimenti devo prendere  la causale di SCARICO invece di quella di CARICO
                bool caricoDAtrasferimento = isCaricoDaTrasferimento(assetloadMotive);
                object idaccAssetLoadMotive = isCaricoDaTrasferimento(assetloadMotive)
                    ? calcolaCausaleEpScaricoCespite(rAssetAcquire["idinv"])
                    : calcolaIdAccMotiveCausaleCarico(assetloadMotive);


                object idaccAssetLoadTrasferimento = calcolaIdAccMotiveTrasferimentoCespite(rAssetAcquire["idinv"]);
                object idreg = rAssetAcquire["idreg"];
                object idupb = rAssetAcquire["idupb"];

                decimal valoreStorico = CfgFn.GetNoNullDecimal(rAssetAcquire["historicalvalue"]);
                decimal importoOriginale = CfgFn.GetNoNullDecimal(rAssetAcquire["cost"]);
                decimal ammPregressi = 0;
                if (valoreStorico > importoOriginale && idaccAssetLoadTrasferimento != null &&
                    idaccAssetLoadTrasferimento != DBNull.Value) {
                    ammPregressi = valoreStorico - importoOriginale;
                    DataRow[] ContiTrasferimento = EP.GetAccMotiveDetails(idaccAssetLoadTrasferimento);
                    if (!ContiTrasferimento._HasRows()) {
                        ShowMessage("Causale di trasferimento non configurata bene per il carico " +
                                    rAssetAcquire["nassetacquire"]);
                        return false;
                    }

                    foreach (DataRow conto in ContiTrasferimento) {
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, ammPregressi, conto["idacc"],
                            idreg, idupb,
                            null, null, rAssetAcquire, idaccAssetLoadTrasferimento, rAssetAcquire["idcostpartition"], null, null, idrelated + "§transfer",
                            rAssetAcquire["description"]);
                    }
                }

                decimal importoScontato = CfgFn.GetNoNullDecimal(rAssetAcquire["cost_discounted"]);
                decimal sconto = importoOriginale - importoScontato;
                //decimal importoUnitario = importoOriginale / CfgFn.GetNoNullDecimal(rAssetAcquire["number"]);

                object idaccmotiveImmobilizzazione = calcolaIdAccMotiveCaricoCespite(rAssetAcquire["idinv"]);
                object idaccmotiveSconto = calcolaIdAccMotiveScontoCespite(rAssetAcquire["idinv"]);

                if (idaccmotiveSconto == DBNull.Value) {
                    sconto = 0;
                    importoScontato = importoOriginale;
                }
                else {
                    importoOriginale = importoScontato; //questo è l'importo netto del costo
                }

                if (caricoDAtrasferimento && idaccAssetLoadMotive != null) {
                    DataRow[] contiScarico = EP.GetAccMotiveDetails(idaccAssetLoadMotive);
                    if (!contiScarico._HasRows()) {
                        ShowMessage("Causale di scarico non configurata bene per il carico" +
                                    rAssetAcquire["nassetacquire"]);
                        return false;
                    }

                    foreach (DataRow conto in contiScarico) {
                        object idepexp = (EP.isCosto(conto["idacc"]) & !EP.isImmobilizzazione(conto["idacc"]))
                            ? getIdEpExpByIdRelated(idrelated + "§reload", 2)
                            : DBNull.Value;
                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoOriginale, conto["idacc"],
                            idreg, idupb,
                            null, null, rAssetAcquire, idaccAssetLoadMotive, rAssetAcquire["idcostpartition"], idepexp, null, idrelated + "§reload",
                            rAssetAcquire["description"]);
                    }

                    continue;
                }


                if (((idaccAssetLoadMotive == null) || (idaccAssetLoadMotive == DBNull.Value)) && sconto == 0) continue;

                if (((idaccmotiveImmobilizzazione == null) || (idaccmotiveImmobilizzazione == DBNull.Value)) &&
                    sconto > 0) {
                    ShowMessage("Non è stata specificata la causale per la class. inventariale del carico n." +
                                rAssetAcquire["nassetacquire"], "Errore");
                    return false;
                }

                //importoAttuale -= totammortamenti;
                DataRow[] ContiImmobilizzazione = EP.GetAccMotiveDetails(idaccmotiveImmobilizzazione);
                if (!ContiImmobilizzazione._HasRows() && sconto > 0) {
                    ShowMessage("Causale di carico della class.inventariale non configurata bene per il carico " +
                                rAssetAcquire["nassetacquire"]);
                    return false;
                }

                object idaccImmobilizzazione = null;
                if (ContiImmobilizzazione._HasRows()) {
                    idaccImmobilizzazione = ContiImmobilizzazione._First()["idacc"];
                }

                bool isRicavo = false;
                object idaccReddito = DBNull.Value;
                bool isDebito = false;

                if (idaccAssetLoadMotive != null && idaccAssetLoadMotive != DBNull.Value) {
                    DataRow[] ContiRedditoCheck = EP.GetAccMotiveDetails(idaccAssetLoadMotive);
                    if (ContiRedditoCheck.Length != 0) {
                        idaccReddito = ContiRedditoCheck[0]["idacc"];
                        DataRow RAccountReddito = EP.getRowIdAcc(idaccReddito);
                        int flagReddito = CfgFn.GetNoNullInt32(RAccountReddito["flagaccountusage"]);
                        isRicavo = (flagReddito & 128) != 0;
                        // con 65536 check flag 'Altre voci del passivo', 16 flag 'Conto di Debito'
                        isDebito = (flagReddito & 65536) != 0 || (flagReddito & 16) != 0;
                    }
                }

                if (isRicavo) {
                    sconto = 0;
                    importoScontato = importoOriginale;
                }

                object idaccSconto = DBNull.Value;
                DataRow RAccountSconto = null;
                if (sconto > 0) {
                    DataRow[] ContiSconto = EP.GetAccMotiveDetails(idaccmotiveSconto);
                    if (ContiSconto.Length == 0) {
                        ShowMessage(
                            "Causale di reddito non configurata per il carico " + rAssetAcquire["nassetacquire"],
                            "Errore");
                        continue;
                    }

                    idaccSconto = ContiSconto[0]["idacc"];
                    RAccountSconto = EP.getRowIdAcc(idaccSconto);
                }

                if (sconto > 0) {
                    string idrelDiscount = idrelated + "§discount";

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, sconto, idaccImmobilizzazione, idreg, idupb,
                        null, null, rAssetAcquire, idaccmotiveImmobilizzazione, rAssetAcquire["idcostpartition"], getIdEpExpByIdRelated(idrelDiscount, 2),
                        null,
                        idrelDiscount, rAssetAcquire["description"]);

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, -sconto, idaccSconto, idreg, idupb,
                        null, null, null, idaccmotiveSconto, null, null, getIdEpAccByIdRelated(idrelDiscount, 2),
                        idrelDiscount, rAssetAcquire["description"]);
                }



                //IMMOBILIZZAZIONE preso dalla class. inventariale
                if (idaccAssetLoadMotive != null && idaccAssetLoadMotive != DBNull.Value) {
                    object idepexp = getIdEpExpByIdRelated(idrelated, 2);
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoOriginale, idaccImmobilizzazione,
                        idreg, idupb,
                        null, null, rAssetAcquire, idaccmotiveImmobilizzazione, rAssetAcquire["idcostpartition"], idepexp, null, idrelated + "§discount",
                        rAssetAcquire["description"]);

                    //REDDITO O RISCONTO PASSIVO preso dal carico cespite
                    if (idaccReddito != DBNull.Value) {
                        if (isRicavo) {
                            //Si tratta di un ricavo
                            object idepacc = getIdEpAccByIdRelated(idrelated, 2);
                            if ((idepacc == null || idepacc == DBNull.Value) && UsaAccertamentiDiBudget &&
                                esercizio > 2016) {
                                ShowMessage(
                                    "Non è stato trovato alcun accertamento di budget per il carico cespite", "Errore");
                                return false;
                            }

                            EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoOriginale, idaccReddito,
                                idreg, idupb,
                                null, null, rAssetAcquire, idaccAssetLoadMotive, rAssetAcquire["idcostpartition"], null, idepacc, idrelated,
                                rAssetAcquire["description"]);
                        }
                        else {
                            if (isDebito) {
                                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, importoOriginale, idaccReddito,
                                    idreg, idupb,
                                    null, null, null, idaccAssetLoadMotive, null, idepexp, null, idrelated,
                                    rAssetAcquire["description"]);
							}
                            else {
                                //Si tratta presumibilmente di un risconto passivo
                                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, -importoOriginale, idaccReddito,
                                    idreg, idupb,
                                    null, null, null, idaccAssetLoadMotive, null, idepexp, null, idrelated,
                                    rAssetAcquire["description"]);
                            }
                        }
                    }
                }


            }


            EP.RemoveEmptyDetails();

            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;
        }


        private bool generaScrittureContrattoAttivo(DataRow curr, BudgetFunction bf) {
            if (bf == null) {
                EP.GetEntryForDocument(curr);
            }
            else {
                EP.attachToDataSet(bf.D, EP_functions.GetIdForDocument(curr));
            }


            DataTable estimDet;
            if (DS.Tables.Contains("estimatedetail")) {
                estimDet = DS.Tables["estimatedetail"];
            }
            else {
                estimDet = Conn.RUN_SELECT("estimatedetail", "*", null, QHS.CmpKey(curr), null, false);
            }

            int ndetails = estimDet.Rows.Count;
            bool epexists = EP.MainEntryExists();
            if ((epexists == false) && (ndetails == 0)) return false; //No details- no use for EP

            object idreg = curr["idreg"];

            object doc;
            if (curr["doc"] != DBNull.Value) {
                doc = curr["doc"];
            }
            else {
                doc = "C.A. " + curr["idestimkind"] + ' ' + curr["yestim"].ToString().Substring(2, 2) + "/" +
                      curr["nestim"];
            }




            int yestim = CfgFn.GetNoNullInt32(curr["yestim"]);
            DateTime mainDate;

            mainDate = (DateTime) curr["adate"];

            DataRow mainEntry = EP.SetEntry(curr["description"], mainDate, doc, curr["docdate"],
                EP_functions.GetIdForDocument(curr));
            CopySecurity(curr, mainEntry);
            EP.ClearDetails(mainEntry);


            string idepcontext = "ESTIM";
            object idaccRegistry = DBNull.Value;

            if (curr["idreg"] != DBNull.Value) {
                idaccRegistry = EP.GetCustomerAccountForRegistry(curr["idaccmotivecredit"], curr["idreg"]);
            }

            if (curr["idreg"] != DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                ShowMessage("Non è stato configurato il conto di credito opportuno nel contratto " + doc, "Errore");
                return false;
            }

            double tassocambio = CfgFn.GetNoNullDouble(curr["exchangerate"]);
            string filterMainCurrent = QHC.CmpKey(curr);
            string filterdetails;
            DateTime primoGennaio = new DateTime(esercizio, 1, 1);
            DateTime trentunoDic = new DateTime(esercizio, 12, 31);

            string descrizioneCredito = nomeCAttivo(curr);

            //Cicla sui dettagli  (annullati e non)
            foreach (DataRow restimdet in estimDet.Select(filterMainCurrent)) {
                if (!isEstimKindEpEnabled(curr["idestimkind"])) continue;

                bool considera = movimentoCreazioneDettaglioContrattoDaGenerare_2(restimdet, curr) ||
                                 variazioneAnnulloOAResiduoDaGenerare_5(restimdet, curr) ||
                                 movimentoDiTipoVariazione_1(restimdet, curr);
                if (!considera) continue;

                DateTime currDate = mainDate;
                bool scrittureDifferite = false;
                if (estimDet.Columns.Contains("flag")) {
                    scrittureDifferite = (CfgFn.GetNoNullInt32(restimdet["flag"]) & 1) != 0;
                }

                string rifDetail = "Contratto Attivo " + curr["idestimkind"] + ' ' +
                                   curr["yestim"].ToString().Substring(2, 2) + "/" +
                                   curr["nestim"].ToString() + " dett. " + restimdet["rownum"] + "- ";


                DataRow nextRow = getNextRow(restimdet);
                DataRow firstRow = getFirstRow(restimdet);
                DataRow prevRow = getPrevRow(restimdet);
                DataRow lastRow = getLastRow(restimdet);

                DateTime originalDate = (DateTime) (firstRow["start"] == DBNull.Value ? mainDate : firstRow["start"]);
                int yearStartAccertamento = originalDate.Year;

                //Se le scritture sono differite occorre che start sia valorizzato per effettuare le scritture
                if (restimdet["start"] == DBNull.Value && scrittureDifferite) continue;

                var idrelatedCreazione =
                    EP_functions
                        .GetIdForDocument(lastRow); //la creazione è fatta sull'ultimo dettaglio ma con i dati del primo
                var idrelatedCorrente = EP_functions.GetIdForDocument(restimdet);

                if (restimdet["start"] != DBNull.Value) {
                    currDate = (DateTime) restimdet["start"];
                }

                object idregToUse = curr["idreg"];
                if (restimdet["idreg"] != DBNull.Value) idregToUse = restimdet["idreg"];

                object idAccMotiveCredit = getIdAccMotiveDebitCredit(curr["idaccmotivecredit"],
                    curr["idaccmotivecredit_crg"], curr["idaccmotivecredit_datacrg"]);

                idaccRegistry = EP.GetCustomerAccountForRegistry(idAccMotiveCredit, idregToUse);

                if (curr["idreg"] == DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                    ShowMessage("Non è stato configurato il conto di credito opportuno nel contratto " + doc +
                                " dettaglio " + restimdet["detaildescription"], "Errore");
                    return false;
                }

                if (restimdet["idupb"] == DBNull.Value) {
                    ShowMessage("Attenzione, il dettaglio " + restimdet["detaildescription"] +
                                " non ha l'indicazione dell'UPB", "Errore");
                    return false;
                }

                object idaccmotiveOriginal = firstRow["idaccmotive"]; //la causale è quella del dettaglio originale
                if (idaccmotiveOriginal == DBNull.Value) {
                    ShowMessage($"Attenzione, il dettaglio {firstRow["detaildescription"]} non ha la causale!",
                        "Errore");
                    continue;
                }


                //object idepaccCredito = lastRow["idepacc"]; //era restimdet, ma come accertamento prendiamo sempre l'ultimo della catena, retrocompatibilmente
                //object idepaccRicavo = lastRow["idepacc"]; //era restimdet, ma come accertamento prendiamo sempre l'ultimo della catena
                //object idepexp = restimdet["idepexp"];  //come impegno invece va bene il corrente



                object idepaccRicavo = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepaccRicavo = _listaAccertamenti[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepacc"];
                }

                if (idepaccRicavo == DBNull.Value) idepaccRicavo = lastRow["idepacc"];


                object idepaccCredito = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepaccCredito = _listaAccertamenti[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepacc"];
                }

                if (idepaccCredito == DBNull.Value) idepaccCredito = lastRow["idepacc"];


                //object idepexpCorrente = getIdEpExpByIdRelated(idrelatedCorrente,2);





                //Non genera scritture se non c'è accertamento di budget  e la riga è annullata, come data fine usa l'ultima riga
                if (accertamentiAbilitati(curr) && idepaccRicavo == DBNull.Value && lastRow["stop"] != DBNull.Value) {
                    if (((DateTime) lastRow["stop"]).Year == esercizio && yearStartAccertamento == esercizio) continue;
                } //23/6/2020 copio come da c.passivo


                bool generaCreditoARicavo = false;

                //L'unico caso un cui  genera la scrittura credito a ricavo è l'ultima riga ma con i dati della riga originale
                // in tutti gli altri casi fa ricavo a credito dove il credito è movimentato nell'acc. di budget dell'ultima versione
                // Attenzione che la scrittura di creazione deve avere idrelated dell'ultima riga non della riga originale
                //la creazione è fatta sull'ultimo dettaglio ma con i dati del primo (importoRicavoOriginale etc)
                if (nextRow == null && yearStartAccertamento == esercizio)
                    generaCreditoARicavo = true; //normale scrittura di apertura credito


                decimal importoRicavoCorrente = getTotaleImponibile(curr, restimdet);

                var rowToConsider =
                    firstRow; //considera non la riga corrente ma l'ultima riga del primo anno per l'importo scrittura, tutto questo solo sull'ultima riga
                while (getNextRow(rowToConsider) != null) {
                    var nextR = getNextRow(rowToConsider);
                    var startR = (DateTime) nextR["start"];
                    if (startR.Year != esercizio) break;
                    rowToConsider = nextR;
                }

                decimal importoRicavoOriginale = getTotaleImponibile(curr, rowToConsider);

                DataRow[] rEntries = EP.GetAccMotiveDetails(idaccmotiveOriginal);

                if (rEntries.Length != 1) {
                    ShowMessage(
                        $"La causale di ricavo del dettaglio {restimdet["detaildescription"]} non è ben configurata.",
                        "Errore");
                    return false;
                }

                DataRow re = rEntries[0];

                if (importoRicavoCorrente == 0) continue;

                if (generaCreditoARicavo) {
                    DataRow subMain = EP.setCurrDate(originalDate);
                    CopySecurity(curr, subMain);
                    EP.clearSubDetails(subMain);

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        importoRicavoOriginale,
                        re["idacc"], idregToUse, restimdet["idupb"], restimdet["competencystart"],
                        restimdet["competencystop"],
                        restimdet, idaccmotiveOriginal, restimdet["idrevenuepartition"], DBNull.Value, idepaccRicavo, idrelatedCreazione,
                        rifDetail + restimdet["detaildescription"]);

                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                        importoRicavoOriginale, //importocosto + valore_iva - sconto,
                        idaccRegistry, idregToUse, restimdet["idupb"], restimdet["competencystart"],
                        restimdet["competencystop"],
                        //restimdet, idaccmotiveMainCredit, DBNull.Value, DBNull.Value, idepacc, idrelated,
                        restimdet, idaccmotiveOriginal, DBNull.Value, DBNull.Value, idepaccCredito, idrelatedCreazione,
                        descrizioneCredito + " n° " + restimdet["rownum"]);
                }



                //Parte di annullo ma solo per anno iniziale, quindi lavora con la stessa causale di creazione, ma all'opposto
                if (restimdet["stop"] != DBNull.Value && yearStartAccertamento == esercizio) {
                    if (nextRow != null) {
                        //per l'annullamento facciamo la scrittura con importo differenza, però sull'accertamento di budget dell'altro dettaglio
                        importoRicavoCorrente -= getTotaleImponibile(curr, nextRow);
                    }

                    DateTime stop = (DateTime) restimdet["stop"];
                    if (stop.Year == esercizio) {
                        DataRow subMain2 = EP.setCurrDate(stop);
                        CopySecurity(curr, subMain2);
                        EP.clearSubDetails(subMain2);


                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            -importoRicavoCorrente,
                            re["idacc"], idregToUse, restimdet["idupb"], restimdet["competencystart"],
                            restimdet["competencystop"],
                            restimdet, idaccmotiveOriginal, restimdet["idrevenuepartition"], DBNull.Value, idepaccRicavo,
                            idrelatedCreazione,
                            rifDetail + restimdet["detaildescription"]);

                        EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                            -importoRicavoCorrente, //importocosto + valore_iva - sconto,
                            idaccRegistry, idregToUse, restimdet["idupb"], restimdet["competencystart"],
                            restimdet["competencystop"],
                            //restimdet, idaccmotiveMainCredit, DBNull.Value, DBNull.Value, idepacc, idrelated,restimdet["detaildescription"]);
                            restimdet, idaccmotiveOriginal, DBNull.Value, DBNull.Value, idepaccCredito,
                            idrelatedCorrente,
                            descrizioneCredito + " dett. " + restimdet["rownum"]);

                    }
                }

                if (EP.saldo != 0) {
                    ShowMessage($"Si è verificata una squadratura sul dettaglio {restimdet["detaildescription"]}");
                }


            }

            //Esamina ora tutti gli annullamenti
            //idepcontext = "MAN";
            //idacc_registry = EP.GetAccountForSupplier();

            //if (idacc_registry == null || idacc_registry == DBNull.Value) {
            //    ShowMessage("Non è stato configurato il conto di debito/credito opportuno");
            //    return;
            //}
            string idepcontextAnnull = "FATVENVAR";

            filterdetails = QHC.AppAnd(filterMainCurrent, QHC.CmpGe("stop", primoGennaio),
                QHC.CmpLe("stop", trentunoDic));

            //Considera gli annulli, ma solo quelli in anni successivi. Per quelli nello stesso anno l'ha già fatta nel ciclo precedente.
            // il filtro sulla data fine dovrebbe andare bene anche per la nuova gestione
            foreach (DataRow rAnnul in estimDet.Select(filterdetails)) {
                DataRow nextRow = getNextRow(rAnnul);
                DataRow lastRow = getLastRow(rAnnul);
                DataRow firstRow = getFirstRow(rAnnul);
                DataRow prevRow = getPrevRow(rAnnul);


                DateTime currDate = (DateTime) rAnnul["stop"];
                DataRow subMain = EP.setCurrDate(currDate);
                CopySecurity(curr, subMain);
                EP.clearSubDetails(subMain);
                bool generaScrittura = isEstimKindEpEnabled(rAnnul["idestimkind"]); //per i non collegabili, sempre
                if (fatturaARicevereOEmettere(rAnnul)) generaScrittura = true;
                if (nextRow == null && rateo(rAnnul)) generaScrittura = true; //annullo semplice
                bool variazionePerRateo = movimentoDiTipoVariazionePerRateo(rAnnul, curr);
                if (variazionePerRateo) generaScrittura = true;
                if (!generaScrittura) continue;


                DateTime originalDate = (DateTime) (firstRow["start"] == DBNull.Value ? mainDate : firstRow["start"]);
                int yearStartAccertamento = originalDate.Year;

                if (yearStartAccertamento == esercizio) {
                    continue; //nessuna scrittura per dettagli nati quest'anno, l'ha già fatta sopra
                }

                bool scrittureDifferite = false;
                if (estimDet.Columns.Contains("flag")) {
                    scrittureDifferite = (CfgFn.GetNoNullInt32(rAnnul["flag"]) & 1) != 0;
                }

                //Se le scritture sono differite occorre che start sia valorizzato per effettuare le scritture, se questo non c''è allora 
                //  nemmeno l''annullamento deve agire
                if (firstRow["start"] == DBNull.Value && scrittureDifferite) continue;

                var idAccMotiveCredit = getIdAccMotiveDebitCredit(curr["idaccmotivecredit"],
                    curr["idaccmotivecredit_crg"], curr["idaccmotivecredit_datacrg"]);

                //object idepaccCredito = lastRow["idepacc"]; //era restimdet, ma come accertamento prendiamo sempre l'ultimo della catena, retrocompatibilmente
                //object idepaccRicavo = rAnnul["idepacc"]; // accertamento di annullo del  dettaglio annullato, deve essere quello dell'acc. di variazione non dell'originale

                //if (idepaccRicavo == DBNull.Value) {
                //	if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(rAnnul["rownum"]))) {
                //		idepaccRicavo = _listaAccertamenti[CfgFn.GetNoNullInt32(rAnnul["rownum"])]["idepacc"];
                //	}
                //}


                object idepaccRicavo = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(rAnnul["rownum"]))) {
                    idepaccRicavo = _listaAccertamenti[CfgFn.GetNoNullInt32(rAnnul["rownum"])]["idepacc"];
                }

                if (idepaccRicavo == DBNull.Value) idepaccRicavo = rAnnul["idepacc"];


                object idepaccCredito = DBNull.Value;
                if (_listaAccertamenti.ContainsKey(CfgFn.GetNoNullInt32(lastRow["rownum"]))) {
                    idepaccCredito = _listaAccertamenti[CfgFn.GetNoNullInt32(lastRow["rownum"])]["idepacc"];
                }

                if (idepaccCredito == DBNull.Value) idepaccCredito = lastRow["idepacc"];


                var idrelatedCurr = EP_functions.GetIdForDocument(rAnnul);
                var idrelatedLast = EP_functions.GetIdForDocument(lastRow);

                //if (impegniAbilitati(curr) && idepexp == DBNull.Value && idepacc == DBNull.Value &&
                //    rAnnul["stop"] != DBNull.Value) {
                //	if (((DateTime) rAnnul["stop"]).Year == esercizio && currDate.Year == esercizio) continue;
                //}


                var idregToUse = curr["idreg"];
                if (curr["idreg"] == DBNull.Value) {
                    idregToUse = rAnnul["idreg"];
                }

                idaccRegistry = EP.GetCustomerAccountForRegistry(idAccMotiveCredit, idregToUse);
                if (rateoOFatturaARicevere(rAnnul)) {
                    idaccRegistry = rateo(rAnnul) ? _idrateo_attivo : _idaccInvoicetoemit;
                }

                if (curr["idreg"] == DBNull.Value && (idaccRegistry == null || idaccRegistry == DBNull.Value)) {
                    ShowMessage("Non è stato configurato il conto di debito/credito opportuno", "Errore");
                    return false;
                }

                decimal importoAnnullo = getTotaleImponibile(curr, rAnnul);
                decimal importoCredito = importoAnnullo;

                if (nextRow != null) {
                    importoAnnullo -= getTotaleImponibile(curr, nextRow);
                    importoCredito = rateoOFatturaARicevere(rAnnul) ? -importoAnnullo : importoAnnullo;

                }

                //task 15604 al tel. con Cinzia, mi dice che questo importo è pari al totale dettaglio
                if (fatturaARicevereOEmettere(rAnnul) && nextRow == null && importoAnnullo != 0) {
                    //	decimal importoRateo = CfgFn.GetNoNullDecimal(
                    //		Conn.readValue("entrydetail", q.lt("amount", 0) & getFilterDetailForRateo(lastRow, "idepacc", idepaccCredito) & q.eq("idacc", _idaccInvoicetoemit),
                    //			"sum(amount)"));
                    //	if (importoRateo == 0) {
                    //		ShowMessage(
                    //			$"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come fattura da emettere",
                    //			"Errore");
                    //		return false;
                    //		}
                    //	importoAnnullo = -importoRateo;
                    importoCredito = -importoAnnullo;
                }



                if (rateo(rAnnul) && nextRow == null && importoAnnullo != 0) {
                    decimal importoRateo = CfgFn.GetNoNullDecimal(
                        Conn.readValue("entrydetail",
                            q.lt("amount", 0) & getFilterDetailForRateo(lastRow, "idepacc",
                                                  idepaccCredito) //q.eq("idepacc", idepaccCredito) 
                                              & q.eq("idacc", _idrateo_attivo),
                            "sum(amount)"));
                    if (importoRateo == 0) {
                        ShowMessage(
                            $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come rateo",
                            "Errore");
                        return false;
                    }

                    importoAnnullo = -importoRateo;
                    importoCredito = -importoAnnullo;
                }

                if (variazionePerRateo) {
                    decimal importoRateo = CfgFn.GetNoNullDecimal(
                        Conn.readValue("entrydetail",
                            q.lt("amount", 0) & getFilterDetailForRateo(lastRow, "idepacc",
                                                  idepaccCredito) //  q.eq("idepacc", idepaccCredito) 
                                              & q.eq("idacc", _idrateo_attivo),
                            "sum(amount)"));
                    if (importoRateo == 0) {
                        ShowMessage(
                            $"E' necessaria la presenza delle scritture di apertura per il dettaglio {rAnnul["detaildescription"]} perchè marcato come rateo",
                            "Errore");
                        return false;
                    }

                    importoAnnullo = -importoRateo;
                    importoCredito = -importoAnnullo;
                }

                //if (rAnnul["annulmentamount"] != DBNull.Value) {
                //	importoAnnullo = CfgFn.GetNoNullDecimal(rAnnul["annulmentamount"]);
                //}

                object idaccmotiveAnnul = rAnnul["idaccmotiveannulment"];
                if (idaccmotiveAnnul == DBNull.Value) {
                    if (yestim < esercizio) {
                        ShowMessage(
                            $"Attenzione, il dettaglio {rAnnul["detaildescription"]} non ha la causale di annullo!",
                            "Errore");
                        return false;
                    }

                    continue;
                }


                //decimal quotaIncassata = quotaIncassataDettaglioContrattoAttivo(rAnnul);



                DataRow[] rEntriesAnnull = EP.GetAccMotiveDetails(idaccmotiveAnnul);
                if (rEntriesAnnull.Length != 1) {
                    ShowMessage(
                        $"La causale di annullo del dettaglio {rAnnul["detaildescription"]} non è ben configurata.",
                        "Errore");
                    return false;
                }

                object idContoAnnullo = rEntriesAnnull[0]["idacc"];

                string rifDetail = "Contratto Attivo " + curr["idestimkind"] + ' ' +
                                   curr["yestim"].ToString().Substring(2, 2) + "/" +
                                   curr["nestim"].ToString() + "dett. " + rAnnul["rownum"] + "- ";

                if (EP.isRicavo(idContoAnnullo)) {
                    //Rimosso messaggio e ripristinato comportamento precedente a seguito di task 15300
                    //ShowMessage( $"La causale di annullo del dettaglio {rAnnul["detaildescription"]} non non può essere di ricavo.","Errore");
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextAnnull,
                        importoAnnullo,
                        idContoAnnullo,
                        idregToUse, rAnnul["idupb"],
                        rAnnul["competencystart"], rAnnul["competencystop"],
                        rAnnul, idaccmotiveAnnul, rAnnul["idrevenuepartition"], DBNull.Value, idepaccRicavo, idrelatedCurr,
                        rifDetail + rAnnul["detaildescription"]);
                }
                else {
                    var idepexp = getIdEpExpByIdRelated(idrelatedCurr, 2);
                    EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextAnnull,
                        importoAnnullo,
                        idContoAnnullo,
                        idregToUse, rAnnul["idupb"],
                        rAnnul["competencystart"], rAnnul["competencystop"],
                        rAnnul, idaccmotiveAnnul, DBNull.Value, idepexp, DBNull.Value, idrelatedCurr,
                        rifDetail + rAnnul["detaildescription"]);
                }


                //Scrittura sul credito, ma sull'accertamento dell'ultimo dettaglio
                EP.EffettuaScritturaSuddivisaImpegnoBudget(idepcontextAnnull,
                    importoCredito,
                    idaccRegistry,
                    idregToUse, rAnnul["idupb"],
                    rAnnul["competencystart"], rAnnul["competencystop"],
                    //rAnnul, idaccmotiveMainCredit, DBNull.Value, DBNull.Value, idepacc, idrelated, rAnnul["detaildescription"]);
                    rAnnul, idaccmotiveAnnul, DBNull.Value, DBNull.Value, idepaccCredito, idrelatedLast,
                    descrizioneCredito + " dett. " + rAnnul["rownum"]);

                if (EP.saldo != 0) {
                    ShowMessage("Si è verificata una squadratura sul dettaglio " + rAnnul["detaildescription"] +
                                " (annullamento)");
                }
            }

            EP.RemoveEmptyDetails();
            if (EP.D.Tables["entry"].Rows.Count == 0) {
                if (!silent) ShowMessage("Nessuna scrittura da generare.", "Avviso", false);
                return false;
            }

            return true;

        }

        public ProcedureMessageCollection EPRules;

        /// <summary>
        /// Salva le scritture, per i test valorizza EPRules
        /// </summary>
        /// <returns></returns>
        bool salvaScritture() {

            MetaData metaEntry = Disp.Get("entry");
            PostData post = metaEntry.Get_PostData();

            if (invokedByInnerPosting) {
                //post.InitClass(EP.D, Conn);
                //post.innerPosting = true;
                //post.addMessagesToIgnore(postingClass.hashMessagesToIgnore());
                //var listaMsg = post.DO_POST_SERVICE();
                //if (listaMsg.Count>0) {
                //    postingClass.mergeMessages(listaMsg);
                //    return listaMsg.CanIgnore;
                //}
                return postingClass.saveData(EP.D, post);
            }
            else {
                post.initClass(EP.D, Conn);
                var res = false;
                if (silentPosting) {
                    EPRules = post.DO_POST_SERVICE();
                    res = EPRules.Count == 0;
                }
                else {
                    res = post.DO_POST();
                }

                if (res) {
                    mostraEtichette();
                    return true;
                }
                else {
                    if (!silent) {
                        EP.viewDetails(meta);
                    }

                    return false;
                }
            }

            ///TODO:: inserire uso epposting


        }
    }

    /// <summary>
    /// Summary description for Class1.
    /// </summary>
    public class EP_functions {
        DataAccess Conn;
        DataRow rConfig;
        MetaData MetaEntry;
        MetaData MetaEntryDetail;
        public bool attivo;
        DataTable AccMotiveDetail;
        DataTable Account;
        DataTable AccountKind;
        public DataSet D;
        int esercizio;

        DataTable epcontext;

        //bool SottraiRatei;
        MetaDataDispatcher Disp;
        private ShowMessageDelegate showMessage;

        void ShowMessage(string error, string title = null, bool unrecoverable = true) {
            if (title == null) title = unrecoverable ? "Errore" : "Avviso";
            MetaFactory.factory.getSingleton<IMessageShower>().Show(error, title);
        }

        QueryHelper QHS;
        CQueryHelper QHC;

        public EP_functions(MetaDataDispatcher disp) {
            this.Disp = disp;
            this.Conn = disp.Conn;
            QHC = new CQueryHelper();
            QHS = Conn.GetQueryHelper();

            showMessage = ShowMessage;

            attivo = false;
            esercizio = CfgFn.GetNoNullInt32(Conn.GetSys("esercizio"));
            string filter = QHS.CmpEq("ayear", Conn.GetSys("esercizio"));
            DataTable t = Conn.RUN_SELECT("config", "*", null, filter, null, null, true);

            AccMotiveDetail = Conn.CreateTableByName("accmotivedetail", "*");
            Account = Conn.CreateTableByName("account", "*");
            epcontext = Conn.RUN_SELECT("epcontext", "*", null, null, null, true);
            AccountKind = Conn.RUN_SELECT("accountkind", "*", null, null, null, true);
            MetaEntry = disp.Get("entry");
            MetaEntryDetail = disp.Get("entrydetail");
            D = new DataSet();

            if (t == null) return;
            if (t.Rows.Count == 0) {
                //ShowMessage(
                //    "Manca nella configurazione l'indicazione dei conti di debito credito verso clienti e fornitori.",
                //    "Errore");
                return;
            }

            //if (disp.GetUsr("eco_entry") != null && disp.GetUsr("eco_entry").ToString().ToUpper() != "'S'") return;
            rConfig = t.Rows[0];

            if (rConfig["idacc_customer"] == DBNull.Value) return;
            if (rConfig["idacc_supplier"] == DBNull.Value) return;
            attivo = true;
            //SottraiRatei=true;


        }

        public delegate void ShowMessageDelegate(string error, string title = null, bool unrecoverable = true);

        public void viewDetails(MetaData mParent) {
            if (D.Tables["entry"].Rows.Count == 0) return;
            var myMain = D.Tables["entry"].Rows[0];
            if (myMain.RowState == DataRowState.Deleted || myMain.RowState == DataRowState.Detached) return;

            MetaData toMetaEntry = mParent.Dispatcher.Get("entry");
            MetaData toMetaEntryDetail = mParent.Dispatcher.Get("entrydetail");
            if (toMetaEntry == null)
                return;
            Form F = null;
            if (mParent.linkedForm != null) F = mParent.linkedForm.ParentForm;
            showMessage(
                "Le scritture non sono state salvate. Verranno ora mostrate per consentire di esaminarle e correggere la configurazione.",
                "Avviso");
            var result = toMetaEntry.Edit(F, "default", false);
            var listtype = toMetaEntry.DefaultListType;

            var d = toMetaEntry.DS;

            var entry = d.Tables["entry"];
            var entrydetail = d.Tables["entrydetail"];

            toMetaEntry.SetDefaults(entry);
            toMetaEntryDetail.SetDefaults(entrydetail);

            toMetaEntry.CanSave = false;
            toMetaEntry.CanInsert = false;
            toMetaEntry.CanCancel = false;
            toMetaEntry.SearchEnabled = false;

            toMetaEntry.DoMainCommand("maininsert");
            var main = entry.Rows[0];

            foreach (var field in new[] {
                "adate", "description", "identrykind", "doc", "docdate", "locked", "idrelated",
                "idsor01", "idsor02", "idsor03", "idsor04", "idsor05", "official"
            }) {
                main[field] = myMain[field];
            }

            foreach (var myChild in D.Tables["entrydetail"].Select()) {
                if (myChild.RowState == DataRowState.Deleted || myChild.RowState == DataRowState.Detached) continue;
                if (toMetaEntry.formController.isClosing) return;
                var rchild = toMetaEntryDetail.Get_New_Row(main, entrydetail);
                foreach (var childField in new[] {
                    "amount", "idacc", "idreg", "idupb", "idaccmotive",
                    "competencystart", "competencystop", "idsor1", "idsor2", "idsor3", "importcode", "description",
                    "autogenerated",
                    "idepexp", "idepacc"
                }) {
                    if (!D.Tables["entrydetail"].Columns.Contains(childField))
                        continue;
                    if (!entrydetail.Columns.Contains(childField))
                        continue;
                    rchild[childField] = myChild[childField];
                }
            }

            toMetaEntry.FreshForm(true);
        }

        public static string composeObjects(object[] o) {
            if (o == null) return null;
            if (o.Length == 0) return null;
            var res = "";
            foreach (var oo in o) {
                if (res != "") res += "§";
                res += oo.ToString();
            }

            return res;
        }

        public bool DeleteDetailByIdRelated(string idrelated, ep_poster posting) {

            string filterEntry = null;
            foreach (DataRow rEntryDetail in D.Tables["entrydetail"].Select(QHC.CmpEq("idrelated", idrelated))) {
                filterEntry = QHC.AppAnd(QHC.CmpEq("yentry", rEntryDetail["yentry", DataRowVersion.Original]),
                    QHC.CmpEq("nentry", rEntryDetail["nentry", DataRowVersion.Original])
                );
                rEntryDetail.Delete();
            }

            if (filterEntry != null) {
                if (D.Tables["entrydetail"].Select(filterEntry).Length == 0) {
                    DataRow rMain = D.Tables["entry"].Select(filterEntry)._First();
                    if (rMain != null) rMain.Delete();
                }
            }

            if (posting != null) {
                MetaData MetaEntry = Disp.Get("entry");
                PostData Post = MetaEntry.Get_PostData();
                return posting.saveData(D, Post);
            }
            else {
                MetaData MetaEntry = Disp.Get("entry");
                PostData Post = MetaEntry.Get_PostData();

                Post.InitClass(D, Conn);
                if (!Post.DO_POST()) {
                    showMessage("Errore durante la cancellazione dei dettagli scrittura in PD");
                    return false;
                }

            }

            return true;
        }

        public bool DeleteAll(ep_poster posting) {
            foreach (DataRow rEntry in D.Tables["entry"].Rows) {
                rEntry.Delete();
            }

            foreach (DataRow rEntryDetail in D.Tables["entrydetail"].Rows) {
                rEntryDetail.Delete();
            }

            if (posting != null) {
                MetaData MetaEntry = Disp.Get("entry");
                PostData Post = MetaEntry.Get_PostData();
                return posting.saveData(D, Post);
            }
            else {
                MetaData MetaEntry = Disp.Get("entry");
                PostData Post = MetaEntry.Get_PostData();

                Post.InitClass(D, Conn);
                if (!Post.DO_POST()) {
                    showMessage("Errore durante la cancellazione delle scritture in PD");
                    return false;
                }
            }

            return true;
        }


        static string[] DecomposeObjects(string S) {
            if (S == null) return null;
            return S.Length == 0 ? null : S.Split('§');
        }


        static object[] decodeID(string idrelated) {
            string[] arr1 = DecomposeObjects(idrelated);
            if (arr1 == null) return null;
            object[] obj1 = new object[arr1.Length];
            string pref = arr1[0];
            if (pref == "grant" && arr1.Length == 4) {
                obj1[0] = "grantload";
                obj1[1] = Convert.ToInt32(arr1[1]); //yload
                obj1[2] = arr1[2]; //kind
                obj1[3] = arr1[3]; //idgrantload
            }

            if (pref == "upbcommessa") {
                obj1[0] = "upbcommessa";
                obj1[1] = arr1[1]; //idupb
                obj1[2] = Convert.ToInt32(arr1[2]); //ayear
            }

            if (pref == "assetload" && arr1.Length == 2) {
                obj1[0] = "assetload";
                obj1[1] = Convert.ToInt32(arr1[1]); //idassetload
            }

            if (pref == "assetload" && arr1.Length == 3) {
                obj1[0] = "assetacquire";
                obj1[1] = Convert.ToInt32(arr1[2]); //nassetacquire
            }

            if (pref == "assetunload" && arr1.Length == 2) {
                obj1[0] = "assetunload";
                obj1[1] = arr1[1];
            }

            if (pref == "assetunload" && arr1.Length == 3) {
                obj1[0] = "assetamortization";
                obj1[1] = arr1[2]; //namortization
            }

            if (pref == "provision" && arr1.Length == 2) {
                obj1[0] = "provision";
                obj1[1] = arr1[1];
            }

            if (pref == "provision" && arr1.Length == 3) {
                obj1[0] = "provision";
                obj1[1] = arr1[1]; //per ora punta comunque a provision, domani si vedrà
            }

            //if (pref == "assetload" && arr1.Length == 4) {
            //    obj1[0] = "assetload";
            //    obj1[1] = Convert.ToInt32(arr1[1]);     //idassetloadkind
            //    obj1[2] = arr1[2];     //yassetload
            //    obj1[3] = arr1[3];     //nassetload
            //}
            if (pref == "inv" && arr1.Length == 4) {
                obj1[0] = "invoice";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
            }

            if (pref == "invdetail" || (pref == "inv" && arr1.Length == 5)) {
                obj1[0] = "invoicedetail";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
                obj1[4] = Convert.ToInt32(arr1[4]);
            }

            if (pref == "ivapay") {
                obj1[0] = "ivapay";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "mainivapay") {
                obj1[0] = "mainivapay";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "paytrans") {
                obj1[0] = "paymenttransmission";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "protrans") {
                obj1[0] = "proceedstransmission";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "cascon") {
                obj1[0] = "casualcontract";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "profservice") {
                obj1[0] = "profservice";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "payroll") {
                obj1[0] = "payroll";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
            }

            if (pref == "wageadd") {
                obj1[0] = "wageaddition";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "itineration") {
                obj1[0] = "itineration";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "pettycashoperation") {
                obj1[0] = "pettycashoperation";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
            }

            if (pref == "estim" && arr1.Length == 4) {
                obj1[0] = "estimate";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
            }

            if (pref == "estimdet" || (pref == "estim" && arr1.Length == 5)) {
                obj1[0] = "estimatedetail";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
                obj1[4] = Convert.ToInt32(arr1[4]);
            }

            if ((pref == "mandatedetail" || pref == "man") && arr1.Length == 4) {
                obj1[0] = "mandate";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
            }

            if (pref == "mandatedetail" || (pref == "man" && arr1.Length == 5)) {
                obj1[0] = "mandatedetail";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = Convert.ToInt32(arr1[3]);
                obj1[4] = Convert.ToInt32(arr1[4]);
            }

            if (pref == "entry") {
                obj1[0] = "entry";
                obj1[1] = arr1[1];
                obj1[2] = Convert.ToInt32(arr1[2]);
            }


            if (pref == "csa_import") {
                obj1[0] = "csa_import";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
            }

            if (pref == "import_flow") {
                obj1[0] = "import_flow";
                obj1[1] = arr1[1];
            }

            if (pref == "taxpay") {
                obj1[0] = "taxpay";
                obj1[1] = Convert.ToInt32(arr1[1]);
                obj1[2] = Convert.ToInt32(arr1[2]);
                obj1[3] = arr1[3];
            }

            if (pref == "bankimport") {
                obj1[0] = "bankimport";
                obj1[1] = Convert.ToInt32(arr1[1]);
            }

            //if (pref == "storeunloaddetail"){
            //    obj1[0] = "storeunloaddetail";
            //    obj1[1] = arr1[1];
            //    obj1[2] = Convert.ToInt32(arr1[2]);
            //}
            return obj1;
        }

        public static string GetIDForDocumentChild(DataRow R, string suffix) {
            return GetIdForDocument(R) + "§" + suffix;
        }

        public static string GetIdForDocumentCorrige(DataRow R) {
            return GetIdForDocument(R) + "§crg";
        }

        /// <summary>
        /// Gives an external id for a DataRow. It's necessary R has been SAVED, 
        /// i.e R.DataRowState != Added
        /// </summary>
        /// <param name="R"></param>
        /// <returns>idrelated to put into 'entry' table</returns>
        public static string GetIdForDocument(DataRow R) {
            if (R == null) return null;
            DataRowVersion toConsider = DataRowVersion.Current;
            if (R.RowState == DataRowState.Deleted) toConsider = DataRowVersion.Original;
            string table = R.Table.TableName.ToLower();
            switch (table) {
                case "invoice":
                    return composeObjects(
                        new object[] {
                            "inv",
                            R["idinvkind", toConsider],
                            R["yinv", toConsider],
                            R["ninv", toConsider]
                        });
                case "invoicedetail":
                    return composeObjects(
                        new[] {
                            "inv",
                            R["idinvkind", toConsider],
                            R["yinv", toConsider],
                            R["ninv", toConsider],
                            R["rownum", toConsider]
                        });
                case "grantload":
                    return composeObjects(
                        new object[] {
                            "grant",
                            R["yload", toConsider],
                            R["kind", toConsider],
                            R["idgrantload", toConsider]

                        });
                case "assetgrant":
                    return composeObjects(
                        new object[] {
                            "grant",
                            R["ygrant", toConsider],
                            "D",
                            R["idasset", toConsider],
                            R["idpiece", toConsider]
                        });
                case "assetgrantdetail":
                    return composeObjects(
                        new object[] {
                            "grant",
                            R["ydetail", toConsider],
                            "U",
                            R["idasset", toConsider],
                            R["idpiece", toConsider]
                        });
                case "assetacquire":
                case "assetacquireview":
                    return composeObjects(
                        new object[] {
                            "assetload",
                            R["idassetload", toConsider],
                            R["nassetacquire", toConsider]
                        });
                case "ivapay":
                    return composeObjects(
                        new[] {
                            "ivapay",
                            R["yivapay", toConsider],
                            R["nivapay", toConsider]
                        });
                case "mainivapay":
                    return composeObjects(
                        new[] {
                            "mainivapay",
                            R["ymainivapay", toConsider],
                            R["nmainivapay", toConsider]
                        });
                case "paymenttransmission":
                    return composeObjects(
                        new object[] {
                            "paytrans",
                            R["ypaymenttransmission", toConsider],
                            R["npaymenttransmission", toConsider]
                        });
                case "proceedstransmission":
                    return composeObjects(
                        new[] {
                            "protrans",
                            R["yproceedstransmission", toConsider],
                            R["nproceedstransmission", toConsider]
                        });
                case "casualcontract":
                    return composeObjects(
                        new[] {
                            "cascon",
                            R["ycon", toConsider],
                            R["ncon", toConsider]
                        });
                case "casualcontracttaxbracket":
                    return composeObjects(
                        new[] {
                            "cascon",
                            R["ycon", toConsider],
                            R["ncon", toConsider],
                            "RITEN",
                            R["taxcode", toConsider]
                        });
                case "casualcontractrefund":
                    return composeObjects(
                        new[] {
                            "cascon",
                            R["ycon", toConsider],
                            R["ncon", toConsider],
                            "SPESA",
                            R["idlinkedrefund", toConsider]
                        });
                case "payroll":
                    return composeObjects(
                        new[] {
                            "payroll",
                            R["idpayroll", toConsider],
                            R["fiscalyear", toConsider],
                            R["npayroll", toConsider]
                        });
                case "wageaddition":
                    return composeObjects(
                        new[] {
                            "wageadd",
                            R["ycon", toConsider],
                            R["ncon", toConsider]
                        });
                case "itineration":
                    return composeObjects(
                        new[] {
                            "itineration",
                            R["yitineration", toConsider],
                            R["nitineration", toConsider]
                        });
                case "pettycashoperation":
                    return composeObjects(
                        new[] {
                            "pettycashoperation",
                            R["idpettycash", toConsider],
                            R["yoperation", toConsider],
                            R["noperation", toConsider]
                        });
                case "estimate":
                    return composeObjects(
                        new[] {
                            "estim",
                            R["idestimkind", toConsider],
                            R["yestim", toConsider],
                            R["nestim", toConsider]
                        });
                case "estimatedetail":
                    return composeObjects(
                        new[] {
                            "estim",
                            R["idestimkind", toConsider],
                            R["yestim", toConsider],
                            R["nestim", toConsider],
                            R["rownum", toConsider]
                        });
                case "mandate":
                    return composeObjects(
                        new[] {
                            "man",
                            R["idmankind", toConsider],
                            R["yman", toConsider],
                            R["nman", toConsider]
                        });
                case "mandatedetail":
                    return composeObjects(
                        new[] {
                            "man",
                            R["idmankind", toConsider],
                            R["yman", toConsider],
                            R["nman", toConsider],
                            R["rownum", toConsider]
                        });
                case "entry":
                    return composeObjects(
                        new[] {
                            "entry",
                            R["yentry", toConsider],
                            R["nentry", toConsider]
                        });
                case "assetunload":
                    return composeObjects(
                        new[] {
                            "assetunload",
                            R["idassetunload", toConsider]
                        });
                case "assetamortization":
                case "assetamortizationunloadview":
                    return composeObjects(
                        new[] {
                            "assetunload",
                            R["idassetunload", toConsider],
                            R["namortization", toConsider]

                        });
                case "assetload":
                    return composeObjects(
                        new[] {
                            "assetload",
                            R["idassetload", toConsider]
                        });
                case "csa_import":
                    return composeObjects(
                        new[] {
                            "csa_import",
                            R["yimport", toConsider],
                            R["nimport", toConsider]
                        });
                case "csa_import.debit":
                    return composeObjects(
                        new[] {
                            "csa_import_debit",
                            R["yimport", toConsider],
                            R["nimport", toConsider]
                        });
                case "storeunloaddetail":
                    return composeObjects(
                        new[] {
                            "storeunloaddetail",
                            R["idstoreunload", toConsider],
                            R["idstoreunloaddetail", toConsider]
                        });
                case "profservice":
                    return composeObjects(
                        new[] {
                            "profservice",
                            R["ycon", toConsider],
                            R["ncon", toConsider]
                        });
                case "taxpay":
                    return composeObjects(
                        new[] {
                            "taxpay",
                            R["ytaxpay", toConsider],
                            R["ntaxpay", toConsider],
                            R["taxcode", toConsider]
                        });
                case "profservicetax":
                    return composeObjects(
                        new[] {
                            "profservice",
                            R["ycon", toConsider],
                            R["ncon", toConsider],
                            "RITEN",
                            R["taxcode", toConsider]
                        });
                case "import_flow":
                case "import_flowview":
                case "import_flow_coge":
                    return composeObjects(
                        new[] {
                            "import_flow",
                            R["idimportflow", toConsider]
                        });
                case "bankimport":
                    return composeObjects(
                        new[] {
                            "bankimport",
                            R["idbankimport", toConsider]
                        });
                case "provision":
                    return composeObjects(new[] {"provision", R["idprovision"]});
                case "provisiondetail":
                    return composeObjects(new[] {"provision", R["idprovision"], R["rownum"]});
                case "upbcommessa":
                    return composeObjects(new[] {"upbcommessa", R["idupb"], R["ayear"]});
            }

            return null;
        }

        //La funzione, dato un idrelated fornisce un filtro sui potenziali impegni di budget da selezionare
        public string GetFilterForEpexp(MetaData Meta, string idrelated) {
            int nphase = 2; // Impegno
            string filter = QHS.AppAnd(QHS.CmpEq("nphase", nphase), QHS.CmpEq("idrelated", idrelated));

            object[] obj1 = decodeID(idrelated);
            if (obj1 == null) return null;
            if (obj1[0] == null) return null;
            string filterIx = "";
            string tablename = obj1[0].ToString();
            if (tablename == "invoice") {
                string newTable;
                string filterInv = GetFilterForDocument(idrelated, out newTable);
                //restituisce il filtro su indinvkind, yinv e ninv.
                // Fattura collegata a parcella professionale:resituisce gli Ix di budget della parcella.
                DataTable ProfService = Meta.Conn.RUN_SELECT("profservice", "idepexp", null, filterInv, null, true);
                if (ProfService != null && ProfService.Rows.Count > 0) {
                    string listaImpegniBudgetProfservice = QHS.DistinctVal(ProfService.Select(), "idepexp");
                    filterIx = QHS.FieldInList("idepexp", listaImpegniBudgetProfservice);
                    return filterIx;
                }

                DataTable InvoiceDet = Meta.Conn.RUN_SELECT("invoicedetail", "idepexp", null, filterInv, null, true);
                string listaImpegniBudget = QHS.DistinctVal(InvoiceDet.Select(), "idepexp");
                filterIx = QHS.FieldInList("idepexp", listaImpegniBudget);
                return filterIx;
            }

            return filter;
        }

        public string GetFilterForEpAcc(MetaData Meta, string idrelated) {
            int nphase = 2; // Accertamento
            string filter = QHS.AppAnd(QHS.CmpEq("nphase", nphase), QHS.CmpEq("idrelated", idrelated));

            object[] obj1 = decodeID(idrelated);
            if (obj1 == null) return null;
            if (obj1[0] == null) return null;
            string filterInv = "";
            string tablename = obj1[0].ToString();
            if (tablename == "invoice") {
                filterInv = GetFilterForDocument(idrelated, out filterInv);
                //restituisce il filtro su indinvkind, yinv e ninv.
                DataTable InvoiceDet = Meta.Conn.RUN_SELECT("invoicedetail", "idepacc", null, filterInv, null, true);
                string listaAccertamentiBudget = QHS.DistinctVal(InvoiceDet.Select(), "idepacc");
                filterInv = QHS.FieldInList("idepacc", listaAccertamentiBudget);
                return filterInv;
            }

            return filter;
        }


        string CreateFilter(QueryHelper Q, object[] O, params string[] field) {
            string filter = "";
            for (int i = 0; i < field.Length; i++) {
                string fieldname = field[i];
                filter = Q.AppAnd(filter, Q.CmpEq(fieldname, O[i + 1]));
            }

            return filter;
        }

        public string GetFilterForDocument(string idrelated, out string tablename) {
            tablename = null;
            if (idrelated == null) return null;
            object[] obj1 = decodeID(idrelated);
            if (obj1 == null) return null;
            if (obj1[0] == null) return null;
            tablename = obj1[0].ToString();
            string myTable = tablename;
            if (tablename == "csa_import.debit") {
                tablename = "csa_import";
            }

            switch (myTable) {
                case "grantload":
                    return CreateFilter(QHS, obj1, "yload", "kind", "idgrantload");
                case "assetload":
                    return CreateFilter(QHS, obj1, "idassetload");
                case "assetacquire":
                    return CreateFilter(QHS, obj1, "nassetacquire");
                case "provision":
                    return CreateFilter(QHS, obj1, "idprovision");
                case "provisiondetail":
                    return CreateFilter(QHS, obj1, "idprovision", "ydetail", "rownum");
                case "upbcommessa":
                    return CreateFilter(QHS, obj1, "idupb", "ayear");
                case "assetunload":
                    return CreateFilter(QHS, obj1, "idassetunload");
                case "assetamortization":
                case "assetamortizationunloadview":
                    return CreateFilter(QHS, obj1, "namortization");
                case "assetgrant":
                    return CreateFilter(QHS, obj1, "ygrant", "idasset", "idpiece");
                case "assetgrantdetail":
                    return CreateFilter(QHS, obj1, "ydetail", "idasset", "idpiece");
                case "invoice":
                    return CreateFilter(QHS, obj1, "idinvkind", "yinv", "ninv");
                case "invoicedetail":
                    return CreateFilter(QHS, obj1, "idinvkind", "yinv", "ninv", "rownum");
                case "ivapay":
                    return CreateFilter(QHS, obj1, "yivapay", "nivapay");
                case "mainivapay":
                    return CreateFilter(QHS, obj1, "ymainivapay", "nmainivapay");
                case "paymenttransmission":
                    return CreateFilter(QHS, obj1, "ypaymenttransmission", "npaymenttransmission");
                case "proceedstransmission":
                    return CreateFilter(QHS, obj1, "yproceedstransmission", "nproceedstransmission");
                case "casualcontract":
                    return CreateFilter(QHS, obj1, "ycon", "ncon");
                case "payroll":
                    return CreateFilter(QHS, obj1, "idpayroll", "fiscalyear", "npayroll");
                case "wageaddition":
                    return CreateFilter(QHS, obj1, "ycon", "ncon");
                case "itineration":
                    return CreateFilter(QHS, obj1, "yitineration", "nitineration");
                case "pettycashoperation":
                    return CreateFilter(QHS, obj1, "idpettycash", "yoperation", "noperation");
                case "estimate":
                    return CreateFilter(QHS, obj1, "idestimkind", "yestim", "nestim");
                case "estimatedetail":
                    return CreateFilter(QHS, obj1, "idestimkind", "yestim", "nestim", "rownum");
                case "mandate":
                    return CreateFilter(QHS, obj1, "idmankind", "yman", "nman");
                case "mandatedetail":
                    return CreateFilter(QHS, obj1, "idmankind", "yman", "nman", "rownum");
                case "entry":
                    return CreateFilter(QHS, obj1, "yentry", "nentry");
                case "csa_import":
                    return CreateFilter(QHS, obj1, "yimport", "nimport");
                case "csa_import.debit":
                    return CreateFilter(QHS, obj1, "yimport", "nimport");
                case "storeunloaddetail":
                    return CreateFilter(QHS, obj1, "idstoreunload", "idstoreunloaddetail");
                case "import_flow":
                    return CreateFilter(QHS, obj1, "idimportflow");
                case "taxpay":
                    return CreateFilter(QHS, obj1, "ytaxpay", "ntaxpay", "taxcode");
                case "bankimport":
                    return CreateFilter(QHS, obj1, "idbankimport");
            }

            return null;
        }

        public void EditRelatedDocument(MetaData meta, DataRow R) {
            try {
                if (R == null) return;
                string idrelated = R["idrelated"].ToString();
                string table;
                string filter = GetFilterForDocument(idrelated, out table);
                if (filter == null) return;
                MetaData Doc = meta.Dispatcher.Get(table);
                Doc.ContextFilter = filter;
                Form F = null;
                if (meta.linkedForm != null) F = meta.linkedForm.ParentForm;
                bool result = Doc.Edit(F, "default", false);
                string listtype = Doc.DefaultListType;
                DataRow RR = Doc.SelectOne(listtype, filter, null, null);
                if (RR != null) Doc.SelectRow(RR, listtype);
            }
            catch {
            }
        }


        public static object importCostPartitionDetail(MetaData Meta) {
            OpenFileDialog _op = new OpenFileDialog();
            IOpenFileDialog op = MetaFactory.factory.create<IOpenFileDialog>().init(_op);
            DialogResult dr = op.ShowDialog();
            if (dr != DialogResult.OK) {
                return null;
            }

            string fileName = op.FileName;

            DataTable T = new DataTable();
            //Aggiungere a T le colonne del foglio excel
            T.Columns.Add(new DataColumn("quota", typeof(decimal)));
            T.Columns.Add(new DataColumn("codice1", typeof(string)));
            T.Columns.Add(new DataColumn("codice2", typeof(string)));
            T.Columns.Add(new DataColumn("codice3", typeof(string)));


            ExcelImport x = new ExcelImport();
            x.ImportTable(fileName, T);

            if (T.Rows.Count == 0) return null;

            frmAskCostPartitionDetail f = new frmAskCostPartitionDetail();
            MetaFactory.factory.getSingleton<IFormCreationListener>().create(f, null);
            DialogResult dr2 = f.ShowDialog();
            if (dr != DialogResult.OK) {
                return null;
            }

            vistaCostPartition ds = new vistaCostPartition();

            MetaData metaCost = Meta.Dispatcher.Get("costpartition");
            metaCost.SetDefaults(ds.costpartition);

            MetaData metaCostDetail = Meta.Dispatcher.Get("costpartitiondetail");
            metaCostDetail.SetDefaults(ds.costpartitiondetail);
            QueryHelper QHS = Meta.Conn.GetQueryHelper();

            //DataTable cfg = meta.Conn.RUN_SELECT("config", "ayear,idsor1,idsor2,idsor3", null, QHS.CmpEq("ayear", meta.GetSys("esercizio")), null, false);
            object idsorkind1 = Meta.GetSys("idsortingkind1");
            object idsorkind2 = Meta.GetSys("idsortingkind2");
            object idsorkind3 = Meta.GetSys("idsortingkind3");


            DataRow main = metaCost.Get_New_Row(null, ds.costpartition);
            main["costpartitioncode"] = f.txtCodice.Text;
            main["title"] = f.txtDenominazione.Text;
            string error;
            string field;
            if (!metaCost.IsValid(main, out error, out field)) {
                MetaFactory.factory.getSingleton<IMessageShower>().Show(
                                            error, "Errore");
                return null;
            }
            string fieldToUse = "rate";
            if (f.rdbCosti.Checked) {
                fieldToUse = "amount";
                main["kind"] = "C";
            }
            else {
                main["kind"] = "P";
            }

            if (f.chkAttivo.Checked) {
                main["active"] = "S";
            }
            else {
                main["active"] = "N";
            }

            foreach (DataRow r in T.Select()) {
                DataRow det = metaCostDetail.Get_New_Row(main, ds.costpartitiondetail);
                det[fieldToUse] = r["quota"];
                object code1 = r["codice1"];
                object code2 = r["codice2"];
                object code3 = r["codice3"];

                object idsor1 = DBNull.Value;
                object idsor2 = DBNull.Value;
                object idsor3 = DBNull.Value;

                if (idsorkind1 != DBNull.Value && code1.ToString() != "") {
                    idsor1 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind1), QHS.CmpEq("sortcode", code1.ToString().Trim())),
                        "idsor");
                    if (idsor1 == null) {
                        idsor1 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code1 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind1"), "Errore");
                    }
                }

                if (idsorkind2 != DBNull.Value && code2.ToString() != "") {
                    idsor2 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind2), QHS.CmpEq("sortcode", code2.ToString().Trim())),
                        "idsor");
                    if (idsor2 == null) {
                        idsor2 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code2 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind2"), "Errore");
                    }
                }

                if (idsorkind3 != DBNull.Value && code3.ToString() != "") {
                    idsor3 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind3), QHS.CmpEq("sortcode", code3.ToString().Trim())),
                        "idsor");
                    if (idsor3 == null) {
                        idsor3 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code3 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind3"), "Errore");
                    }
                }

                det["idsor1"] = idsor1;
                det["idsor2"] = idsor2;
                det["idsor3"] = idsor3;
            }


            PostData Post = Meta.Get_PostData();

            Post.InitClass(ds, Meta.Conn);
            if (!Post.DO_POST()) {
                MetaFactory.factory.getSingleton<IMessageShower>()
                    .Show("Errore durante il salvataggio del piano di ripartizione");
                return null;
            }

            object idcostpartition = main["idcostpartition"];
            MetaData ToMeta = Meta.Dispatcher.Get("costpartition");
            string checkfilter = QHS.CmpEq("idcostpartition", idcostpartition);
            ToMeta.ContextFilter = checkfilter;
            Form F = null;
            if (Meta.linkedForm != null) F = Meta.linkedForm.ParentForm;
            bool result = ToMeta.Edit(F, "default", false);
            string listtype = ToMeta.DefaultListType;
            DataRow R = ToMeta.SelectOne(listtype, checkfilter, null, null);
            if (R != null) ToMeta.SelectRow(R, listtype);

            return idcostpartition;
        }

        public static object importRevenuePartitionDetail(MetaData Meta) {
            OpenFileDialog _op = new OpenFileDialog();
            IOpenFileDialog op = MetaFactory.factory.create<IOpenFileDialog>().init(_op);
            DialogResult dr = op.ShowDialog();
            if (dr != DialogResult.OK) {
                return null;
            }

            string fileName = op.FileName;

            DataTable T = new DataTable();
            //Aggiungere a T le colonne del foglio excel
            T.Columns.Add(new DataColumn("quota", typeof(decimal)));
            T.Columns.Add(new DataColumn("codice1", typeof(string)));
            T.Columns.Add(new DataColumn("codice2", typeof(string)));
            T.Columns.Add(new DataColumn("codice3", typeof(string)));
            ExcelImport x = new ExcelImport();
            x.ImportTable(fileName, T);

            if (T.Rows.Count == 0) return null;

            frmAskRevenuePartitionDetail f = new frmAskRevenuePartitionDetail();
            MetaFactory.factory.getSingleton<IFormCreationListener>().create(f, null);
            DialogResult dr2 = f.ShowDialog();
            if (dr != DialogResult.OK) {
                return null;
            }

            vistaRevenuePartition ds = new vistaRevenuePartition();

            MetaData metaRevenue = Meta.Dispatcher.Get("revenuepartition");
            metaRevenue.SetDefaults(ds.revenuepartition);

            MetaData metaRevenueDetail = Meta.Dispatcher.Get("revenuepartitiondetail");
            metaRevenueDetail.SetDefaults(ds.revenuepartitiondetail);
            QueryHelper QHS = Meta.Conn.GetQueryHelper();

            //DataTable cfg = meta.Conn.RUN_SELECT("config", "ayear,idsor1,idsor2,idsor3", null, QHS.CmpEq("ayear", meta.GetSys("esercizio")), null, false);
            object idsorkind1 = Meta.GetSys("idsortingkind1");
            object idsorkind2 = Meta.GetSys("idsortingkind2");
            object idsorkind3 = Meta.GetSys("idsortingkind3");

            DataRow main = metaRevenue.Get_New_Row(null, ds.revenuepartition);
            main["revenuepartitioncode"] = f.txtCodice.Text;
            main["title"] = f.txtDenominazione.Text;
            //bool usePerc = true;
            string fieldToUse = "rate";
            if (f.rdbRicavi.Checked) {
                //usePerc = false;
                fieldToUse = "amount";
                main["kind"] = "C";
            }
            else {
                main["kind"] = "P";
            }

            if (f.chkAttivo.Checked) {
                main["active"] = "S";
            }
            else {
                main["active"] = "N";
            }

            foreach (DataRow r in T.Select()) {
                DataRow det = metaRevenueDetail.Get_New_Row(main, ds.revenuepartitiondetail);
                det[fieldToUse] = r["quota"];
                object code1 = r["codice1"];
                object code2 = r["codice2"];
                object code3 = r["codice3"];

                object idsor1 = DBNull.Value;
                object idsor2 = DBNull.Value;
                object idsor3 = DBNull.Value;

                if (idsorkind1 != DBNull.Value && code1.ToString() != "") {
                    idsor1 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind1), QHS.CmpEq("sortcode", code1.ToString().Trim())),
                        "idsor");
                    if (idsor1 == null) {
                        idsor1 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code1 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind1"), "Errore");
                    }
                }

                if (idsorkind2 != DBNull.Value && code2.ToString() != "") {
                    idsor2 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind2), QHS.CmpEq("sortcode", code2.ToString().Trim())),
                        "idsor");
                    if (idsor2 == null) {
                        idsor2 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code2 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind2"), "Errore");
                    }
                }

                if (idsorkind3 != DBNull.Value && code3.ToString() != "") {
                    idsor3 = Meta.Conn.DO_READ_VALUE("sorting",
                        QHS.AppAnd(QHS.CmpEq("idsorkind", idsorkind3), QHS.CmpEq("sortcode", code3.ToString().Trim())),
                        "idsor");
                    if (idsor3 == null) {
                        idsor3 = DBNull.Value;
                        MetaFactory.factory.getSingleton<IMessageShower>().Show(
                            "Codice " + code3 + " non trovato per coordinata analitica " +
                            Meta.GetSys("titlesortingkind3"), "Errore");
                    }
                }

                det["idsor1"] = idsor1;
                det["idsor2"] = idsor2;
                det["idsor3"] = idsor3;
            }

            PostData Post = Meta.Get_PostData();

            Post.InitClass(ds, Meta.Conn);
            if (!Post.DO_POST()) {
                MetaFactory.factory.getSingleton<IMessageShower>()
                    .Show("Errore durante il salvataggio del piano di ripartizione");
                return null;
            }

            object idrevenuepartition = main["idrevenuepartition"];
            MetaData ToMeta = Meta.Dispatcher.Get("revenuepartition");
            string checkfilter = QHS.CmpEq("idrevenuepartition", idrevenuepartition);
            ToMeta.ContextFilter = checkfilter;
            Form F = null;
            if (Meta.linkedForm != null) F = Meta.linkedForm.ParentForm;
            bool result = ToMeta.Edit(F, "default", false);
            string listtype = ToMeta.DefaultListType;
            DataRow R = ToMeta.SelectOne(listtype, checkfilter, null, null);
            if (R != null) ToMeta.SelectRow(R, listtype);

            return idrevenuepartition;
        }


        public void EditRelatedEntry(MetaData Meta, DataRow R) {
            EditRelatedEntry(Meta, GetIdForDocument(R));
        }


        /// <summary>
        /// Opens an entry given the idrelated field. 
        /// </summary>
        /// <param name="Meta"></param>
        /// <param name="idrelated"></param>
        public void EditRelatedEntry(MetaData Meta, string idrelated) {
            if (idrelated == null) return;
            MetaData ToMeta = Meta.Dispatcher.Get("entry");
            if (ToMeta == null) return;
            string checkfilter = QHS.CmpEq("idrelated", idrelated);
            checkfilter = QHS.AppAnd(checkfilter, QHS.CmpEq("yentry", esercizio));
            ToMeta.ContextFilter = checkfilter;
            Form F = null;
            if (Meta.linkedForm != null) F = Meta.linkedForm.ParentForm;
            bool result = ToMeta.Edit(F, "default", false);
            string listtype = ToMeta.DefaultListType;
            DataRow R = ToMeta.SelectOne(listtype, checkfilter, null, null);
            if (R != null) ToMeta.SelectRow(R, listtype);
        }

        /// <summary>
        /// Metodo che visualizza la scrittura tramite la chiamata alla chiave di entry (yentry, nentry)
        /// </summary>
        /// <param name="Meta"></param>
        /// <param name="rEntry"></param>
        public void EditRelatedEntryByKey(MetaData Meta, DataRow rEntry) {
            if (rEntry == null) return;
            int yentry = CfgFn.GetNoNullInt32(rEntry["yentry"]);
            int nentry = CfgFn.GetNoNullInt32(rEntry["nentry"]);
            if ((yentry == 0) || (nentry == 0)) return;
            MetaData ToMeta = Meta.Dispatcher.Get("entry");
            if (ToMeta == null) return;
            string checkfilter = QHS.AppAnd(QHS.CmpEq("yentry", yentry), QHS.CmpEq("nentry", nentry));
            ToMeta.ContextFilter = checkfilter;
            Form F = null;
            if (Meta.linkedForm != null) F = Meta.linkedForm.ParentForm;
            bool result = ToMeta.Edit(F, "default", false);
            string listtype = ToMeta.DefaultListType;
            DataRow R = ToMeta.SelectOne(listtype, checkfilter, null, null);
            if (R != null) ToMeta.SelectRow(R, listtype);
        }

        public Hashtable idaccmotivedebitForIdReg = new Hashtable();

        public object GetSupplierAccountForRegistry(object serviceIDAcc, object idreg) {
            object idaccmotive = serviceIDAcc;
            if (idaccmotive == DBNull.Value || idaccmotive == null) {
                idaccmotive = idaccmotivedebitForIdReg[idreg];
                if (idaccmotive == null) {
                    idaccmotive = Conn.DO_READ_VALUE("registry", QHS.CmpEq("idreg", idreg), "idaccmotivedebit");
                    idaccmotivedebitForIdReg[idreg] = idaccmotive;
                }

            }


            if (idaccmotive != DBNull.Value && idaccmotive != null) {
                var idaccs = GetAccMotiveDetails(idaccmotive);
                //Conn.RUN_SELECT("accmotivedetail", "*", null,
                //QHS.AppAnd(QHS.CmpEq("idaccmotive", idaccmotive), QHS.CmpEq("ayear", esercizio)), null, true);
                if (idaccs.Length > 0) {
                    return idaccs[0]["idacc"];
                }
            }

            return rConfig["idacc_supplier"];
        }



        public Hashtable idaccmotivecreditForIdReg = new Hashtable();

        public object GetCustomerAccountForRegistry(object ServiceIDAcc, object idreg) {
            object idaccmotive = ServiceIDAcc;
            if (idaccmotive == DBNull.Value || idaccmotive == null) {
                idaccmotive = idaccmotivecreditForIdReg[idreg];
                if (idaccmotive == null) {
                    idaccmotive = Conn.DO_READ_VALUE("registry", QHS.CmpEq("idreg", idreg), "idaccmotivecredit");
                    idaccmotivecreditForIdReg[idreg] = idaccmotive;
                }

            }

            if (idaccmotive != DBNull.Value) {
                var accounts = GetAccMotiveDetails(idaccmotive);
                if (accounts.Length > 0) return accounts[0]["idacc"];
            }
            //DataTable idaccs = Conn.RUN_SELECT("accmotivedetail", "*", null,
            //    QHS.AppAnd(QHS.CmpEq("idaccmotive", idaccmotive), QHS.CmpEq("ayear", esercizio)), null, true);
            //if (idaccs.Rows.Count > 0) {
            //    return idaccs.Rows[0]["idacc"];
            //}


            return rConfig["idacc_customer"];
        }


        public object GetAccountForCustomer() {
            return rConfig["idacc_customer"];
        }

        public object GetAccountForSupplier() {
            return rConfig["idacc_supplier"];
        }

        public object GetAccountForIvaRefund() {
            if (rConfig["idacc_ivarefund"] != DBNull.Value) {
                return rConfig["idacc_ivarefund"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForIvaPayment() {
            if (rConfig["idacc_ivapayment"] != DBNull.Value) {
                return rConfig["idacc_ivapayment"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }

        public object GetAccountForIvaPaymentSplit() {
            if (rConfig["idacc_ivapaymentsplit"] != DBNull.Value) {
                return rConfig["idacc_ivapaymentsplit"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }


        public object GetAccountForIvaRefund12() {
            if (rConfig["idacc_ivarefund12"] != DBNull.Value) {
                return rConfig["idacc_ivarefund12"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForIvaPayment12() {
            if (rConfig["idacc_ivapayment12"] != DBNull.Value) {
                return rConfig["idacc_ivapayment12"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }


        public object GetAccountForMainIvaRefund() {
            if (rConfig["idacc_mainivarefund"] != DBNull.Value) {
                return rConfig["idacc_mainivarefund"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForMainIvaPayment() {
            if (rConfig["idacc_mainivapayment"] != DBNull.Value) {
                return rConfig["idacc_mainivapayment"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }

        public object GetAccountForMainIvaRefundInternal() {
            if (rConfig["idacc_mainivarefund_internal"] != DBNull.Value) {
                return rConfig["idacc_mainivarefund_internal"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForMainIvaPaymentInternal() {
            if (rConfig["idacc_mainivapayment_internal"] != DBNull.Value) {
                return rConfig["idacc_mainivapayment_internal"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }

        public object GetAccountForMainIvaRefund12() {
            if (rConfig["idacc_mainivarefund12"] != DBNull.Value) {
                return rConfig["idacc_mainivarefund12"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForMainIvaPayment12() {
            if (rConfig["idacc_mainivapayment12"] != DBNull.Value) {
                return rConfig["idacc_mainivapayment12"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }

        public object GetAccountForMainIvaRefundInternal12() {
            if (rConfig["idacc_mainivarefund_internal12"] != DBNull.Value) {
                return rConfig["idacc_mainivarefund_internal12"];
            }
            else {
                return rConfig["idacc_customer"];
            }
        }

        public object GetAccountForMainIvaPaymentInternal12() {
            if (rConfig["idacc_mainivapayment_internal12"] != DBNull.Value) {
                return rConfig["idacc_mainivapayment_internal12"];
            }
            else {
                return rConfig["idacc_supplier"];
            }
        }




        /// <summary>
        /// Restituisce le scritture associate ad un documento
        /// </summary>
        /// <param name="R"></param>
        /// <returns></returns>
        public void GetEntryForDocument(DataRow R) {
            GetEntryForDocument(GetIdForDocument(R));
        }

        public void GetEntryCorrigeForDocument(DataRow R) {
            GetEntryForDocument(GetIdForDocumentCorrige(R));
        }

        public void GetEntryChildForDocument(DataRow R, string suffix) {
            GetEntryForDocument(GetIDForDocumentChild(R, suffix));
        }

        public void GetEntryForDocument(string idrelated) {
            GetEntryForDocument(idrelated, false);
        }

        public void attachToDataSet(DataSet d, string idrelated) {
            this.D = d;
            string filterrelated = QHS.AppAnd(QHS.CmpEq("idrelated", idrelated),
                QHS.CmpEq("yentry", esercizio));
            DataTable T = d.Tables["entry"];
            Conn.RUN_SELECT_INTO_TABLE(T, null, filterrelated, null, true);
            currentRow = null;
            if (T.Rows.Count == 0) {
                return;
            }

            DataTable tt = d.Tables["entrydetail"];
            DataTable tt3 = d.Tables["entrydetailaccrual"];
            currentRow = T.Rows[0];
            foreach (DataRow entry in T.Select()) {
                Conn.RUN_SELECT_INTO_TABLE(tt, null, QHS.CmpKey(entry), null, true);

                Conn.RUN_SELECT_INTO_TABLE(tt3, null, QHS.CmpKey(entry), null, true);
                foreach (DataRow r3 in tt3.Select(QHC.CmpKey(entry))) r3.Delete();
            }

            scrittureAzzerate.Clear();
        }




        public void GetEntryForDocument(string idrelated, bool silent) {
            scrittureAzzerate.Clear();
            currentRow = null;
            D = new DataSet();
            string filterrelated = QHS.AppAnd(QHS.CmpEq("idrelated", idrelated),
                QHS.CmpEq("yentry", esercizio), QHS.FieldIn("identrykind", new object[] {1, 2, 8}));
            DataTable T = Conn.RUN_SELECT("entry", "*", null, filterrelated, null, true);
            D.Tables.Add(T);
            if (T.Rows.Count == 0) {
                DataTable TT2 = Conn.CreateTableByName("entrydetail", "*");
                D.Tables.Add(TT2);
                D.Relations.Add("entryentrydetail",
                    new DataColumn[] {T.Columns["yentry"], T.Columns["nentry"]},
                    new DataColumn[] {TT2.Columns["yentry"], TT2.Columns["nentry"]}, false);
                return;
            }

            DataTable TT = Conn.CreateTableByName("entrydetail", "*", false);
            D.Tables.Add(TT);
            D.Relations.Add("entryentrydetail",
                new DataColumn[] {T.Columns["yentry"], T.Columns["nentry"]},
                new DataColumn[] {TT.Columns["yentry"], TT.Columns["nentry"]}, false);
            DataTable TT3 = Conn.CreateTableByName("entrydetailaccrual", "*", false);
            D.Tables.Add(TT3);
            D.Relations.Add("entrydetailentrydetailaccrual",
                new DataColumn[] {TT.Columns["yentry"], TT.Columns["nentry"], TT.Columns["ndetail"]},
                new DataColumn[]
                    {TT3.Columns["yentry"], TT3.Columns["nentry"], TT3.Columns["ndetail"]},
                false);
            foreach (DataRow entry in T.Rows) {

                Conn.RUN_SELECT_INTO_TABLE(TT, null, QHS.CmpKey(entry), null, true);


                Conn.RUN_SELECT_INTO_TABLE(TT3, null, QHS.CmpKey(entry), null, true);

                if (TT3.Select(QHC.CmpKey(entry)).Length > 0) {
                    if (!silent) {
                        showMessage("Ci sono ratei associati alle scritture che saranno scollegati. Sarà " +
                                    "necessario ricollegarli a mano", "Avviso", false);
                    }

                    foreach (DataRow R3 in TT3.Select(QHC.CmpKey(entry))) R3.Delete();
                }
            }

            currentRow = T.Rows[0];

            foreach (DataTable t in D.Tables) {
                RowChange.SetOptimized(t, true);
            }

            //string filterprev= GetData.MergeFilters(filterrelated,
            //	"(yentry<"+QueryCreator.quotedstrvalue(esercizio-1,true)+")");
            //int num= Conn.RUN_SELECT_COUNT("entry",filterprev,false);
            //if (num==0) SottraiRatei=false; //Non c'è necessita di sotrarre risconti poichè non ve ne sono.
        }

        /// <summary>
        /// Returns the array of idsor existent in a DataRow
        /// </summary>
        /// <param name="R"></param>
        /// <returns></returns>
        public static object[] GetIDSor(DataRow R) {
            if (R == null) return null;
            int n = 1;
            while (R.Table.Columns["idsor" + n] != null) n++;
            n--;
            object[] res = new object[n];
            for (int i = 1; i <= n; i++) {
                res[i - 1] = R["idsor" + i];
            }

            return res;
        }

        private object description;
        private object Doc;
        private object DocDate;
        private object idrelated;

        public DataRow setCurrDate(object aDate) {
            if (aDate == null || aDate == DBNull.Value) {
                //non è richiesta alcuna data, va bene tutto
                if (currentRow != null) return currentRow;
                if (D.Tables["entry"].Select().Length >= 1) {
                    currentRow = D.Tables["entry"].Select()[0];
                    return currentRow;
                }

                return null;
            }

            //Cerca una scrittura alla data richiesta
            foreach (DataRow r in D.Tables["entry"].Select()) {
                DateTime rDate = (DateTime) r["adate"];
                if (rDate.Year != ((DateTime) aDate).Year) continue;
                if (rDate.Month != ((DateTime) aDate).Month) continue;
                if (rDate.Day != ((DateTime) aDate).Day) continue;
                currentRow = r;
                return r;
            }

            //crea la scrittura alla data richiesta
            currentRow = myAddEntry((DateTime) aDate);
            return currentRow;
        }

        public DataRow setUniqueCurrDate(object aDate) {
            if (currentRow != null) {
                //cambia la data corrente
                currentRow["adate"] = aDate;
                return currentRow;
            }

            if (D.Tables["entry"].Select().Length > 0) {
                //cambia la data corrente
                currentRow = D.Tables["entry"].Select()[0];
                currentRow["adate"] = aDate;
                return currentRow;
            }

            //crea la scrittura alla data richiesta
            currentRow = myAddEntry((DateTime) aDate);
            return currentRow;
        }

        public DataRow currentRow;

        /// <summary>
        /// Imposta i dati principali della scrittura
        /// </summary>
        /// <param name="description"></param>
        /// <param name="adate"></param>
        /// <param name="Doc"></param>
        /// <param name="DocDate"></param>
        /// <param name="idrelated"></param>
        /// <returns></returns>
        public DataRow SetUniqueEntry(object description, object adate,
            object Doc, object DocDate, object idrelated) {
            this.description = description;
            this.Doc = Doc;
            this.DocDate = DocDate;
            this.idrelated = idrelated;
            DataRow r = setUniqueCurrDate(adate);
            string S = description.ToString();
            if (S.Length > 150) {
                r["description"] = S.Substring(0, 150);
            }
            else {
                r["description"] = description;
            }

            r["doc"] = Doc;
            r["docdate"] = DocDate;
            this.saldo = 0;
            return r;
        }

        /// <summary>
        /// Imposta i dati principali della scrittura
        /// </summary>
        /// <param name="description"></param>
        /// <param name="adate"></param>
        /// <param name="Doc"></param>
        /// <param name="DocDate"></param>
        /// <param name="idrelated"></param>
        /// <returns></returns>
        public DataRow SetEntry(object description, object adate,
            object Doc, object DocDate, object idrelated) {
            this.description = description;
            this.Doc = Doc;
            this.DocDate = DocDate;
            this.idrelated = idrelated;
            DataRow r = setCurrDate(adate);
            string S = description.ToString();
            if (S.Length > 150) {
                r["description"] = S.Substring(0, 150);
            }
            else {
                r["description"] = description;
            }

            r["doc"] = Doc;
            r["docdate"] = DocDate;
            this.saldo = 0;
            return r;
        }

        private DataRow myAddEntry(DateTime adate) {
            DataTable Entry = D.Tables["entry"];
            DataRow R;

            MetaEntry.SetDefaults(Entry);
            R = MetaEntry.Get_New_Row(null, Entry);

            string S = description.ToString();
            if (S.Length > 150) {
                R["description"] = S.Substring(0, 150);
            }
            else {
                R["description"] = description;
            }

            this.saldo = 0;
            R["doc"] = Doc;
            R["docdate"] = DocDate;
            R["idrelated"] = idrelated;
            R["adate"] = adate;
            return R;
        }

        public DataRow AddEntryDetail(
            object idacc, object idreg, object idupb, decimal amount,
            object[] idsor, object idepexp, object idepacc, object idrelated) {
            return AddEntryDetail(idacc, idreg, idupb, amount, idsor, DBNull.Value, idepexp, idepacc, idrelated);
        }


        public DataRow AddEntryDetail(
            object idacc, object idreg, object idupb, decimal amount,
            object[] idsor, object idaccmotive, object idepexp, object idepacc, object idrelated) {
            return AddEntryDetail(idacc, idreg, idupb, DBNull.Value, DBNull.Value, amount, idsor, idaccmotive, idepexp,
                idepacc, idrelated, DBNull.Value);
        }

        object getidUpbFromIdEpexp(object idepexp) {
            if (idepexp == DBNull.Value) return DBNull.Value;
            if (D.Tables.Contains("epexpyear")) {
                DataRow[] f = D.Tables["epexpyear"].Select(QHC.CmpEq("idepexp", idepexp));
                if (f.Length > 0) return f[0]["idupb"];
            }

            object idupb = Conn.DO_READ_VALUE("epexpyear",
                QHS.AppAnd(QHS.CmpEq("idepexp", idepexp), QHS.CmpEq("ayear", esercizio)), "idupb");
            return idupb ?? DBNull.Value;
        }




        /// <summary>
        /// Adds an amount to a specified entry, creating a new one if it not exists
        /// </summary>
        /// <param name="D"></param>
        /// <param name="idacc"></param>
        /// <param name="idreg"></param>
        /// <param name="idupb"></param>
        /// <param name="amount"></param>
        /// <param name="idsor"></param>
        /// <returns></returns>
        public DataRow AddEntryDetail(
            object idacc, object idreg, object idupb, object start, object stop, decimal amount,
            object[] idsor, object idaccmotive, object idepexp, object idepacc, object idrelated, object description) {
            DataRow Entry = currentRow;
            DataTable EntryDetail = D.Tables["entrydetail"];
            DataRow R = null;

            if (idepexp == null) idepexp = DBNull.Value;
            if (idepacc == null) idepacc = DBNull.Value;

            if (idupb == DBNull.Value) {
                idupb = getidUpbFromIdEpexp(idepexp);
            }


            //if (idupb == DBNull.Value) {
            //    idupb = getidUpbFromIdEpexp(idepexp);
            //}

            //if (idacc == DBNull.Value || idacc == null) {
            //    MetaFactory.factory.getSingleton<IMessageShower>().Show("idacc null");
            //}

            if (description == null) {
                description = DBNull.Value;
            }
            else {
                if (description.ToString().Length > 400) {
                    description = description.ToString().Substring(0, 400);
                }
            }

            this.saldo += amount;


            MetaEntryDetail.SetDefaults(EntryDetail);
            MetaData.SetDefault(EntryDetail, "idacc", idacc);
            R = MetaEntryDetail.Get_New_Row(Entry, EntryDetail);
            R["idreg"] = idreg;
            if (EntryDetail.Columns.Contains("idaccmotive")) R["idaccmotive"] = idaccmotive;
            R["idupb"] = idupb;
            R["amount"] = amount;
            if (EntryDetail.Columns.Contains("competencystart")) R["competencystart"] = start;
            if (EntryDetail.Columns.Contains("competencystop")) R["competencystop"] = stop;
            if (idsor != null) {
                for (int i = 1; i <= idsor.Length; i++) {
                    R["idsor" + i.ToString()] = idsor[i - 1];
                }
            }

            if (EntryDetail.Columns.Contains("idepexp")) {
                R["idepexp"] = idepexp;
            }

            if (EntryDetail.Columns.Contains("idepacc")) {
                R["idepacc"] = idepacc;
            }

            R["idexp"] = DBNull.Value;
            R["idinc"] = DBNull.Value;
            if (idrelated != null && EntryDetail.Columns.Contains("idrelated")) {
                R["idrelated"] = idrelated;

                if (idrelated.ToString().StartsWith("expense§") & !idrelated.ToString().EndsWith("debit")) {
                    R["idexp"] = CfgFn.GetNoNullInt32(idrelated.ToString().Replace("expense§", ""));
                }

                if (idrelated.ToString().StartsWith("income§") & !idrelated.ToString().EndsWith("credit")) {
                    R["idinc"] = CfgFn.GetNoNullInt32(idrelated.ToString().Replace("income§", ""));
                }
            }


            R["description"] = description;
            //}
            //else {
            //    R["amount"] = CfgFn.GetNoNullDecimal(R["amount"]) + amount;
            //    R["description"] = description;
            //}
            return R;
        }


        public void RemoveEmptyDetails() {
            RemoveEmptyDetails(false);
        }

        string detailSignature(DataRow detail) {
            string res = "";
            foreach (string field in new[] {
                "idacc", "idreg", "idupb", "idaccmotive", "yentry", "nentry",
                "competencystart", "competencystop", "idsor1", "idsor2", "idsor3",
                "description", "autogenerated", "idrelated", "idepexp", "idepacc"
            }) {
                res += "#" + detail[field].ToString();
            }

            if (detail.RowState == DataRowState.Added) {
                res += "#" + CfgFn.GetNoNullDecimal(detail["amount"]).ToString("n");
            }
            else {
                res += "#" + CfgFn.GetNoNullDecimal(detail["amount", DataRowVersion.Original]).ToString("n");
            }

            return res;
        }

        public void RemoveEmptyDetails(bool NonSottrarreRatei) {
            DataTable Det = D.Tables["entrydetail"];
            Dictionary<string, DataRow> added = new Dictionary<string, DataRow>();
            foreach (DataRow r in Det.Select()) {
                if (r.RowState != DataRowState.Added) continue;
                added[detailSignature(r)] = r;
            }

            foreach (DataRow R in Det.Select()) {
                if (R.RowState == DataRowState.Deleted) continue;
                if (R.RowState == DataRowState.Detached) continue;
                if (CfgFn.GetNoNullDecimal(R["amount"]) == 0) {
                    string thisSign = detailSignature(R);
                    DataRow foundRow;
                    if (added.TryGetValue(thisSign, out foundRow)) {
                        R["amount"] = foundRow["amount"];
                        foundRow.RejectChanges();
                        added.Remove(thisSign);
                        continue;
                    }

                    //Altrimenti procede a cancellare R
                    R.Delete();
                }
            }

            DataTable Main = D.Tables["entry"];
            foreach (DataRow rMain in Main.Select()) {
                if (Det.Select(QHC.CmpKey(rMain)).Length == 0) {
                    rMain.Delete();
                }
            }
        }

        public void ClearDetails() {
            ClearDetails(currentRow);
        }


        public void undoDetailChanges() {
            if (D.Tables.Contains("entry")) D.Tables["entry"].RejectChanges();
            if (D.Tables.Contains("entrydetail")) D.Tables["entrydetail"].RejectChanges();
            if (D.Tables.Contains("entrydetailaccrual")) D.Tables["entrydetailaccrual"].RejectChanges();
        }


        //Il credito è negativo quando si chiude positivo quando si apre. Lo chiamiamo col segno giusto quando facciamo le scritture di chiusura del debito, col segno opposto quando le ripristiniamo
        public void aggiornaCredito(int idepacc, decimal amount) {
            var currCredit = getCurrentCreditForIdEpAcc(idepacc);
            currCredit -= amount; //se è una chiusura il segno è negativo quindi lo ripristiniamo cambiandolo di segno
            __listaCreditiEpAcc[idepacc] = currCredit;

            //if (listaCreditiEpAcc.ContainsKey(idepacc)) {
            //    listaCreditiEpAcc[idepacc] += amount;
            //}
            //else {
            //    listaCreditiEpAcc[idepacc] = amount;
            //}
        }

        //Il debito è positivo quando si chiude debito quando si apre 
        public void aggiornaDebito(int idepexp, decimal amount) {
            var currDebit = getCurrentDebitForIdEpExp(idepexp);
            //QueryCreator.MarkEvent($"Debit for idepexp {idepexp} was {amount}");
            currDebit += amount;
            //QueryCreator.MarkEvent($"Debit for idepexp {idepexp} has been variated for {amount} and now is {amount}");
            __listaDebitiEpExp[idepexp] = currDebit;

            //if (listaDebitiEpExp.ContainsKey(idepexp)) {
            //    listaDebitiEpExp[idepexp] += amount;
            //}
            //else {
            //    listaDebitiEpExp[idepexp] = amount;
            //}
        }

        /// <summary>
        /// Sets to 0 all entrydetail amount
        /// </summary>
        public void ClearDetails(DataRow mainEntry) {
            string k = mainEntry["idrelated"] + "*" + mainEntry["adate"];
            if (scrittureAzzerate.ContainsKey(k)) return;

            __listaDebitiEpExp.Clear();
            __listaCreditiEpAcc.Clear();
            clearSubDetails(mainEntry);
        }

        public void clearSubDetails(DataRow subEntry) {
            string k = subEntry["idrelated"] + "*" + subEntry["adate"];
            if (scrittureAzzerate.ContainsKey(k)) return;
            scrittureAzzerate[k] = true;
            DataTable Det = D.Tables["entrydetail"];
            foreach (DataRow R in Det.Select(QHC.CmpKey(subEntry))) {
                var idacc = R["idacc"];
                if (R["idepexp"] != DBNull.Value) {
                    int idepexp = CfgFn.GetNoNullInt32(R["idepexp"]);
                    if (isDebit(idacc)) {
                        aggiornaDebito(idepexp, -CfgFn.GetNoNullDecimal(R["amount"]));
                    }
                }

                if (R["idepacc"] != DBNull.Value) {
                    int idepacc = CfgFn.GetNoNullInt32(R["idepacc"]);
                    if (isCredit(idacc)) {
                        aggiornaCredito(idepacc, -CfgFn.GetNoNullDecimal(R["amount"]));
                    }
                }


                R["amount"] = 0;
            }
        }

        private Dictionary<string, bool> scrittureAzzerate = new Dictionary<string, bool>();

        public void setFlagAccountUsage(object idacc, int flag) {
            if (idacc == DBNull.Value || idacc == null) return;
            flagAccount[idacc.ToString()] = flag;
        }

        public int flagAccountUsage(object idacc) {
            var strIdAcc = idacc.ToString();
            if (!flagAccount.ContainsKey(strIdAcc)) {
                DataRow rAcc = getRowIdAcc(idacc);
                int flag = rAcc == null ? 0 : CfgFn.GetNoNullInt32(rAcc["flagaccountusage"]);
                flagAccount[strIdAcc] = flag;
            }

            return flagAccount[strIdAcc];
        }

        public bool isImmobilizzazione(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 256) != 0;
        }

        public bool isCosto(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 320) != 0;
        }

        public bool isRicavo(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 128) != 0;
        }

        public bool isDebit(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 16) != 0;
        }

        public bool isCredit(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 32) != 0;
        }

        public bool isFondoAmmortamento(object idacc) {
            if (idacc == DBNull.Value) return false;
            return (flagAccountUsage(idacc) & 32768) != 0;
        }

        private Dictionary<string, int> flagAccount = new Dictionary<string, int>();
        private Dictionary<int, decimal> __listaDebitiEpExp = new Dictionary<int, decimal>();
        private Dictionary<int, decimal> __listaCreditiEpAcc = new Dictionary<int, decimal>();

        public decimal getCurrentDebitForIdEpExp(object idepexp) {
            int id = CfgFn.GetNoNullInt32(idepexp);
            if (id <= 0) return 0;
            if (__listaDebitiEpExp.ContainsKey(id)) return __listaDebitiEpExp[id];
            //decimal totaldebit = CfgFn.GetNoNullInt32( Conn.readValue("epexptotal", q.eq("ayear",esercizio)& q.eq("idepexp", idepexp), "debit"));            
            decimal totaldebit =
                CfgFn.GetNoNullDecimal(
                    Conn.DO_SYS_CMD($@"
                    select SUM(amount) from 
			            entrydetail ED  
	                    join account A on ED.idacc=A.idacc 
	                    WHERE   (ED.yentry<={esercizio}) and (A.flagaccountusage & 16 <>0) and ED.idepexp = {id}
                        ", true));

            //CfgFn.GetNoNullDecimal( Conn.readValue("epexptotal",q.eq("idepexp", idepexp), "sum(debit)"));    // q.eq("ayear",esercizio)& 
            //QueryCreator.MarkEvent($"Debit found for idepexp {id} is {totaldebit}");
            __listaDebitiEpExp[id] = totaldebit;
            return totaldebit;
        }

        public decimal getCurrentCreditForIdEpAcc(object idepacc) {
            int id = CfgFn.GetNoNullInt32(idepacc);
            if (id <= 0) return 0;
            if (__listaCreditiEpAcc.ContainsKey(id)) return __listaCreditiEpAcc[id];
            decimal totalcredit = -CfgFn.GetNoNullDecimal(
                Conn.DO_SYS_CMD($@"
                    select SUM(amount) from 
			            entrydetail ED  
	                    join account A on ED.idacc=A.idacc 
	                    WHERE   (ED.yentry<={esercizio}) and (A.flagaccountusage & 32 <>0) and ED.idepacc = {id}
                        ", true));

            //Conn.readValue("epacctotal",  q.eq("idepacc", idepacc), "sum(credit)")); // q.eq("ayear",esercizio)&
            __listaCreditiEpAcc[id] = totalcredit;
            return totalcredit;
        }

        public bool MainEntryExists() {
            if (D.Tables["entry"].Rows.Count == 0) return false;
            return true;
        }


        public DataRow[] GetAccMotiveDetails(object idaccmotive) {
            if (idaccmotive == DBNull.Value || idaccmotive == null) return new DataRow[0];
            string filteraccmotive = QHS.AppAnd(QHS.CmpEq("idaccmotive", idaccmotive),
                QHS.CmpEq("ayear", esercizio));
            if (AccMotiveDetail.Select(filteraccmotive).Length == 0) {
                Conn.RUN_SELECT_INTO_TABLE(AccMotiveDetail, null, filteraccmotive, null, true);
            }

            return AccMotiveDetail.Select(filteraccmotive);
        }

        public DataRow[] GetAccMotiveDetailsYear(object idaccmotive, object ayear) {
            if (idaccmotive == DBNull.Value || idaccmotive == null) return new DataRow[0];
            string filteraccmotive = QHS.AppAnd(QHS.CmpEq("idaccmotive", idaccmotive),
                QHS.CmpEq("ayear", ayear));
            if (AccMotiveDetail.Select(filteraccmotive).Length == 0) {
                Conn.RUN_SELECT_INTO_TABLE(AccMotiveDetail, null, filteraccmotive, null, true);
            }

            return AccMotiveDetail.Select(filteraccmotive);
        }
        public struct ripTable {
            public decimal amount;
            public object idsor1;
            public object idsor2;
            public object idsor3;
        }

        public ripTable[] getTabellaRipartizione(object idcostpartition, decimal amount) {
            if (idcostpartition == DBNull.Value || idcostpartition == null) return null;
            DataTable tMain = Conn.RUN_SELECT("costpartition", "*", null, QHS.CmpEq("idcostpartition", idcostpartition),
                null, false);
            DataTable tDetail = Conn.RUN_SELECT("costpartitiondetail", "*", null,
                QHS.CmpEq("idcostpartition", idcostpartition), null, false);
            if (tMain == null || tMain.Rows.Count == 0 || tDetail == null || tDetail.Rows.Count == 0) return null;
            bool useQuote = false;
            if (tMain.Rows[0]["kind"].ToString().ToUpper() == "P") {
                useQuote = true;
            }

            ripTable[] rip = new ripTable[tDetail.Rows.Count];
            if (!useQuote) {
                //verifica che l'importo sommato sia amount
                decimal sum = 0;
                foreach (DataRow r in tDetail.Select()) {
                    sum += CfgFn.GetNoNullDecimal(r["amount"]);
                }

                if (sum != amount) {
                    //ricalcola la tabella come percentuale
                    decimal sumperc = 0;
                    for (int i = 0; i < tDetail.Rows.Count; i++) {
                        decimal importo_tabella = CfgFn.GetNoNullDecimal(tDetail.Rows[i]["amount"]);
                        decimal perc = sum == 0 ? 1 : CfgFn.Round(importo_tabella / sum, 6);
                        if (i == tDetail.Rows.Count - 1) {
                            //va  a tappo per l'ultima percentuale
                            perc = 1 - sumperc;
                        }
                        else {
                            sumperc += perc;
                        }

                        tDetail.Rows[i]["rate"] = perc;
                    }

                    useQuote = true;
                }
            }

            if (useQuote) {
                decimal amount_ripartito = 0;
                for (int i = 0; i < tDetail.Rows.Count; i++) {
                    decimal perc_tabella = CfgFn.GetNoNullDecimal(tDetail.Rows[i]["rate"]);
                    decimal importo_calcolato = CfgFn.Round(perc_tabella * amount, 2);
                    if (i == tDetail.Rows.Count - 1) {
                        //va  a tappo per l'ultimo importo
                        importo_calcolato = amount - amount_ripartito;
                    }
                    else {
                        amount_ripartito += importo_calcolato;
                    }

                    ripTable rt = new ripTable();
                    rt.amount = importo_calcolato;
                    rt.idsor1 = tDetail.Rows[i]["idsor1"];
                    rt.idsor2 = tDetail.Rows[i]["idsor2"];
                    rt.idsor3 = tDetail.Rows[i]["idsor3"];
                    rip[i] = rt;
                }
            }
            else {
                for (int i = 0; i < tDetail.Rows.Count; i++) {
                    decimal importo_assegnato = CfgFn.GetNoNullDecimal(tDetail.Rows[i]["amount"]);
                    ripTable rt = new ripTable();
                    rt.amount = importo_assegnato;
                    rt.idsor1 = tDetail.Rows[i]["idsor1"];
                    rt.idsor2 = tDetail.Rows[i]["idsor2"];
                    rt.idsor3 = tDetail.Rows[i]["idsor3"];
                    rip[i] = rt;
                }
            }

            return rip;
        }
        
        public void EffettuaScrittura(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR) {
            EffettuaScritturaSuddivisa(idepcontext, amount, idacc, idreg, idupb, RowForIDSOR, DBNull.Value);
        }


        public void EffettuaScritturaCollegataImpegnoBudget(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idepexp, object idepacc, object idrelated) {
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb, RowForIDSOR, DBNull.Value,
                idepexp, idepacc, idrelated);
        }


        public void EffettuaScritturaSuddivisa(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idcostpartition) {
            EffettuaScritturaSuddivisa(idepcontext, amount, idacc, idreg, idupb, RowForIDSOR, DBNull.Value,
                idcostpartition);
        }


        public void EffettuaScritturaSuddivisaImpegnoBudget(
            string idepcontext,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idcostpartition, object idepexp, object idepacc, object idrelated) {
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb, RowForIDSOR,
                DBNull.Value, idcostpartition, idepexp, idepacc, idrelated);
        }


        public void EffettuaScrittura(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idaccmotive) {
            EffettuaScritturaSuddivisa(idepcontext, amount, idacc, idreg, idupb,
                DBNull.Value, DBNull.Value,
                RowForIDSOR, idaccmotive, DBNull.Value);
        }

        public void EffettuaScritturaIdRelated(string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idaccmotive, string idrelated, object description) {
            EffettuaScritturaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb,
                RowForIDSOR, idaccmotive, DBNull.Value, DBNull.Value, idrelated, description);
        }


        public void EffettuaScritturaImpegnoBudget(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idaccmotive, object idepexp, object idepacc, object idrelated,
            object description = null) {
            if (description == null) description = DBNull.Value;
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb,
                DBNull.Value, DBNull.Value,
                RowForIDSOR, idaccmotive, DBNull.Value, idepexp, idepacc, idrelated, description);
        }



        public void EffettuaScritturaSuddivisa(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idaccmotive, object idcostpartition) {
            EffettuaScritturaSuddivisa(idepcontext, amount, idacc, idreg, idupb,
                DBNull.Value, DBNull.Value,
                RowForIDSOR, idaccmotive, idcostpartition);
        }

        public void EffettuaScritturaSuddivisaImpegnoBudget(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb,
            DataRow RowForIDSOR, object idaccmotive, object idcostpartition, object idepexp, object idepacc,
            object idrelated) {
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb,
                DBNull.Value, DBNull.Value,
                RowForIDSOR, idaccmotive, idcostpartition, idepexp, idepacc, idrelated, null);
        }


        public void EffettuaScrittura(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb, object start, object stop,
            DataRow RowForIDSOR, object idaccmotive, string description = null) {
            EffettuaScritturaSuddivisa(idepcontext,
                amount, idacc, idreg, idupb, start, stop,
                RowForIDSOR, idaccmotive, DBNull.Value, description);
        }



        public void EffettuaScritturaImpegnoBudget(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb, object start, object stop,
            DataRow RowForIDSOR, object idaccmotive, object idepexp, object idepacc, object idrelated,
            object description = null) {
            if (description == null) description = DBNull.Value;
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext,
                amount, idacc, idreg, idupb, start, stop,
                RowForIDSOR, idaccmotive, DBNull.Value, idepexp, idepacc, idrelated, description);
        }

        public void EffettuaScritturaSuddivisa(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb, object start, object stop,
            DataRow RowForIDSOR, object idaccmotive, object idcostpartition, string description = null) {
            EffettuaScritturaSuddivisaImpegnoBudget(idepcontext, amount, idacc, idreg, idupb, start, stop, RowForIDSOR,
                idaccmotive, idcostpartition, DBNull.Value, DBNull.Value, DBNull.Value, description);
        }

        public decimal signForAccount(object idacc, string idepcontext) {
            DataRow EPOp = epcontext.Select(QHC.CmpEq("idepcontext", idepcontext))[0];
            decimal segno = 1;

            if (EPOp["kind"].ToString().ToUpper() != "A") segno = -segno;

            DataRow RAccount = getRowIdAcc(idacc);
            if (RAccount == null) return 1;

            //La convenzione è che l'AVERE sia POSITIVO, il DARE sia NEGATIVO!!
            string filtertipoconto_C = QHC.CmpEq("idaccountkind", RAccount["idaccountkind"]);
            DataRow[] TipiConto = AccountKind.Select(filtertipoconto_C);
            if (TipiConto.Length == 0) {
                object conto = Conn.DO_READ_VALUE("account", QHS.CmpEq("idacc", idacc), "codeacc");
                showMessage("Conto " + conto + " NON CONFIGURATO (MANCA TIPOCONTO)!!");
                return 1;
            }

            DataRow TipoConto = TipiConto[0];

            //La convenzione è che l'AVERE sia POSITIVO, il DARE sia NEGATIVO!!
            if (TipoConto["flagda"].ToString().ToUpper() == "D") {
                segno = -segno;
            }

            return segno;
        }

        private Dictionary<string, DataRow> accountData = new Dictionary<string, DataRow>();

        public DataRow getRowIdAcc(object idacc) {
            if (idacc == null || idacc == DBNull.Value) {
                showMessage("Conto " + idacc + " ASSENTE!!");
                return null;
            }

            if (accountData.ContainsKey(idacc.ToString())) return accountData[idacc.ToString()];
            string filteraccount_C = QHC.CmpEq("idacc", idacc);
            string filteraccount = QHS.CmpEq("idacc", idacc);
            if (Account.Select(filteraccount_C).Length == 0) {
                Conn.RUN_SELECT_INTO_TABLE(Account, null, filteraccount, null, true);
            }

            DataRow[] found = Account.Select(filteraccount_C);
            if (found.Length == 0) {
                showMessage("Conto " + idacc + " NON TROVATO!!");
                return null;
            }

            accountData[idacc.ToString()] = found[0];
            return found[0];
        }

        public decimal saldo = 0;

        /// <summary>
        /// Effettua una sull'impegno di budget suddividendo nella ripartizione associata, ove specificata
        /// </summary>
        /// <param name="idepcontext"></param>
        /// <param name="amount"></param>
        /// <param name="idacc"></param>
        /// <param name="idreg"></param>
        /// <param name="idupb"></param>
        /// <param name="start"></param>
        /// <param name="stop"></param>
        /// <param name="RowForIDSOR"></param>
        /// <param name="idaccmotive"></param>
        /// <param name="idcostpartition"></param>
        /// <param name="idepexp"></param>
        /// <param name="idepacc"></param>
        /// <param name="idrelated"></param>
        /// <param name="description"></param>
        public void EffettuaScritturaSuddivisaImpegnoBudget(
            string idepcontext,
            //EP_functions EP, DataSet D, DataTable Account,
            decimal amount, object idacc, object idreg, object idupb, object start, object stop,
            DataRow RowForIDSOR, object idaccmotive, object idcostpartition, object idepexp, object idepacc,
            object idrelated, object description) {
            if (idreg == null) idreg = DBNull.Value;
            if (idupb == null) idupb = DBNull.Value;
            if (start == null) start = DBNull.Value;
            if (stop == null) stop = DBNull.Value;
            amount = CfgFn.Round(amount, 2);
            if (amount == 0) return;


            //L'assunto è che il gruppo B abbia segno opposto rispetto al gruppo A in 
            // qualsiasi operazione:
            decimal segno = signForAccount(idacc, idepcontext);

            DataRow RAccount = getRowIdAcc(idacc);
            if (RAccount == null) return;

            bool flagreg = false;
            bool flagupb = false;
            bool flagcompetency = false;
            if (RAccount["flagregistry"].ToString().ToUpper() == "S") flagreg = true;
            if (RAccount["flagupb"].ToString().ToUpper() == "S") flagupb = true;
            if (RAccount.Table.Columns.Contains("flagcompetency")) {
                if (RAccount["flagcompetency"].ToString().ToUpper() == "S") flagcompetency = true;
            }

            int flagaccountusage = CfgFn.GetNoNullInt32(RAccount["flagaccountusage"]);
            if ((flagaccountusage & 4416) != 0)
                idepacc = DBNull.Value; //Non considera l'acc. di budget per costi ed immobilizzazioni e f.acc.
            if ((flagaccountusage & 128) != 0) idepexp = DBNull.Value; //Non considera l'imp. di budget per ricavi


            ripTable[] listRip = null;

            if (idcostpartition != DBNull.Value) {
                listRip = getTabellaRipartizione(idcostpartition, amount);
            }

            if (listRip != null) {
                foreach (ripTable r in listRip) {
                    DataRow R =
                        AddEntryDetail(idacc,
                            flagreg ? idreg : DBNull.Value,
                            flagupb ? idupb : DBNull.Value,
                            flagcompetency ? start : DBNull.Value,
                            flagcompetency ? stop : DBNull.Value,
                            r.amount * segno,
                            new object[] {r.idsor1, r.idsor2, r.idsor3},
                            idaccmotive, idepexp, idepacc, idrelated, description);
                }
            }
            else {
                DataRow R = AddEntryDetail(idacc,
                    flagreg ? idreg : DBNull.Value,
                    flagupb ? idupb : DBNull.Value,
                    flagcompetency ? start : DBNull.Value,
                    flagcompetency ? stop : DBNull.Value,
                    amount * segno,
                    EP_functions.GetIDSor(RowForIDSOR), idaccmotive, idepexp, idepacc, idrelated, description);
            }
        }
    }

    public class TaxEntryHelper {
        DataAccess Conn;
        QueryHelper QHS;
        CQueryHelper QHC;
        DataTable taxsetup;
        DataTable taxregionsetup;
        DataTable taxpaymentpartsetup;

        public TaxEntryHelper(DataAccess Conn) {
            this.Conn = Conn;
            QHC = new CQueryHelper();
            QHS = Conn.GetQueryHelper();
            taxsetup = Conn.RUN_SELECT("taxsetup", "*", null,
                QHS.CmpEq("ayear", Conn.GetSys("esercizio")), null, true);
            taxregionsetup = Conn.RUN_SELECT("taxregionsetup", "*", null,
                QHS.CmpEq("ayear", Conn.GetSys("esercizio")), null, true);
            taxpaymentpartsetup = Conn.RUN_SELECT("taxpaymentpartsetup", "*", null,
                QHS.CmpEq("ayear", Conn.GetSys("esercizio")), null, true);
        }

        /// <summary>
        /// Restituisce una tabella con le % di applicazione per ogni idreg ipportuno
        ///  ..campi della tab. di ouput: idreg (int) , quota (decimal)
        /// </summary>
        /// <param name="taxcode"></param>
        /// <param name="idcity"></param>
        /// <param name="idfiscaltaxregion"></param>
        /// <returns></returns>
        public DataTable GetIdRegFor(object taxcode, object idcity, object idfiscaltaxregion) {
            DataRow[] found = taxsetup.Select(QHC.CmpEq("taxcode", taxcode));
            DataTable Result = new DataTable("result");
            Result.Columns.Add("idreg", typeof(int));
            Result.Columns.Add("quota", typeof(decimal));
            decimal One = 1;

            if (found.Length == 0) return null;
            int flag = CfgFn.GetNoNullInt32(found[0]["flag"]);
            if ((flag & 1) != 0) {
                DataRow R1 = Result.NewRow();
                R1["idreg"] = found[0]["paymentagency"];
                R1["quota"] = One;
                Result.Rows.Add(R1);
                return Result;
            }

            if ((flag & 2) != 0) {
                object idregion = DBNull.Value;
                if (idfiscaltaxregion != DBNull.Value) {
                    DataTable fiscalTaxRegion = Conn.RUN_SELECT("fiscaltaxregion", "*", null,
                        QHS.CmpEq("idfiscaltaxregion", idfiscaltaxregion), null, true);
                    if (fiscalTaxRegion.Rows.Count == 0) return Result;
                    DataRow rReg = fiscalTaxRegion.Rows[0];
                    if (rReg["idcountry"] != DBNull.Value) {
                        idregion = Conn.DO_READ_VALUE("geo_country",
                            QHS.CmpEq("idcountry", rReg["idcountry"]), "idregion");
                    }
                    else {
                        idregion = rReg["idregion"];
                    }
                }

                var idcountry = Conn.DO_READ_VALUE("geo_city", QHS.CmpEq("idcity", idcity), "idcountry");

                var rr = taxregionsetup.Select(
                    QHC.AppAnd(QHC.CmpEq("taxcode", taxcode),
                        QHC.DoPar(
                            QHC.AppOr(
                                QHC.DoPar(QHC.AppAnd(QHC.CmpEq("idplace", idregion), QHC.CmpEq("kind", "R"))),
                                QHC.DoPar(QHC.AppAnd(QHC.CmpEq("idplace", idcountry), QHC.CmpEq("kind", "P")))
                            )
                        )));
                if (rr.Length == 0) return Result;
                var r1 = Result.NewRow();
                r1["idreg"] = rr[0]["regionalagency"];
                r1["quota"] = One;
                Result.Rows.Add(r1);
                return Result;
            }

            if ((flag & 4) != 0) {
                DataRow[] rrr = taxpaymentpartsetup.Select(QHC.CmpEq("taxcode", taxcode));
                foreach (DataRow r in rrr) {
                    DataRow r1 = Result.NewRow();
                    r1["idreg"] = r["idreg"];
                    r1["quota"] = r["percentage"];
                    Result.Rows.Add(r1);
                }

                return Result;
            }

            return Result;
        }

        public DataTable GetIdRegFor(object taxcode, object idexp) {
            DataTable expensetax = Conn.RUN_SELECT("expensetax", "*", null,
                QHS.AppAnd(QHS.CmpEq("idexp", idexp),
                    QHS.DoPar(QHS.AppOr(QHS.IsNotNull("idcity"), QHS.IsNotNull("idfiscaltaxregion"))),
                    QHS.CmpEq("taxcode", taxcode)), null, true);
            if (expensetax.Rows.Count == 0) return GetIdRegFor(taxcode, DBNull.Value, DBNull.Value);
            DataRow r = expensetax.Rows[0];
            return GetIdRegFor(taxcode, r["idcity"], r["idfiscaltaxregion"]);
        }
    }


    public class AccMotiveManager : SearchTableManager {
        public AccMotiveManager(GroupBox G) : base(G, "motive", "tree") {
        }
    }

    public class AddAccMotiveFilter {
        public static string AddAmmDepFilter(string filter, DataAccess Conn) {
            QueryHelper QHS = Conn.GetQueryHelper();
            string userdb = Conn.GetSys("userdb").ToString().ToLower(); //
            if (userdb == "amministrazione")
                return QHS.AppAnd(filter, QHS.NullOrEq("flagamm", "S"));
            else
                return QHS.AppAnd(filter, QHS.NullOrEq("flagdep", "S"));
        }
    }

    public class SearchTableManager {
        GroupBox G;

        //DataTable AccMotive;
        ContextMenu CM;
        string filter;
        string searchfield;
        string tablename;
        string listtype;
        QueryHelper QHS;
        MetaData M;
        DataTable T;

        public SearchTableManager(GroupBox G, string searchfield, string listtype) {
            this.M = MetaData.GetMetaData(G.FindForm());
            DataSet DS = M.DS;
            QHS = M.QHS;
            this.G = G;
            this.searchfield = searchfield;
            this.listtype = listtype;
            CM = new ContextMenu(new MenuItem[] {new MenuItem("Cerca per descrizione", new EventHandler(Cerca))});
            G.ContextMenu = CM;

            string tag = G.Tag.ToString();
            filter = HelpForm.GetLastField(tag, 3);

            string texboxname = HelpForm.GetField(tag, 1);
            if (texboxname != null) {
                foreach (Control C in G.Controls) {
                    if (C.Name != texboxname) continue;
                    if (!typeof(TextBox).IsAssignableFrom(C.GetType())) break;
                    if (C.Tag == null) return;
                    string tag2 = HelpForm.GetStandardTag(C.Tag);
                    if (tag2 == null) return;
                    string ttag = HelpForm.GetStandardTag(tag2);

                    tablename = HelpForm.GetFieldLower(ttag, 0);
                    if (tablename == null) return;
                    if (DS.Tables[tablename] == null) return;
                    T = DS.Tables[tablename];
                    break;
                }
            }
        }

        void Cerca(object O, EventArgs E) {
            frmAskDescr FR = new frmAskDescr();
            MetaFactory.factory.getSingleton<IFormCreationListener>().create(FR, M.linkedForm);
            DialogResult D = FR.ShowDialog(M.linkedForm);
            if (D != DialogResult.OK) return;
            string myfilter =
                GetData.MergeFilters(QHS.AppAnd(filter, QHS.Like(searchfield, "%" + FR.txtDescrizione.Text + "%")), T);
            myfilter = QHS.AppAnd(myfilter, "(idaccmotive in (select idaccmotive from accmotiveusable))");
            MetaData.DoMainCommand(M.linkedForm, "choose." + tablename + "." + listtype + "." + myfilter);
        }
    }
}
